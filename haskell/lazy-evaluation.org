* Haskell: Lazy Evaluation

** Applicative and Normal Order Evaluation

#+begin_example
  === Lambda Calculus ===

  -- applicative order -> infinity
  -- normal order      -> 7

  λx.7 infinity

  -- applicative order -> (λx.xx)(λx.xx) ...
  -- normal order -> z

  (λy.z)((λx.xx)(λx.xx))
#+end_example

** Eager and Lazy Evaluation

#+begin_src scheme
  ;; === Scheme ===

  (define loop-forever (lambda () (loop-forever)))

  ;; eager evaluation -> infinity (stack overflow)
  ;; lazy evaluation  -> 7

  ((lambda (x) 7) (loop-forever))
#+end_src

** Pattern Matching

Pattern matching drives evaluation.

#+begin_src haskell
  -- === Example 1 ===

  -- f1 thunk = [thunk, thunk]
  f1 :: Maybe a -> [Maybe a]
  f1 m = [m, m]

  -- f2 thunk = case thunk of
  --              Nothing    -> []
  --              Just thunk -> [thunk]
  f2 :: Maybe a -> [a]
  f2 Nothing  = []
  f2 (Just x) = [x]

  -- === Example 2 ===

  -- thunk-x && thunk-y =
  --   case thunk-x of
  --     False -> False
  --     True  -> thunk-y
  (&&) :: Bool -> Bool -> Bool
  False && y      = False
  True  && y      = y

  -- thunk-x || thunk-y =
  --   case thunk-x of
  --     False -> thunk-y
  --     True  -> True
  (||) :: Bool -> Bool -> Bool
  False || y = y
  True  || y = True

  -- === Example 3 ===

  repeat :: a -> [a]
  repeat x = x : repeat x

  take :: Int -> [a] -> [a]
  take _ []     = []
  take n (x:xs) = if n <= 0
                  then []
                  else (x : take (n - 1) xs)

    take 2 (repeat 7)
  = take 2 (7 : repeat 7)
  = 7 : take (2 - 1) (repeat 7)
  = 7 : take 1 (repeat 7)
  = 7 : take 1 (7 : repeat 7)
  = 7 : 7 : take (1 - 1) (repeat 7)
  = 7 : 7 : take 0 (repeat 7)
  = 7 : 7 : []
#+end_src

** Space Usage

#+begin_src haskell
  foldl :: (b -> a -> b) -> [a] -> b
  foldl _ z []     = z
  foldl f z (x:xs) = foldl f (f z x) xs

  -- Since the value of the accumulator is not demanded until after
  -- recursing through the entire list, the accumulator builds up
  -- the unevaluated expression "(((0+1)+2)+3)"
    foldl (+) 0 [1,2,3]
  = foldl (+) (0+1) [2,3]
  = foldl (+) ((0+1)+2) [3]
  = foldl (+) (((0+1)+2)+3) []
  = (((0+1)+2)+3)
  = ((1+2)+3)
  = (3+3)
  = 6

  -- strict in its first argument
  seq :: a -> b -> b

  foldl' :: (a -> b -> a) -> a -> [b] -> a
  foldl' _ z [] = z
  foldl' f z (x:xs) = let z' = f z x in seq z' foldl' f z' xs

    foldl' (+) 0 [1,2,3]
  = foldl' (+) (0+1) [2,3]
  = foldl' (+) 1 [2,3]
  = foldl' (+) (1+2) [3]
  = foldl' (+) 3 [3]
  = foldl' (+) (3+3) []
  = foldl' (+) 6 []
  = 6
#+end_src

** Evaluation and Thunks

#+begin_example
  === expression ===

  (4, [1, 2])

  === evaluation / reduction ===

               >
  unevaluated | thunk
               >
               >
              | (thunk, thunk)
  WHNF        | (4, thunk)
              | (4, 1:thunk)
              | (4, 1:2:thunk)
               >
               >
  Normal Form | (4, 1:2:[])
               >
#+end_example
