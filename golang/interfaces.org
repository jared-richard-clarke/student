* Go Interfaces

** Sources

| source           | author              |
|------------------+---------------------|
| *A Tour of Go*   | go.dev              |
| Package ~errors~ | Go Standard Library |

** About

An interface type is a set of method signatures. It can store any concrete
(non-interface) value as long as that value implements the interface's methods.
Conceptually, an interface is a tuple: ~(type, value)~.

Type assertion provides access to an interface's underlying value. It returns
the underlying value and a boolean that reports whether the assertion succeeded.

#+begin_src go
  var number interface{} = 7

  // v == 7, ok == true
  v, ok := number.(int)
#+end_src

A type switch is a switch statement that performs a series of type assertions.

#+begin_src go
  switch v := i.(type) {
  case int64:
      return v + 7
  case float64:
      return v + 7.0
  default:
      return error.New("invalid type")
  }
#+end_src

The type ~any~ is an alias for any empty interface value. It is equal
to ~interface{}~ in all ways.

#+begin_src go
  type any interface{}
#+end_src

** Interfaces in the Go Standard Library

*** ~Reader~

#+begin_src go
  type Reader interface {
          Read(p []byte) (n int, err error)
  }
#+end_src

~strings.NewReader~ implements the ~io.Reader~ interface, which represents
the read end of a stream of data. ~io.Reader~ wraps the ~Read~ method.
~Read~ fills a given byte slice with data, returning the number of bytes
pushed to the slice and a potential error value. Returns ~io.EOF~ when the stream ends.

#+begin_src go
  package main

  import (
          "fmt"
          "io"
          "strings"
  )

  func main() {
          // r := &Reader{ s: "Hello, Reader!", i: 0, prevRune: -1 }
          r := strings.NewReader("Hello, Reader!")

          // b := []byte{ 0, 0, 0, 0, 0, 0, 0, 0 }
          b := make([]byte, 8)
          for {
                  n, err := r.Read(b)
                  fmt.Printf("n = %v err = %v b = %v\n", n, err, b)
                  fmt.Printf("b[:n] = %q\n", b[:n])
                  if err == io.EOF {
                          break
                  }
          }
  }

  // === Output ===
  //
  // n = 8 err = <nil> b = [72 101 108 108 111 44 32 82]
  // b[:n] = "Hello, R"
  // n = 6 err = <nil> b = [101 97 100 101 114 33 32 82]
  // b[:n] = "eader!"
  // n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
  // b[:n] = ""
#+end_src

*** ~Stringer~

#+begin_src go
  type Stringer interface {
          String() string
  }
#+end_src

The ~fmt~ package looks for the ~Stringer~ interface when printing values.
The ~Stringer~ interface as defined in the ~fmt~ package:

#+begin_src go
  package main

  import "fmt"

  type IPAddr [4]byte

  func (ip IPAddr) String() string {
          return fmt.Sprintf("%v.%v.%v.%v", ip[0], ip[1], ip[2], ip[3])
  }
  func main() {
          hosts := map[string]IPAddr{
                  "loopback":  {127, 0, 0, 1},
                  "googleDNS": {8, 8, 8, 8},
          }
          for name, ip := range hosts {
                  fmt.Printf("%v: %v\n", name, ip)
          }
  }

  // === without stringer method ===
  //
  // loopback: [127 0 0 1]
  // googleDNS: [8 8 8 8]

  // === with stringer method ===
  //
  // loopback: 127.0.0.1
  // googleDNS: 8.8.8.8
#+end_src

** The ~error~ Interface

Package ~errors~ provides functions to manipulate errors in Go. The entire package
is built around the ~error~ interface.

#+begin_src go
  // The built-in error interface type is the conventional interface for
  // representing an error condition. The nil value represents no error.
  type error interface {
      Error() string
  }

  // Each call to "New" returns a distinct value even if the texts are identical.
  func New(text string) error {
      return &errorString{text}
  }

  // The struct that implements the error interface.
  type errorString struct {
      s string
  }

  // The method that fulfills the error interface for "errorString".
  func (e *errorString) Error() string {
      return e.s
  }
#+end_src

*** Errors Joined

#+begin_src go
  // "Join" returns an error that wraps the given errors.
  func Join(errs ...error) error {
      n := 0
      for _, err := range errs {
          if err != nil {
              n++
          }
      }
      if n == 0 {
          return nil
      }
      e := &joinError{
          errs: make([]error, 0, n),
      }
      for _, err := range errs {
          if err != nil {
              e.errs = append(e.errs, err)
          }
      }
      return e
  }

  type joinError struct {
      errs []error
  }

  func (e *joinError) Error() string {
      if len(e.errs) == 1 {
          return e.errs[0].Error()
      }

      b := []byte(e.errs[0].Error())
      for _, err := range e.errs[1:] {
          b = append(b, '\n')
          b = append(b, err.Error()...)
      }
      return unsafe.String(&b[0], len(b))
  }

  func (e *joinError) Unwrap() []error {
      return e.errs
  }
#+end_src

*** Errors Unwrapped

#+begin_src go
  // "Unwrap" returns the result of calling the "Unwrap" method on "err", if "err's"
  // type contains an "Unwrap" method returning "error".
  // Otherwise, Unwrap returns nil.
  func Unwrap(err error) error {
      u, ok := err.(interface {
          Unwrap() error
      })
      if !ok {
          return nil
      }
      return u.Unwrap()
  }

  // "Is" reports whether any error in "err's" tree matches target.
  func Is(err, target error) bool {
      if err == nil || target == nil {
          return err == target
      }

      isComparable := reflectlite.TypeOf(target).Comparable()
      return is(err, target, isComparable)
  }

  func is(err, target error, targetComparable bool) bool {
      for {
          if targetComparable && err == target {
              return true
          }
          if x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {
              return true
          }
          switch x := err.(type) {
          case interface{ Unwrap() error }:
              err = x.Unwrap()
              if err == nil {
                      return false
              }
          case interface{ Unwrap() []error }:
              for _, err := range x.Unwrap() {
                  if is(err, target, targetComparable) {
                      return true
                  }
              }
              return false
          default:
              return false
          }
      }
  }

  // "As" finds the first error in "err's" tree that matches "target",
  // and if one is found, sets "target" to that error value and returns true.
  // Otherwise, it returns false.
  func As(err error, target any) bool {
      if err == nil {
          return false
      }
      if target == nil {
          panic("errors: target cannot be nil")
      }
      val := reflectlite.ValueOf(target)
      typ := val.Type()
      if typ.Kind() != reflectlite.Ptr || val.IsNil() {
          panic("errors: target must be a non-nil pointer")
      }
      targetType := typ.Elem()
      if targetType.Kind() != reflectlite.Interface && !targetType.Implements(errorType) {
          panic("errors: *target must be interface or implement error")
      }
      return as(err, target, val, targetType)
  }

  func as(err error, target any, targetVal reflectlite.Value, targetType reflectlite.Type) bool {
      for {
          if reflectlite.TypeOf(err).AssignableTo(targetType) {
              targetVal.Elem().Set(reflectlite.ValueOf(err))
              return true
          }
          if x, ok := err.(interface{ As(any) bool }); ok && x.As(target) {
              return true
          }
          switch x := err.(type) {
          case interface{ Unwrap() error }:
              err = x.Unwrap()
              if err == nil {
                  return false
              }
          case interface{ Unwrap() []error }:
              for _, err := range x.Unwrap() {
                  if err == nil {
                      continue
                  }
                  if as(err, target, targetVal, targetType) {
                      return true
                  }
              }
              return false
          default:
              return false
          }
      }
  }

  var errorType = reflectlite.TypeOf((*error)(nil)).Elem()
#+end_src
