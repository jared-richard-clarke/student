* Regular Expression Derivatives

** Sources

| source                                      | author                               |
|---------------------------------------------+--------------------------------------|
| *Regular-Expression Derivatives Reexamined* | Scott Owens, John Reppy, Aaron Turon |
| *Brzozowski derivative*                     | Wikipedia                            |
| *Regex Derivatives*                         | Ben Lynn                             |

** Definitions

- Σ :: finite alphabet

- Σ* :: finite set of strings over Σ

- a, b, c ... :: symbols

- u, v, w ... :: strings

- ε :: empty string

- L ⊆ Σ* :: language of Σ

*** Syntax

- r, s :: regular expressions *r* and *s*

| syntax | meaning                    |
|--------+----------------------------|
| ∅      | empty set                  |
| ε      | empty string               |
| a      | a ∈ Σ                      |
| r • s  | concatenation              |
| r*     | Kleene closure             |
| r + s  | logical *or* (alternation) |
| r & s  | logical *and*              |
| ¬r     | complement                 |

*** Semantics

- L⟦r⟧ ⊆ Σ* :: the language of the regular expression

| evaluation | meaning                         |
|------------+---------------------------------|
| L⟦∅⟧       | ∅                               |
| L⟦ε⟧       | ε                               |
| L⟦a⟧       | {a}                             |
| L⟦r • s⟧   | { u • v : u ∈ L⟦r⟧ ∧ v ∈ L⟦s⟧ } |
| L⟦r*⟧      | {ε} ∪ L⟦r • r*⟧                 |
| L⟦r + s⟧   | L⟦r⟧ ∪ L⟦s⟧                     |
| L⟦r & s⟧   | L⟦r⟧ ∩ L⟦s⟧                     |
| L⟦¬r⟧      | Σ* - L⟦r⟧                       |

*** Finite State Machine: DFA

- (Q, q₀, F, δ) :: deterministic finite automaton over alphabet Σ

- Q :: finite set of states

- q₀ ∈ Q :: start state

- F ⊆ Q :: final or accepting states

- δ : Q × Σ → Q :: state transition function

#+begin_example
  === Extending δ Over Strings ===
  
  δ'(q, ε)  = q
  δ'(q, au) = δ'(q', u), where q' = δ(q, a)

  === Language Accepted by DFA ===

  { u : δ'(q₀, u) ∈ F }
#+end_example

** Derivatives

- ∂_{u}L = { v : u • v ∈ L } :: the derivative of language L ⊆ Σ* with
  respect to string u ∈ Σ*

  - *∂_{c}{ cat, cow, dog } = { at, ow }*

*** Computing Nullability

#+begin_example
  nullable(r) = ε, if ε ∈ L⟦r⟧
  nullable(r) = ∅, otherwise
#+end_example

| function        | computation               |
|-----------------+---------------------------|
| nullable(ε)     | ε                         |
| nullable(a)     | a                         |
| nullable(∅)     | ∅                         |
| nullable(r • s) | nullable(r) & nullable(s) |
| nullable(r + s) | nullable(r) + nullable(s) |
| nullable(r*)    | ε                         |
| nullable(r & s) | nullable(r) & nullable(s) |
| nullable(¬r)    | ε, if nullable(r) = ∅     |
| nullable(¬r)    | ∅, if nullable(r) = ε     |

*** Computing Derivatives

Computing the derivative of a regular expression with respect to symbol *a*.

| function     | computation                       |
|--------------+-----------------------------------|
| ∂_{a}ε       | ∅                                 |
| ∂_{a}a       | ε                                 |
| ∂_{a}b       | ∅, because b ≠ a                  |
| ∂_{a}∅       | ∅                                 |
| ∂_{a}(r • s) | ∂_{a}r • s + nullable(r) • ∂_{a}s |
| ∂_{a}(r*)    | ∂_{a}r • r*                       |
| ∂_{a}(r + s) | ∂_{a}r + ∂_{a}s                   |
| ∂_{a}(r & s) | ∂_{a}r & ∂_{a}s                   |
| ∂_{a}(¬r)    | ¬(∂_{a}r)                         |
| ∂_{ε}r       | r                                 |
| ∂_{ua}r      | ∂_{a}(∂_{u}r)                     |

- r ~ u :: regular expression *r* matches string *u* if and only if *u ∈ L⟦r⟧*
  
  - r ~ ε ⇔ nullable(r) = ε

  - r ~ a • w ⇔ ∂_{a}r ~ w

**** Example Derivations

#+begin_example
  RE     = a • b*
  string = abb

  a • b* ~ abb ⇔ ∂a(a • b*) ~ bb
               ⇔ b* ~ bb
               ⇔ ∂b(b*) ~ b
               ⇔ b* ~ b
               ⇔ ∂b(b*) ~ ε
               ⇔ b* ~ ε
               ⇔ nullable(b*) = ε (true)

  RE     = a • b*
  string = aba

  a • b* ~ aba ⇔ ∂a(a • b*) ~ ba
               ⇔ b* ~ ba
               ⇔ ∂b(b*) ~ a
               ⇔ b* ~ a
               ⇔ ∂a(b*) ~ ε
               ⇔ ∅ ~ ε
               ⇔ nullable(∅) = ε (false)
#+end_example

** DFA Construction

- r ≡ s :: *r* and *s* are equivalent if *L⟦r⟧ = L⟦s⟧*

- [r]_{≡} :: *{ s : r ≡ s }*, the equivalence of class *r* under *≡*

- δ(q, [a]_{≡}) = [∂_{a}(q)]_{≡} :: The states of the DFA are RE equivalence classes
  and the transition function is the derivative function on those classes. Accepting
  states are those states labeled by nullable REs. The error state is labeled by *∅*.

#+begin_src
  (*
     DFA construction using RE derivatives,
     where
         "goto": constructs the transition state from state "q" for symbol "x"
         "explore": collects all possible transitions from state "q"

     Together these functions perform a depth-first traversal
     of the DFA's state graph while constructing it.
  *)
  fun goto q (x, (Q, δ)) =
      let qₓ = ∂ₓq
      in
          if ∃q' ∈ Q such that q' ≡ qₓ
          then (Q, δ ∪ {(q, x) ↦ q'})
          else
              let Q' = Q ∪ {qₓ}
              let δ' = δ ∪ {(q, x) ↦ qₓ}
              in explore (Q', δ', qₓ)

  (*
     In SML, the "and" syntax allows the joint declaration
     of mutually-recursive functions.
  *)
  and explore (Q, δ, q) = fold (goto q) (Q, δ) Σ

  fun mkDFA r =
      let q₀ = ∂ε(r)
      let (Q, δ) = explore ({q₀}, {}, q₀)
      let F = { q : q ∈ Q ∧ nullable(q) = ε }
      in ⟨Q, q₀, F, δ⟩
#+end_src

*** Example DFA Construction

#+begin_example
  === DFA Construction ===

  RE = a • b + a • c
  Σ  = { a, b, c }

  q0 = ∂ε(a • b + a • c) = a • b + a • c

  1. ∂a(q0) = ∂a(a • b + a • c) = b + c
     state q1

  2. ∂a(q1) = ∂a(b + c) = ∅
     state q2

  3. ∂a(q2) = ∂a(∅) = ∅
     state q2

  4. ∂b(q2) and ∂c(q2)
     state q2

  5. ∂b(q1) = ∂b(b + c) = (ε + ∅) ≡ ε
     state q3

  6. ∂a(q3) = ∂a(ε) = ∅
     state q2

  7. ∂b(q3) and ∂c(q3)
     state q2

  8. ∂c(q1) = ∂c(b + c) = (∅ + ε) ≡ ε
     state q3

  9. ∂b(q0) = ∂b(a • b + a • c)
     state q2

  10. ∂c(q0) = ∂c(a • b + a • c) = ∅
      state q2

  === Accepting State ===

  nullable(q3) = ε

  === DFA Graph ===
                                            +------------+
  +--------------+     +------------+       | +--------+ |
  | q0 = ab + ac |--a->| q1 = b + c |--b,c->| | q3 = ε | |
  +--------------+     +------------+       | +--------+ |
            |               |               +------------+
           b,c              a
            |  +---------+  |
            +->| q2 = ∅  |<-+
               +---------+
                |       ^
                +-a,b,c-+
#+end_example

** Implementation Issues
1. The problem of determining whether two REs are equivalent, which is used to test if
   *q' ≡ qₓ* in the ~goto~ function, is computationally expensive.

2. The iteration over symbols in *Σ* that is used to compute the *δ* function is impractical
   for large alphabets.

3. A scanner generator may take a collection of REs as its input specification,
   whereas the algorithm above builds a DFA for a single RE.

*** 1. Weaker Notions of RE Equivalence

- equivalence :: ∃q' ∈ Q such that q' ≡ q_{x}

- approximation :: ∃q' ∈ Q such that q' ≈ q_{x}

| RE          | ≈           |
|-------------+-------------|
| r & r       | r           |
| r & s       | s & r       |
| (r & s) & t | r & (s & t) |
| ∅ & r       | ∅           |
| ¬∅ & r      | r           |
| r + r       | r           |
| r + s       | s + r       |
| (r + s) + t | r + (s + t) |
| ¬∅ + r      | ¬∅          |
| ∅ + r       | r           |
| (r • s) • t | r • (s • t) |
| ∅ • r       | ∅           |
| ε • r       | r           |
| r • ε       | r           |
| (r*)*       | r*          |
| ε*          | ε           |
| ∅*          | ε           |
| ¬(¬r)       | r           |

#+begin_quote
  "In our implementations, we maintain the invariant that all REs are in *≈-canonical* form
   and use structural equality to identify equivalent REs. To ensure this invariant,
   we represent REs as an abstract type and use smart-constructor functions to build
   *≈-canonical* forms. Each RE operator has an associated smart-constructor function that
   checks its arguments for the applicability of the *≈* equations. If an equation applies,
   the smart constructor simplifies the RE using the equation as a reduction from left to right.
   For example, the constructor for negation inspects its argument, and if it is of the form
   *(¬r)*, the constructor simply returns *r*.

   For the commutativity and associativity equations, we use these equivalences to sort the
   subterms in lexical order. We also use this lexical order to implement a functional finite
   map with RE keys. This map is used as the representation of the set *Q* of DFA states...
   where RE labels are mapped to states. The membership test *q_{c} ∈ Q* is just a lookup
   in the finite map."

  — *Regular-Expression Derivatives Reexamined*, Scott Owens, John Reppy, and Aaron Turon
#+end_quote

*** 2. Character Sets

- S :: character set — including the empty set, single characters, and character classes

  - L⟦S⟧ = S

  - nullable(S) = ∅

  - ∂_{a}S = ε if a ∈ S, otherwise ∅

| syntax | meaning                    |
|--------+----------------------------|
| S      | S ⊆ Σ                      |
| ε      | empty string               |
| r • s  | concatenation              |
| r*     | Kleene closure             |
| r + s  | logical *or* (alternation) |
| r & s  | logical *and*              |
| ¬r     | complement                 |

- R, S, T :: character sets R, S, and T

| RE    | ≈         |
|-------+-----------|
| R + S | T = R ∪ S |
| ¬S    | T = Σ - S |

*** 3. Regular Vectors

** Haskell

*** Derivation

#+begin_src haskell
  data Regex = EmptySet
             | EmptyString
             | Character Char
             | Union  Regex Regex
             | Concat Regex Regex
             | Repeat Regex
             deriving (Eq, Show)

  nullable :: Regex -> Bool
  nullable regex =
      case regex of
          EmptySet      -> False
          EmptyString   -> True
          (Character _) -> False
          (Union x y)   -> nullable x || nullable y
          (Concat x y)  -> nullable x && nullable y
          (Repeat _)    -> True

  derive :: Regex -> Char -> Regex
  derive regex prefix =
      case regex prefix of
          EmptySet _      -> EmptySet
          EmptyString _   -> EmptySet
          (Character x) c -> if x == c
                             then EmptyString
                             else EmptySet
          (Union x y) c   -> Union (derive x c) (derive y c)
          (Concat x y) c  -> if nullable x
                             then Union (Concat (derive x c) y) (derive y c)
                             else Concat (derive x c) y
          (Repeat x) c    -> Concat (derive x c) (Repeat x)

  match :: Regex -> String -> Bool
  match regex text =
      case regex text of
          re ""     -> nullable re
          re (x:xs) -> match (derive re x) xs
#+end_src

*** Compilation

#+begin_src haskell
  data Regex = EmptySet
             | EmptyString
             | Character Char
             | Repeat Regex
             | Concat Regex Regex
             | Union [Regex]
             deriving (Eq, Ord)

  nullable :: Regex -> Bool
  nullable re =
      case re of
          EmptySet    -> False
          EmptyString -> True
          Character _ -> False
          Concat x y  -> nullable x && nullable y
          Union xs    -> any nullable xs
          Repeat _    -> True

  derive :: Char -> Regex -> Regex
  derive c f =
      let dc = derive c
      in case f of
          EmptySet    -> EmptySet
          EmptyString -> EmptySet
          Character x -> if x == c
                         then EmptyString
                         else EmptySet
          Concat x y  -> if nullable x
                         then unify [dc (Concat x y), dc y]
                         else dc (Concat x y)
          Union xs    -> unify (fmap dc xs)
          Repeat x    -> dc (Concat x f)

  -- +---------------------------+
  -- | problem       | solution  |
  -- |---------------+-----------|
  -- | idempotence   | nub       |
  -- | commutativity | sort      |
  -- | associativity | concatMap |
  -- +---------------------------+
  unify :: [Regex] -> Regex
  unify xs =
      let xs         = nub (sort (concatMap flatten xs))
          flatten ys = case ys of
                           (Union zs) -> zs
                           z          -> [z]
      in case xs of
             [x] -> x
              _  -> Union xs

  -- Compiles a DFA from Regex
  compile :: Regex -> ([Regex], Regex, [Regex], [((Regex, Regex), Char)])
  compile regex =
      let (states, edges) = explore ([Regex], []) Regex
          explore gr q = foldl' (goto q) gr ['a'..'z']
          goto q (qs, es) c =
              let qc  = derive c q
                  es1 = ((q, qc), c):es
              in if elem qc qs
                 then (qs, es1)
                 else explore (qc:qs, es1) qc
      in (states, regex, (filter nullable states), edges)
#+end_src
