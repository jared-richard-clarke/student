* Regular Expression Derivatives

** Sources

| source                                      | author                               |
|---------------------------------------------+--------------------------------------|
| *Regular-Expression Derivatives Reexamined* | Scott Owens, John Reppy, Aaron Turon |
| *Brzozowski derivative*                     | Wikipedia                            |

** Definitions

- Σ :: finite alphabet

- Σ* :: finite set of strings over Σ

- a, b, c ... :: symbols

- u, v, w ... :: strings

- ε :: empty string

- L ⊆ Σ* :: language of Σ

*** Syntax

- r, s :: regular expressions *r* and *s*

| syntax | meaning                    |
|--------+----------------------------|
| ∅      | empty set                  |
| ε      | empty string               |
| a      | a ∈ Σ                      |
| r • s  | concatenation              |
| r*     | Kleene closure             |
| r + s  | logical *or* (alternation) |
| r & s  | logical *and*              |
| ¬r     | complement                 |

*** Semantics

- L⟦r⟧ ⊆ Σ* :: the language of the regular expression

| evaluation | meaning                           |
|------------+-----------------------------------|
| L⟦∅⟧       | ∅                                 |
| L⟦ε⟧       | ε                                 |
| L⟦a⟧       | {a}                               |
| L⟦r • s⟧   | { u • v : u ∈ L⟦r⟧ and v ∈ L⟦s⟧ } |
| L⟦r*⟧      | {ε} ∪ L⟦r • r*⟧                   |
| L⟦r + s⟧   | L⟦r⟧ ∪ L⟦s⟧                       |
| L⟦r & s⟧   | L⟦r⟧ ∩ L⟦s⟧                       |
| L⟦¬r⟧      | Σ* \ L⟦r⟧                         |

*** Finite State Machine: DFA

- (Q, q₀, F, δ) :: deterministic finite automaton over alphabet Σ

- Q :: finite set of states

- q₀ ∈ Q :: start state

- F ⊆ Q :: final or accepting states

- δ : Q × Σ → Q :: state transition function

#+begin_example
  === Extending δ Over Strings ===
  
  δ'(q, ε)  = q
  δ'(q, au) = δ'(q', u), where q' = δ(q, a)

  === Language Accepted by DFA ===

  { u : δ'(q₀, u) ∈ F }
#+end_example

** Derivatives

- ∂_{u}L = { v : u • v ∈ L } :: the derivative of language L ⊆ Σ* with
  respect to string u ∈ Σ*

  - *∂_{c}{ cat, cow, dog } = { at, ow }*

*** Computing Nullability

#+begin_example
  nullable(r) = ε, if ε ∈ L⟦r⟧
  nullable(r) = ∅, otherwise
#+end_example

| function        | computation               |
|-----------------+---------------------------|
| nullable(ε)     | ε                         |
| nullable(a)     | a                         |
| nullable(∅)     | ∅                         |
| nullable(r • s) | nullable(r) & nullable(s) |
| nullable(r + s) | nullable(r) + nullable(s) |
| nullable(r*)    | ε                         |
| nullable(r & s) | nullable(r) & nullable(s) |
| nullable(¬r)    | ε, if nullable(r) = ∅     |
| nullable(¬r)    | ∅, if nullable(r) = ε     |

*** Computing Derivatives

Computing the derivative of a regular expression with respect to symbol *a*.

| function     | computation                       |
|--------------+-----------------------------------|
| ∂_{a}ε       | ∅                                 |
| ∂_{a}a       | ε                                 |
| ∂_{a}b       | ∅, because b ≠ a                  |
| ∂_{a}∅       | ∅                                 |
| ∂_{a}(r • s) | ∂_{a}r • s + nullable(r) • ∂_{a}s |
| ∂_{a}(r*)    | ∂_{a}r • r*                       |
| ∂_{a}(r + s) | ∂_{a}r + ∂_{a}s                   |
| ∂_{a}(r & s) | ∂_{a}r & ∂_{a}s                   |
| ∂_{a}(¬r)    | ¬(∂_{a}r)                         |
| ∂_{ε}r       | r                                 |
| ∂_{ua}r      | ∂_{a}(∂_{u}r)                     |

- r ~ u :: regular expression *r* matches string *u* if and only if *u ∈ L⟦r⟧*
  
  - r ~ ε ⇔ nullable(r) = ε

  - r ~ a • w ⇔ ∂_{a}r ~ w

#+begin_example
  RE     = a • b*
  string = abb

  a • b* ~ abb ⇔ ∂a(a • b*) ~ bb
               ⇔ b* ~ bb
               ⇔ ∂b(b*) ~ b
               ⇔ b* ~ b
               ⇔ ∂b(b*) ~ ε
               ⇔ b* ~ ε
               ⇔ nullable(b*) = ε (true)

  RE     = a • b*
  string = aba

  a • b* ~ aba ⇔ ∂a(a • b*) ~ ba
               ⇔ b* ~ ba
               ⇔ ∂b(b*) ~ a
               ⇔ b* ~ a
               ⇔ ∂a(b*) ~ ε
               ⇔ ∅ ~ ε
               ⇔ nullable(∅) = ε (false)
#+end_example

** DFA Construction

- r ≡ s :: *r* and *s* are equivalent if *L⟦r⟧ = L⟦s⟧*

- [r]_{≡} :: *{ s : r ≡ s }*, the equivalence of class *r* under *≡*

- δ(q, [a]_{≡}) = [∂_{a}(q)]_{≡} :: The states of the DFA are RE equivalence classes
  and the transition function is the derivative function on those classes. Accepting
  states are those states labeled by nullable REs. The error state is labeled by *∅*.

#+begin_example
  (*
     DFA construction using RE derivatives,
     where
         "goto": constructs the transition state from state "q" for symbol "x"
         "explore": collects all possible transitions from state "q"

     Together these functions perform a depth-first traversal
     of the DFA's state graph while constructing it.
  *)
  fun goto q (x, (Q, δ)) =
      let qₓ = ∂ₓq
      in
          if ∃q' ∈ Q such that q' ≡ qₓ
          then (Q, δ ∪ {(q, x) ↦ q'})
          else
              let Q' = Q ∪ {qₓ}
              let δ' = δ ∪ {(q, x) ↦ qₓ}
              in explore (Q', δ', qₓ)

  (*
     In SML, the "and" syntax allows the joint declaration
     of mutually-recursive functions.
  *)
  and explore (Q, δ, q) = fold (goto q) (Q, δ) Σ

  fun compile r =
      let q₀ = ∂ε(r)
      let (Q, δ) = explore ({q₀}, {}, q₀)
      let F = { q : q ∈ Q and nullable(q) = ε }
      in ⟨Q, q₀, F, δ⟩

  (* ========================================================== *)

  (*
     DFA construction using character classes and RE derivatives
     in ≈-canonical form.
  *)
  fun goto q (S, (Q, δ)) =
      let x ∈ S
      let qₓ = ∂ₓq
      in
          if ∃q' ∈ Q such that q' ≈ qₓ
          then (Q, δ ∪ {(q, S) ↦ q'})
          else
              let Q' = Q ∪ {qₓ}
              let δ' = δ ∪ {(q, S) ↦ qₓ}
              in explore (Q', δ', qₓ)

  and explore (Q, δ, q) = fold (goto q) (Q, δ) (C(q))

  fun compile r =
      let q₀ = ∂ε(r)
      let (Q, δ) = explore ({q₀}, {}, q₀)
      let F = { q : q ∈ Q and nullable(q) = ε }
      in ⟨Q, q₀, F, δ⟩
#+end_example

*** Example DFA Construction

#+begin_example
  === DFA Construction ===

  RE = ab + ac
  Σ  = { a, b, c }

  q0 = ∂ε(ab + ac) = ab + ac

  1. ∂a(q0) = ∂a(ab + ac) = b + c
     state q1

  2. ∂a(q1) = ∂a(b + c) = ∅
     state q2

  3. ∂a(q2) = ∂a(∅) = ∅ = q2

  4. ∂b(q2) = q2 and ∂c(q2) = q2

  5. ∂b(q1) = ∂b(b + c) = (ε + ∅) ≡ ε
     state q3

  6. ∂a(q3) = ∂a(ε) = ∅ = q2

  7. ∂b(q3) = q2 and ∂c(q3) = q2

  8. ∂c(q1) = ∂c(b + c) = (∅ + ε) ≡ ε = q3

  9. ∂b(q0) = ∂b(ab + ac) = ∅ = q2

  10. ∂c(q0) = ∂c(ab + ac) = ∅ = q2

  === Accepting State ===

  nullable(q3) = ε

  === DFA Graph ===
                                            +------------+
  +--------------+     +------------+       | +--------+ |
  | q0 = ab + ac |--a->| q1 = b + c |--b,c->| | q3 = ε | |
  +--------------+     +------------+       | +--------+ |
         |                   |              +------------+
        b,c                  a
         |    +---------+    |
         +--->| q2 = ∅  |<---+
              +---------+
               |       ^
               |       |
               +-a,b,c-+
#+end_example

** Implementation

1. The problem of determining whether two REs are equivalent, which is used to test if
   *q' ≡ qₓ* in the ~goto~ function, is computationally expensive.

2. The iteration over symbols in *Σ* that is used to compute the *δ* function is impractical
   for large alphabets.

3. A scanner generator may take a collection of REs as its input specification,
   whereas the algorithm above builds a DFA for a single RE.

*** 1. Weaker Notions of RE Equivalence

- equivalence :: ∃q' ∈ Q such that q' ≡ q_{x}

- approximation :: ∃q' ∈ Q such that q' ≈ q_{x}

| RE          | ≈           |
|-------------+-------------|
| r & r       | r           |
| r & s       | s & r       |
| (r & s) & t | r & (s & t) |
| ∅ & r       | ∅           |
| ¬∅ & r      | r           |
| r + r       | r           |
| r + s       | s + r       |
| (r + s) + t | r + (s + t) |
| ¬∅ + r      | ¬∅          |
| ∅ + r       | r           |
| (r • s) • t | r • (s • t) |
| ∅ • r       | ∅           |
| ε • r       | r           |
| r • ε       | r           |
| (r*)*       | r*          |
| ε*          | ε           |
| ∅*          | ε           |
| ¬(¬r)       | r           |

#+begin_quote
  "In our implementations, we maintain the invariant that all REs are in *≈-canonical* form
   and use structural equality to identify equivalent REs. To ensure this invariant,
   we represent REs as an abstract type and use smart-constructor functions to build
   *≈-canonical* forms. Each RE operator has an associated smart-constructor function that
   checks its arguments for the applicability of the *≈* equations. If an equation applies,
   the smart constructor simplifies the RE using the equation as a reduction from left to right.
   For example, the constructor for negation inspects its argument, and if it is of the form
   *(¬r)*, the constructor simply returns *r*.

   For the commutativity and associativity equations, we use these equivalences to sort the
   subterms in lexical order. We also use this lexical order to implement a functional finite
   map with RE keys. This map is used as the representation of the set *Q* of DFA states...
   where RE labels are mapped to states. The membership test *q_{c} ∈ Q* is just a lookup
   in the finite map."

  — *Regular-Expression Derivatives Reexamined*, Scott Owens, John Reppy, and Aaron Turon
#+end_quote

*** 2. Character Sets

- S :: A character set. Includes the empty set, single characters, and character classes.

  - L⟦S⟧ = S

  - nullable(S) = ∅

  - ∂_{a}S = ε if a ∈ S, otherwise ∅

| syntax | meaning                    |
|--------+----------------------------|
| S      | S ⊆ Σ                      |
| ε      | empty string               |
| r • s  | concatenation              |
| r*     | Kleene closure             |
| r + s  | logical *or* (alternation) |
| r & s  | logical *and*              |
| ¬r     | complement                 |

- R, S, T :: character sets R, S, and T

| RE    | ≈         |
|-------+-----------|
| R + S | T = R ∪ S |
| ¬S    | T = Σ \ S |

- a ≃_{r} b :: 
  1. *r* over *Σ*

  2. *a, b ∈ Σ*

  3. *∂_{a}r ≡ ∂_{b}r*

- Σ/≃_{r} :: The equivalence classes that are the derivative classes of *r*.

  - equivalence class :: Disjoint subsets of a larger set that are formed
    by an equivalence relation.

- [a]_{r} = { b : a ≃_{r} b } :: The derivative class of *r* represented by *a*.

| a ≃_{r} b and a ≃_{s} b |
|-------------------------|
| a ≃_{(r • s)} b         |
| a ≃_{(r + s)} b         |
| a ≃_{(r & s)} b         |
| a ≃_{r*} b              |
| a ≃_{¬r} b              |

- C(r) :: A partitioning function that approximates derivative classes.
  The algorithm is conservative because it assumes that only those
  symbols that are related in both *C(r)* and *C(s)* are related in *C(r + s)*.
  More precisely: *C(r) ∧ C(s) = { S_{r} ∩ S_{s} : S_{r} ∈ C(r), S_{s} ∈ C(s) }*.

| function | computation                             |
|----------+-----------------------------------------|
| C(ε)     | { Σ }                                   |
| C(S)     | { S, Σ \ S }                            |
| C(r • s) | if nullable(r): C(r) ∧ C(s), else: C(r) |
| C(r + s) | C(r) ∧ C(s)                             |
| C(r & s) | C(r) ∧ C(s)                             |
| C(r*)    | C(r)                                    |
| C(¬r)    | C(r)                                    |

#+begin_example
  C(a + ba + c) = C(a + ba) ∧ C(c)
                = (C(a) ∧ C(ba)) ∧ C(c)
                = (C(a) ∧ C(b)) ∧ C(c)
                = ({{a}, Σ \ {a}} ∧ {{b}, Σ \ {b}}) ∧ {{c}, Σ \ {c}}
                = {∅, {a}, {b}, Σ \ {a, b}} ∧ {{c}, Σ \ {c}}
                = {∅, {a}, {b}, {c}, Σ \ {a, b, c}}
#+end_example

*** 3. Regular Vectors

#+begin_quote
  "In order to use this DFA construction algorithm in a scanner generator,
   we need to extend it to handle multiple REs in parallel. Brzozowski
   recognized this problem and introduced regular vectors as an elegant
   solution."

  — *Regular-Expression Derivatives Reexamined*, Scott Owens, John Reppy, and Aaron Turon
#+end_quote

- R = (r_{1} ... r_{n}) :: An n-tuple of regular expressions. Called a *regular vector*.
  Replaces REs as states within a DFA.

- ∂_{a}(r_{1} ... r_{n}) = (∂_{a}r_{1} ... ∂_{a}r_{n}) :: The derivative function that
  is the transitions function, where the derivative of a regular vector is defined
  component-wise.

- error state :: *(r_{1} ... r_{n})* where *(∀r)(r = ∅)*.

- accept state :: *(r_{1} ... r_{n})* where *(∃r)(nullable(r) = ε)*

- C(r_{1} ... r_{n}) = ∧C(r_{i}) :: An approximation of the derivative classes
  of a regular vector is the intersection of the approximate derivative classes
  of its components.

** Example Code

*** Haskell Derivation

#+begin_src haskell
  data Regex = EmptySet
             | EmptyString
             | Literal Char
             | Union Regex Regex
             | Concat Regex Regex
             | Repeat Regex
             deriving (Eq, Show)

  nullable :: Regex -> Bool
  nullable regex =
      case regex of
          EmptySet     -> False
          EmptyString  -> True
          (Literal _)  -> False
          (Union x y)  -> nullable x || nullable y
          (Concat x y) -> nullable x && nullable y
          (Repeat _)   -> True

  derive :: Regex -> Char -> Regex
  derive regex prefix =
      case regex prefix of
          EmptySet _     -> EmptySet
          EmptyString _  -> EmptySet
          (Literal x) c  -> if x == c
                            then EmptyString
                            else EmptySet
          (Union x y) c  -> Union (derive x c) (derive y c)
          (Concat x y) c -> if nullable x
                            then Union (Concat (derive x c) y) (derive y c)
                            else Concat (derive x c) y
          (Repeat x) c   -> Concat (derive x c) (Repeat x)

  match :: Regex -> String -> Bool
  match regex text =
      case regex text of
          re ""     -> nullable re
          re (x:xs) -> match (derive re x) xs
#+end_src

| step | derivation                          | ≈                  |
|------+-------------------------------------+--------------------|
|    1 | ~match ab* "abb"~                   | ~match ab* "abb"~  |
|      | ~derive ab* 'a'~                    | ~derive ab* 'a'~   |
|      | ~(derive a 'a')b*~                  | ~(derive a 'a')b*~ |
|      | ~εb*~                               | ~b*~               |
|------+-------------------------------------+--------------------|
|    2 | ~match εb* "bb"~                    | ~match b* "bb"~    |
|      | ~(derive ε 'b') + (derive b* 'b')~  | ~(derive b* 'b')~  |
|      | ~∅ + (derive b 'b')b*~              | ~(derive b 'b')b*~ |
|      | ~∅ + εb*~                           | ~b*~               |
|------+-------------------------------------+--------------------|
|    3 | ~match (∅ + εb*) "b"~               | ~match b* "b"~     |
|      | ~derive (∅ + εb*) 'b'~              | ~derive b* 'b'~    |
|      | ~(derive ∅ 'b') + (derive εb* 'b')~ | ~(derive b 'b')b*~ |
|      | ~∅ + (derive ε 'b')(derive b* 'b')~ | ~b*~               |
|      | ~∅ + ∅ + (derive b 'b')b*~          |                    |
|      | ~∅ + ∅ + εb*~                       |                    |
|------+-------------------------------------+--------------------|
|    4 | ~match (∅ + ∅ + εb*) ""~            | ~match b* ""~      |
|      | ~nullable (∅ + ∅ + εb*)~            | ~nullable b*~      |
|      | ~True~                              | ~True~             |

*** Python Compilation

#+begin_src python
  def compile(regex, alphabet):
      start = regex
      states = {start}
      # { state-x: { symbol: state-y } }
      transitions = {}
      # worklist: depth-first traversal
      stack = [start]

      while stack:
          x = stack.pop()
          transitions[x] = {}

          for symbol in alphabet:
              y = derive(x, symbol)
              if y not in states:
                  states.add(y)
                  stack.append(y)
              transitions[x][symbol] = y

      accepting = { state for state in states if nullable(state) }

      return { "Q": states, "q0": start, "F": accepting, "δ": transitions }
#+end_src
