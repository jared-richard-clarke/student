#+title: Thompson's Construction

* Sources

| source                                               | author          |
|------------------------------------------------------+-----------------|
| *Thompson's Construction*                            | Wikipedia       |
| *Regular Expression Matching Can Be Simple and Fast* | Russ Cox        |
| *Theory of Computation*                              | Michael Sipser  |
| *Visualizing Thompson's Construction*                | Gregory Cernera |

* NFA Fragments

*Side Note*: The unlabeled edges are ε-transitions.

#+begin_example
  === empty ===

  >◯--ε-->◎
   ^      ^
   |      |
   start  accept

  === symbol ===

  >◯--a-->◎

  === alternation or union (s|t) ===

  S ∪ T = { w | w ∈ S ∨ w ∈ T }

    ----------
   | ◯ N(s) ◯ |
    / ------ \
  >◯          ◎
    \ ------ /
   | ◯ N(t) ◯ |
    ----------

  === concatenation (st or s•t) ===

  S • T = { xy | x ∈ S ∧ y ∈ T }

    ----------      ----------
  >| ◯ N(s) ◯ |--->| ◯ N(t) ◎ |
    ----------      ----------
            ^--------^
           joined state

  === Kleene star (s*) ===

  S⁰   = {ε}
  S¹   = S
  Sⁿ⁺¹ = { xy | x ∈ Sⁿ ∧ y ∈ S } for each n > 0

             <+
            /  \
         ----------
  >◯--->| ◯ N(s) ◯ |--->◎
    \    ----------    /
     +---------------->
#+end_example


* NFA Fragments (Russ Cox)

#+begin_src c
  typedef struct State {
    int c;
    State *out;
    State *out1;
    int lastlist;
  } State;

  //                +--->out
  //                |
  // >◯-c->out     >◯                    ◎
  //                |
  //                +--->out1
  //
  // c < 256       c = 256 (Split)       c = 257 (Match)

  typedef struct Frag {
    State *start;
    Ptrlist *out;
  } Frag;

  typedef union Ptrlist {
    Ptrlist *next;
    State *s;
  } Ptrlist;

  State* post2nfa(char *postfix)
  {
    char *p;
    Frag stack[1000], *stackp, e1, e2, e;
    State *s;

  #define push(s) *stackp++ = s
  #define pop()   *--stackp

    stackp = stack;
    for(p=postfix; *p; p++){
      switch(*p){

        // === single characters ===

      default:                                         //    *p
        s = state(*p, NULL, NULL);                     // >◯---->
        push(frag(s, list1(&s->out)));
        break;

        // === concatenation (e₁e₂) ===

      case: '.':
        e2 = pop();                                    //   ----      ----
        e1 = pop();                                    // >| e₁ |--->| e₂ |--->
        patch(e1.out, e2.start);                       //   ----      ----
        push(frag(e1.start, e2.out));
        break;

        // === alternation (e₁|e₂) ===

                                                       //        ----
      case '|':                                        //  +--->| e₁ |--->
        e2 = pop();                                    //  |     ----
        e1 = pop();                                    // >◯
        s = state(Split, e1.start, e2.start);          //  |     ----
        push(frag(s, append(e1.out, e2.out)));         //  +--->| e₂ |--->
        break;                                         //        ----

        // === zero-or-one (e?) ===
                                                       //        ---
      case '?':                                        //  +--->| e |--->
        e = pop();                                     //  |     ---
        s = state(Split, e.start, NULL);               // >◯
        push(frag(s, append(e.out, list1(&s->out1)))); //  |
        break;                                         //  +------------>

        // === zero or more (e*) ===

                                                       //        ---
      case '*':                                        //  +--->| e |---+
        e = pop();                                     //  |     ---    |
        s = state(Split, e.start, NULL);               // >◯<-----------+
        patch(e.out, s);                               //  |
        push(frag(s, list1(&s->out1)));                //  +------------>
        break;

        // === one or more (e+) ===

      case '+':                                        //    +------+
        e = pop();                                     //    V      |
        s = state(Split, e.start, NULL);               //   ---     |
        patch(e.out, s);                               // >| e |--->◯--->
        push(frag(e.start, list1(&s->out1)));          //   ---
        break;
      }
    }

    e = pop();
    patch(e.out, matchstate);                          // >◎
    return e.start;
  #undef pop
  #undef push
  }
#+end_src

* RE to NFA Construction

#+begin_example
  === regular expression ===

  infix:   a(a|b)*b

  postfix: aab|*•b•

  === NFA construction ===

  1. aab|*•b•
     ^

     >◯-a->◎

  2. aab|*•b•
      ^

     >◯-a->◎

  3. aab|*•b•
       ^

     >◯-b->◎

  4. aab|*•b•
        ^

        ◯-a->◯
       /      \
     >◯        ◎
       \      /
        ◯-b->◯

  5.  aab|*•b•
          ^

            <--------+
            | ◯-a->◯ |
            |/      \|
       ◯--->◯        ◯--->◎
        \    \      /    /
         \    ◯-b->◯    /
          +------------>

  6. aab|*•b•
          ^

                <--------+
                | ◯-a->◯ |
                |/      \|
     >◯-a->◯--->◯        ◯--->◎
            \    \      /    /
             \    ◯-b->◯    /
              +------------>

  7. aab|*•b•
           ^

     >◯-b->◎

  8. aab|*•b•
            ^

                <--------+
                | ◯-a->◯ |
                |/      \|
     >◯-a->◯--->◯        ◯--->◯-b->◎
            \    \      /    /
             \    ◯-b->◯    /
              +------------>

  === regular expression ===

  infix:   a|b|c

  postfix: abc||

  === NFA construction ===

  1. abc||
     ^

     >◯-a->◎

  2. abc||
      ^

     >◯-b->◎

  3. abc||
       ^

     >◯-c->◎

  4. abc||
        ^

        ◯-b->◯
       /      \
     >◯        ◎
       \      /
        ◯-c->◯

  5. abc||
         ^

        ◯---a--->◯
       /          \
     >◯   ◯-b->◯   ◎
       \ /      \ /
        ◯        ◯
         \      /
          ◯-c->◯

#+end_example

* RE to NFA to DFA

#+begin_example
  === regular expression ===

  infix:   (ab|c)*
  postfix: ab•c|*

  === NFA Construction ===

  1. ab•c|*
     ^

     >[1]-a->(2)

  2. ab•c|*
      ^

     >[3]-b->(4)

  3. ab•c|*
       ^

     >[1]-a->[2]-b->(4)

  4. ab•c|*
        ^

     >[5]-c->[6]

  5. ab•c|*
         ^

        [1]-a->[2]-b->[4]
        /               \
     >[7]               (8)
        \               /
        [5]-----c---->[6]

  6. ab•c|*
          ^
            <-----------------+
            |                 |
            |[1]-a->[2]-b->[4]|
            |/               \|
     >[9]->[7]               [8]->(10)
        \    \               /    /
         \   [5]-----c---->[6]   /
          \                     /
           +------------------->
#+end_example

| NFA States     | DFA State | a | b | c |
|----------------+-----------+---+---+---|
| {9,7,1,5,10}   | A         | B |   | C |
| {2}            | B         |   | D |   |
| {6,8,10,7,1,5} | C         | B |   | C |
| {4,8,7,1,5,10} | D         | B |   | C |

#+begin_example
  === subset construction ===

  while (there is an unmarked state T in D) {
      mark T;
      for (each input symbol a) {
          U = ε-closure(move(T,a));
          D[T, a] = U;
          if (U is not in D) {
              add U as unmarked state to D;
          }
      }
  }

  === DFA ===

        <------a
        |      |
    a->[B]->b  |
    |   ^   |  |
  >(A)  a  (D)-+
    |   |   |
    c->(C)<-c
       / \
      +-c->
#+end_example
