* Thompson's Construction

** Sources

| source                                               | author          |
|------------------------------------------------------+-----------------|
| *Thompson's Construction*                            | Wikipedia       |
| *Regular Expression Matching Can Be Simple and Fast* | Russ Cox        |
| *Theory of Computation*                              | Michael Sipser  |
| *Visualizing Thompson's Construction*                | Gregory Cernera |

** NFA Fragments

*Side Note*: The unlabeled edges are ε-transitions.

#+begin_quote
  "[E]fficiency comes from tracking the set of reachable states but not which paths were used
   to reach them. In an *NFA* with *n* nodes, there can only be *n* reachable states at any step,
   but there might be *2ⁿ* paths through the *NFA*."

   — *Regular Expression Matching Can Be Simple and Fast*, Russ Cox
#+end_quote

#+begin_example
  === empty ===

  >◯--ε-->◎
   ^      ^
   |      |
   start  accept

  === symbol ===

  >◯--a-->◎

  === alternation or union (s|t) ===

  S ∪ T = { w | w ∈ S ∨ w ∈ T }

    ----------
   | ◯ N(s) ◯ |
    / ------ \
  >◯          ◎
    \ ------ /
   | ◯ N(t) ◯ |
    ----------

  === concatenation (st or s•t) ===

  S • T = { xy | x ∈ S ∧ y ∈ T }

    ----------      ----------
  >| ◯ N(s) ◯ |--->| ◯ N(t) ◎ |
    ----------      ----------
            ^--------^
           joined state

  === Kleene star (s*) ===

  S⁰   = {ε}
  S¹   = S
  Sⁿ⁺¹ = { xy | x ∈ Sⁿ ∧ y ∈ S } for each n > 0

             <+
            /  \
         ----------
  >◯--->| ◯ N(s) ◯ |--->◎
    \    ----------    /
     +---------------->
#+end_example


** NFA Fragments (Russ Cox)

#+begin_src c
  typedef struct State {
    int c;
    State *out;
    State *out1;
    int lastlist;
  } State;

  //                +--->out
  //                |
  // >◯-c->out     >◯                    ◎
  //                |
  //                +--->out1
  //
  // c < 256       c = 256 (Split)       c = 257 (Match)

  typedef struct Frag {
    State *start;
    Ptrlist *out;
  } Frag;

  typedef union Ptrlist {
    Ptrlist *next;
    State *s;
  } Ptrlist;

  State* post2nfa(char *postfix)
  {
    char *p;
    Frag stack[1000], *stackp, e1, e2, e;
    State *s;

  #define push(s) *stackp++ = s
  #define pop()   *--stackp

    stackp = stack;
    for(p = postfix; *p; p++){
      switch(*p){

        // === literal characters ===

      default:                                         //    *p
        s = state(*p, NULL, NULL);                     // >◯---->
        push(frag(s, list1(&s->out)));
        break;

        // === concatenation (e₁e₂) ===

      case: '.':
        e2 = pop();                                    //   ----      ----
        e1 = pop();                                    // >| e₁ |--->| e₂ |--->
        patch(e1.out, e2.start);                       //   ----      ----
        push(frag(e1.start, e2.out));
        break;

        // === alternation (e₁|e₂) ===

                                                       //        ----
      case '|':                                        //  +--->| e₁ |--->
        e2 = pop();                                    //  |     ----
        e1 = pop();                                    // >◯
        s = state(Split, e1.start, e2.start);          //  |     ----
        push(frag(s, append(e1.out, e2.out)));         //  +--->| e₂ |--->
        break;                                         //        ----

        // === zero-or-one (e?) ===
                                                       //        ---
      case '?':                                        //  +--->| e |--->
        e = pop();                                     //  |     ---
        s = state(Split, e.start, NULL);               // >◯
        push(frag(s, append(e.out, list1(&s->out1)))); //  |
        break;                                         //  +------------>

        // === zero or more (e*) ===

                                                       //        ---
      case '*':                                        //  +--->| e |---+
        e = pop();                                     //  |     ---    |
        s = state(Split, e.start, NULL);               // >◯<-----------+
        patch(e.out, s);                               //  |
        push(frag(s, list1(&s->out1)));                //  +------------>
        break;

        // === one or more (e+) ===

      case '+':                                        //    +------+
        e = pop();                                     //    V      |
        s = state(Split, e.start, NULL);               //   ---     |
        patch(e.out, s);                               // >| e |--->◯--->
        push(frag(e.start, list1(&s->out1)));          //   ---
        break;
      }
    }

    e = pop();
    if(stackp != stack) {
      return NULL;
    }
    patch(e.out, &matchstate);                         // >◎
    return e.start;
  #undef pop
  #undef push
  }
#+end_src

** RE to NFA Construction

#+begin_example
  === regular expression ===

  infix:   a(a|b)*b

  postfix: aab|*•b•

  === NFA construction ===

  1. aab|*•b•
     ^

     >◯-a->◎

  2. aab|*•b•
      ^

     >◯-a->◎

  3. aab|*•b•
       ^

     >◯-b->◎

  4. aab|*•b•
        ^

        ◯-a->◯
       /      \
     >◯        ◎
       \      /
        ◯-b->◯

  5.  aab|*•b•
          ^

            <--------+
            | ◯-a->◯ |
            |/      \|
       ◯--->◯        ◯--->◎
        \    \      /    /
         \    ◯-b->◯    /
          +------------>

  6. aab|*•b•
          ^

                <--------+
                | ◯-a->◯ |
                |/      \|
     >◯-a->◯--->◯        ◯--->◎
            \    \      /    /
             \    ◯-b->◯    /
              +------------>

  7. aab|*•b•
           ^

     >◯-b->◎

  8. aab|*•b•
            ^

                <--------+
                | ◯-a->◯ |
                |/      \|
     >◯-a->◯--->◯        ◯--->◯-b->◎
            \    \      /    /
             \    ◯-b->◯    /
              +------------>

  === regular expression ===

  infix:   a|b|c

  postfix: abc||

  === NFA construction ===

  1. abc||
     ^

     >◯-a->◎

  2. abc||
      ^

     >◯-b->◎

  3. abc||
       ^

     >◯-c->◎

  4. abc||
        ^

        ◯-b->◯
       /      \
     >◯        ◎
       \      /
        ◯-c->◯

  5. abc||
         ^

        ◯---a--->◯
       /          \
     >◯   ◯-b->◯   ◎
       \ /      \ /
        ◯        ◯
         \      /
          ◯-c->◯

#+end_example

** RE to NFA to DFA

#+begin_example
  === regular expression ===

  infix:   (ab|c)*
  postfix: ab•c|*

  === NFA Construction ===

  1. ab•c|*
     ^

     >[1]-a->(2)

  2. ab•c|*
      ^

     >[3]-b->(4)

  3. ab•c|*
       ^

     >[1]-a->[2]-b->(4)

  4. ab•c|*
        ^

     >[5]-c->[6]

  5. ab•c|*
         ^

        [1]-a->[2]-b->[4]
        /               \
     >[7]               (8)
        \               /
        [5]-----c---->[6]

  6. ab•c|*
          ^
            <-----------------+
            |                 |
            |[1]-a->[2]-b->[4]|
            |/               \|
     >[9]->[7]               [8]->(10)
        \    \               /    /
         \   [5]-----c---->[6]   /
          \                     /
           +------------------->
#+end_example

Each state in the *DFA* corresponds to a list of states from the *NFA*.

The epsilon closure *E(q)* of a state *q* in *Q* is the union of the set *{q}* with the set of all states
that can be reached from *q* via one or more *ε* transitions.

If *R* is a set of states from *Q*, the epsilon closure *E(R)* is defined as the union of the epsilon
closures of all the states in *R*.

1. The set of states of the *DFA* is *P(Q)*, the power set of states *Q* in the original *NFA*.

2. The start state of the *DFA* is *E({q₀})*, where *q₀* is the original start state of the *NFA*.

3. For sets *R* in *P(Q)* and input characters *c ∈ Σ*, the transition function *δn* of the *DFA* is defined
   in terms of the transition function *δ* of the *NFA* by *δn(R,c) = U_{r ∈ R} E(δ(r,c))*.

The set of accepting states *F* of the *DFA* is defined to be the set of all states containing at least one
final state of the *NFA*.

| NFA States            | DFA State | a | b | c |
|-----------------------+-----------+---+---+---|
| { 9, 7, 1, 5, 10 }    | A         | B |   | C |
| { 2 }                 | B         |   | D |   |
| { 6, 8, 10, 7, 1, 5 } | C         | B |   | C |
| { 4, 8, 7, 1, 5, 10 } | D         | B |   | C |

#+begin_example
  === subset construction ===

  while there is an unmarked state T in D-states {
      mark T
      for each input symbol a {
          U := ε-closure(move(T, a))
          if U is not in D-states {
              add U as unmarked state to D
          }
          D-transitions[T, a] := U
      }
  }

  === DFA ===

        <------a
        |      |
    a->[B]->b  |
    |   ^   |  |
  >(A)  a  (D)-+
    |   |   |
    c->(C)<-c
       / \
      +-c->
#+end_example
