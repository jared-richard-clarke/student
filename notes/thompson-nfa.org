* Thompson's Construction

** Sources

| source                                               | author         |
|------------------------------------------------------+----------------|
| *Thompson's Construction*                            | Wikipedia      |
| *Regular Expression Matching Can Be Simple and Fast* | Russ Cox       |
| *Theory of Computation*                              | Michael Sipser |

** NFA Fragments

*Side Note*: The unlabeled edges are ε-transitions.

#+begin_example
  === empty ===

  >ⓠ--ε-->ⓕ

  === symbol ===

  >ⓠ--a-->ⓕ

  === alternation or union (s|t) ===

  S ∪ T = { w | w ∈ S ∨ w ∈ T }

    ----------
   | ◯ N(s) ◯ |
    / ------ \
  >ⓠ          ⓕ
    \ ------ /
   | ◯ N(t) ◯ |
    ----------

  === concatenation (st or s•t) ===

  S • T = { xy | x ∈ S ∧ y ∈ T }

    ----------       ----------
  >| ⓠ N(s) ◯ |--->| ◯ N(t) ⓕ |
    ----------       ----------

  === Kleene star (s*) ===

  S⁰   = {ε}
  S¹   = S
  Sⁿ⁺¹ = { xy | x ∈ Sⁿ ∧ y ∈ S } for each n > 0

             <-+
            /   \
          ---------
  >ⓠ--->| ◯ N(s) ◯ |---->ⓕ
    \     ---------     /
     +----------------->
#+end_example


** NFA Fragments (Russ Cox)

#+begin_src c
  State* post2nfa(char *postfix)
  {
    char *p;
    Frag stack[1000], *stackp, e1, e2, e;
    State *s;

  #define push(s) *stackp++ = s
  #define pop()   *--stackp

    stackp = stack;
    for(p=postfix; *p; p++){
      switch(*p){

        // === single characters ===

      default:                                         //    *p
        s = state(*p, NULL, NULL);                     // >◯---->
        push(frag(s, list1(&s->out)));
        break;

        // === concatenation (e₁e₂) ===

      case: '.':
        e2 = pop();                                    //   ----      ----
        e1 = pop();                                    // >| e₁ |--->| e₂ |--->
        patch(e1.out, e2.start);                       //   ----      ----
        push(frag(e1.start, e2.out));
        break;

        // === alternation (e₁|e₂) ===

                                                       //        ----
      case '|':                                        //  +--->| e₁ |--->
        e2 = pop();                                    //  |     ----
        e1 = pop();                                    // >◯
        s = state(Split, e1.start, e2.start);          //  |     ----
        push(frag(s, append(e1.out, e2.out)));         //  +--->| e₂ |--->
        break;                                         //        ----

        // === zero-or-one (e?) ===
                                                       //        ---
      case '?':                                        //  +--->| e |--->
        e = pop();                                     //  |     ---
        s = state(Split, e.start, NULL);               // >◯
        push(frag(s, append(e.out, list1(&s->out1)))); //  |
        break;                                         //  +------------>

        // === zero or more (e*) ===

                                                       //        ---
      case '*':                                        //  +--->| e |---+
        e = pop();                                     //  |     ---    |
        s = state(Split, e.start, NULL);               // >◯<-----------+
        patch(e.out, s);                               //  |
        push(frag(s, list1(&s->out1)));                //  +------------>
        break;

        // === one or more (e+) ===

      case '+':                                        //    +------+
        e = pop();                                     //    V      |
        s = state(Split, e.start, NULL);               //   ---     |
        patch(e.out, s);                               // >| e |--->◯--->
        push(frag(e.start, list1(&s->out1)));          //   ---
        break;
      }
    }

    e = pop();
    patch(e.out, matchstate);
    return e.start;
  #undef pop
  #undef push
  }
#+end_src
