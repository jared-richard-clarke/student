* Thompson's Construction

** Sources

| source                                               | author          |
|------------------------------------------------------+-----------------|
| *Thompson's Construction*                            | Wikipedia       |
| *Regular Expression Matching Can Be Simple and Fast* | Russ Cox        |
| *Theory of Computation*                              | Michael Sipser  |
| *Visualizing Thompson's Construction*                | Gregory Cernera |

** NFA Fragments

*Side Note*: The unlabeled edges are ε-transitions.

#+begin_example
  === empty ===

  >ⓧ--ε-->ⓨ
   ^      ^
   |      |
   start  accept

  === symbol ===

  >ⓧ--a-->ⓨ

  === alternation or union (s|t) ===

  S ∪ T = { w | w ∈ S ∨ w ∈ T }

    ----------
   | ◯ N(s) ◯ |
    / ------ \
  >ⓧ          ⓨ
    \ ------ /
   | ◯ N(t) ◯ |
    ----------

  === concatenation (st or s•t) ===

  S • T = { xy | x ∈ S ∧ y ∈ T }

    ----------       ---------
  >| ⓧ N(s) ◯ |--->| ◯ N(t) ⓨ |
    ----------       ---------
            ^--------^
           joined state

  === Kleene star (s*) ===

  S⁰   = {ε}
  S¹   = S
  Sⁿ⁺¹ = { xy | x ∈ Sⁿ ∧ y ∈ S } for each n > 0

             <-+
            /   \
          ---------
  >ⓧ--->| ◯ N(s) ◯ |---->ⓨ
    \     ---------     /
     +----------------->
#+end_example


** NFA Fragments (Russ Cox)

#+begin_src c
  typedef struct State {
    int c;
    State *out;
    State *out1;
    int lastlist;
  } State;

  //                +--->out
  //                |
  // >◯-c->out     >◯                    ◎
  //                |
  //                +--->out1
  //
  // c < 256       c = 256 (Split)       c = 257 (Match)

  typedef struct Frag {
    State *start;
    Ptrlist *out;
  } Frag;

  typedef union Ptrlist {
    Ptrlist *next;
    State *s;
  } Ptrlist;

  State* post2nfa(char *postfix)
  {
    char *p;
    Frag stack[1000], *stackp, e1, e2, e;
    State *s;

  #define push(s) *stackp++ = s
  #define pop()   *--stackp

    stackp = stack;
    for(p=postfix; *p; p++){
      switch(*p){

        // === single characters ===

      default:                                         //    *p
        s = state(*p, NULL, NULL);                     // >◯---->
        push(frag(s, list1(&s->out)));
        break;

        // === concatenation (e₁e₂) ===

      case: '.':
        e2 = pop();                                    //   ----      ----
        e1 = pop();                                    // >| e₁ |--->| e₂ |--->
        patch(e1.out, e2.start);                       //   ----      ----
        push(frag(e1.start, e2.out));
        break;

        // === alternation (e₁|e₂) ===

                                                       //        ----
      case '|':                                        //  +--->| e₁ |--->
        e2 = pop();                                    //  |     ----
        e1 = pop();                                    // >◯
        s = state(Split, e1.start, e2.start);          //  |     ----
        push(frag(s, append(e1.out, e2.out)));         //  +--->| e₂ |--->
        break;                                         //        ----

        // === zero-or-one (e?) ===
                                                       //        ---
      case '?':                                        //  +--->| e |--->
        e = pop();                                     //  |     ---
        s = state(Split, e.start, NULL);               // >◯
        push(frag(s, append(e.out, list1(&s->out1)))); //  |
        break;                                         //  +------------>

        // === zero or more (e*) ===

                                                       //        ---
      case '*':                                        //  +--->| e |---+
        e = pop();                                     //  |     ---    |
        s = state(Split, e.start, NULL);               // >◯<-----------+
        patch(e.out, s);                               //  |
        push(frag(s, list1(&s->out1)));                //  +------------>
        break;

        // === one or more (e+) ===

      case '+':                                        //    +------+
        e = pop();                                     //    V      |
        s = state(Split, e.start, NULL);               //   ---     |
        patch(e.out, s);                               // >| e |--->◯--->
        push(frag(e.start, list1(&s->out1)));          //   ---
        break;
      }
    }

    e = pop();
    patch(e.out, matchstate);
    return e.start;
  #undef pop
  #undef push
  }
#+end_src

** RE to NFA Construction

#+begin_example
  === regular expression ===

  infix:   a(a|b)*b

  postfix: aab|*•b•

  === NFA Construction ===

  1. aab|*•b•
     ^

     >◯-a->◎

  2. aab|*•b•
      ^

     >◯-a->◎

  3. aab|*•b•
       ^

     >◯-b->◎

  4. aab|*•b•
        ^

        ◯-a->◯
       /      \
     >◯        ◎
       \      /
        ◯-b->◯

  5.  aab|*•b•
          ^

             <-------+
            | ◯-a->◯ |
            |/      \|
       ◯--->◯        ◯--->◎
        \    \      /    /
         \    ◯-b->◯    /
          +------------>

  6. aab|*•b•
          ^

                 <-------+
                | ◯-a->◯ |
                |/      \|
     >◯-a->◯--->◯        ◯--->◎
            \    \      /    /
             \    ◯-b->◯    /
              +------------>

  7. aab|*•b•
           ^

     >◯-b->◎

  8. aab|*•b•
            ^

                 <-------+
                | ◯-a->◯ |
                |/      \|
     >◯-a->◯--->◯        ◯--->◯-b->◎
            \    \      /    /
             \    ◯-b->◯    /
              +------------>

#+end_example
