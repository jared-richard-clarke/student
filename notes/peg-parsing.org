* Parsing Expression Grammars

*Parsing Expression Grammars: A Recognition-Based Syntactic Foundation*, Bryan Ford

** Keywords

- context-free grammars
- regular expressions
- parsing expression grammars
- BNF (Backus-Naur Form)
- lexical analysis
- unified grammars
- scannerless parsing
- packrat parsing
- syntactic predicates
- TDPL (Top Down Parsing Language)
- GTDPL (Generalized Top Down Parsing Language)

** Generative System

*{s ∈ a\star{} | s = (aa)ⁿ}*

A generative definition over an unary character set, whose strings are constructed by
concatenating pairs of a's.

** Recognition-Based System

*{s ∈ a\star{} | (|s| mod 2 = 0)}*

A recognition-based definition of the same language as the generative system but a string
of a's is accepted if the predicate determines the string's length is even.

** Prioritized Choice Operator: */*

#+begin_example
=== equivalent ===
A → a b | a and A → a | a b

=== non-equivalent ===
A ← a b / a and A ← a / a b
#+end_example

** PEG Operators

| operator | type         | precedence | description        |
|----------+--------------+------------+--------------------|
| ' '      | primary      |          5 | literal string     |
| " "      | primary      |          5 | literal string     |
| [ ]      | primary      |          5 | character class    |
| .        | primary      |          5 | any character      |
| (e)      | primary      |          5 | grouping           |
| e?       | unary suffix |          4 | optional           |
| e*       | unary suffix |          4 | zero-or-more       |
| e+       | unary suffix |          4 | one-or-more        |
| &e       | unary prefix |          3 | and-predicate      |
| !e       | unary prefix |          3 | not-predicate      |
| e1 e2    | binary       |          2 | sequence           |
| e1 / e2  | binary       |          1 | prioritized choice |

The *?*, *\star{}*, and *+* operators behave as in common regular expressions syntax, except
that they are greedy rather than nondeterministic. The option expression *e?* unconditionally
consumes the text matched by *e* if *e* succeeds, and the repetition expressions *e\star{}*
and *e+* always consume as many successive matches of *e* as possible.

The *&* and *!* operators denote syntactic predicates. The expression *&e* attempts to match
pattern *e*, then unconditionally backtracks to the starting point, preserving only the
knowledge of whether *e* succeeded or failed. *foo &(bar)* matches and consumes *foo* only if
it is followed by *bar*. Conversely, the expression *!e* fails if *e* succeeds, but succeeds
if *e* fails. *Identifier !LEFTARROW* matches any identifier not followed by a *LEFTARROW*.

** PEG ASCII Syntax

#+begin_example
# Hierarchical syntax

Grammar    <- Spacing Definition+ EndOfFile
Definition <- Identifier LEFTARROW expression

Expression <- Sequence (SLASH Sequence)*
Sequence   <- Prefix*
Prefix     <- (AND / NOT)? Suffix
Suffix     <- Primary (QUESTION / STAR / PLUS)?
Primary    <- Identifier !LEFTARROW
            / OPEN Expression CLOSE
            / Literal / Class / DOT

# Lexical Syntax
Identifier <- IdentStart IdentCont* Spacing
IdentStart <- [a-zA-Z]
IdentCont  <- IdentStart / [0-9]

Literal    <- ['] (!['] Char)* ['] Spacing
            / ["] (!["] Char)* ["] Spacing
Class      <- '[' (![']' Range)* ']' Spacing
Range      <- Char '-' Char / Char
Char       <- '\\' [nrt'"\[\]\\]
            / '\\' [0-2][0-7][0-7]
            / '\\' [0-7][0-7]?
            / !'\\' .

LEFTARROW  <- '<-' Spacing
SLASH      <- '/' Spacing
AND        <- '&' Spacing
NOT        <- '!' Spacing
QUESTION   <- '?' Spacing
STAR       <- '*' Spacing
PLUS       <- '+' Spacing
OPEN       <- '(' Spacing
CLOSE      <- ')' Spacing
DOT        <- '.' Spacing

Spacing    <- (Space / Comment)*
Comment    <- '#' (!EndOfLine .)* EndOfLine
Space      <- ' ' / '\t' / EndOfLine
EndOfLine  <- '\r\n' / '\n' / '\r'
EndOfFile  <- !.
#+end_example

** PEG Abstract Syntax

A 4-tuple *G = (V_{N}, V_{T}, R, e_{S})* where

- V_{N} :: A finite set of nonterminal symbols.

- V_{T} :: A finite set of terminal symbols.

- R :: A finite set of rules.

- e_{S} :: A parsing expression termed the *start expression*.

- V_{N} ∩ V_{T} = ∅ :: The intersection of the nonterminals and terminal sets are the empty set,
  meaning they share no members. They are disjoint.

- r ∈ R :: A pair *(A, e)*, written as *A ← e*, where *A ∈ V_{N}* and *e* is a parsing expression.

- For any nonterminal *A*, there is exactly one *e* such that *A ← e ∈ R*. *R* is therefore
  a function mapping nonterminals to expressions.

- R(A) :: denotes the unique expression *e* such that *A ← e ∈ R*.

If *e*, *e_{1}*, and *e_{2}* are parsing expressions, then so is:

1. *ε*, the empty string.
2. *a*, any terminal, where *a ∈ V_{T}*.
3. *A*, any nonterminal, where *A ∈ V_{N}*.
4. *e_{1} e_{2}*, a sequence.
5. *e_{1} / e_{2}*, prioritized choice.
6. *e\star{}*, zero or more repetitions.
7. *!e*, a not predicate.

** Desugaring Concrete Syntax

| sugared                    | desugared                     |
|----------------------------+-------------------------------|
| *.*                        | all the terminals in *V_{T}*  |
| *a_{1}, a_{2}, ..., a_{n}* | *a_{1} / a_{2} / ... / a_{n}* |
| *e?*                       | *e_{d} / ε*                   |
| *e+*                       | *e_{d}e\star{}_{d}*           |
| *&e*                       | *!(!e_{d})*                   |

Where *e_{d}* is the desugaring of *e*.
