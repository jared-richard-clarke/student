* Parsing Expression Grammars

*Parsing Expression Grammars: A Recognition-Based Syntactic Foundation*, Bryan Ford

** Keywords

- context-free grammars
- regular expressions
- parsing expression grammars
- BNF (Backus-Naur Form)
- lexical analysis
- unified grammars
- scannerless parsing
- packrat parsing
- syntactic predicates
- TDPL (Top Down Parsing Language)
- GTDPL (Generalized Top Down Parsing Language)

** Generative System

*{s ∈ a\star{} | s = (aa)ⁿ}*

** Recognition-Based System

*{s ∈ a\star{} | (|s| mod 2 = 0)}*

** Prioritized Choice Operator: */*

- Ordered
- Non-Commutative
- Unambiguous

#+begin_example
=== equivalent ===
A → a b | a and A → a | a b

=== non-equivalent ===
A ← a b / a and A ← a / a b
#+end_example

** PEG Operators

| operator | type         | precedence | description        |
|----------+--------------+------------+--------------------|
| ' '      | primary      |          5 | literal string     |
| " "      | primary      |          5 | literal string     |
| [ ]      | primary      |          5 | character class    |
| .        | primary      |          5 | any character      |
| (e)      | primary      |          5 | grouping           |
| e?       | unary suffix |          4 | optional           |
| e*       | unary suffix |          4 | zero-or-more       |
| e+       | unary suffix |          4 | one-or-more        |
| &e       | unary prefix |          3 | and-predicate      |
| !e       | unary prefix |          3 | not-predicate      |
| e1 e2    | binary       |          2 | sequence           |
| e1 / e2  | binary       |          1 | prioritized choice |

- empty :: A parsing expression that always succeeds without consuming any input.

- sequence :: Operator *e_{1} e_{2}* first invokes *e_{1}*, and if *e_{1}* succeeds, subsequently
  invokes *e_{2}* on the remainder of the input string not consumed by *e_{1}*. If either fails, then
  the entire sequence fails, consuming no input.

- choice :: Operator *e_{1} / e_{2}* first invokes *e_{1}*, and if *e_{1}* succeeds, returns it result
  immediately. Otherwise, if *e_{1}* fails, then the choice operator backtracks to the original input
  position at which it invoked *e_{1}* and then calls *e_{2}* instead, returning *e_{2}'s* result.

- zero-or-more :: Operator *e\star{}* consumes zero or more consecutive repetitions of its
  sub-expression *e*. Consumes as much input as possible, never backtracking.

- one-or-more :: Operator *e+* consumes one or more consecutive repetitions of its
  sub-expression *e*. Consumes as much input as possible, never backtracking.

- optional :: Operator *e?* consumes zero or one repetitions of its sub-expression *e*. Consumes as much
  input as possible, never backtracking.

- and-predicate :: Expression *&e* invokes the sub-expression *e*, then succeeds if *e* succeeds and fails
  if *e* fails. In either case it /never consumes any input/.

- not-predicate :: Expression *!e* succeeds if *e* fails and fails if *e* succeeds. In either case it
  /never consumes any input/.

** PEG ASCII Syntax

#+begin_example
# Hierarchical syntax

Grammar    <- Spacing Definition+ EndOfFile
Definition <- Identifier LEFTARROW expression

Expression <- Sequence (SLASH Sequence)*
Sequence   <- Prefix*
Prefix     <- (AND / NOT)? Suffix
Suffix     <- Primary (QUESTION / STAR / PLUS)?
Primary    <- Identifier !LEFTARROW
            / OPEN Expression CLOSE
            / Literal / Class / DOT

# Lexical Syntax
Identifier <- IdentStart IdentCont* Spacing
IdentStart <- [a-zA-Z]
IdentCont  <- IdentStart / [0-9]

Literal    <- ['] (!['] Char)* ['] Spacing
            / ["] (!["] Char)* ["] Spacing
Class      <- '[' (![']' Range)* ']' Spacing
Range      <- Char '-' Char / Char
Char       <- '\\' [nrt'"\[\]\\]
            / '\\' [0-2][0-7][0-7]
            / '\\' [0-7][0-7]?
            / !'\\' .

LEFTARROW  <- '<-' Spacing
SLASH      <- '/' Spacing
AND        <- '&' Spacing
NOT        <- '!' Spacing
QUESTION   <- '?' Spacing
STAR       <- '*' Spacing
PLUS       <- '+' Spacing
OPEN       <- '(' Spacing
CLOSE      <- ')' Spacing
DOT        <- '.' Spacing

Spacing    <- (Space / Comment)*
Comment    <- '#' (!EndOfLine .)* EndOfLine
Space      <- ' ' / '\t' / EndOfLine
EndOfLine  <- '\r\n' / '\n' / '\r'
EndOfFile  <- !.
#+end_example

** PEG Abstract Syntax

A 4-tuple *G = (V_{N}, V_{T}, R, e_{S})* where

- V_{N} :: A finite set of nonterminal symbols.

- V_{T} :: A finite set of terminal symbols.

- R :: A finite set of rules.

- e_{S} :: A parsing expression termed the *start expression*.

- V_{N} ∩ V_{T} = ∅ :: The intersection of the nonterminals and terminal sets are the empty set,
  meaning they share no members. They are disjoint.

- r ∈ R :: A pair *(A, e)*, written as *A ← e*, where *A ∈ V_{N}* and *e* is a parsing expression.

- For any nonterminal *A*, there is exactly one *e* such that *A ← e ∈ R*. *R* is therefore
  a function mapping nonterminals to expressions.

- R(A) :: denotes the unique expression *e* such that *A ← e ∈ R*.

If *e*, *e_{1}*, and *e_{2}* are parsing expressions, then so is:

1. *ε*, the empty string.
2. *a*, any terminal, where *a ∈ V_{T}*.
3. *A*, any nonterminal, where *A ∈ V_{N}*.
4. *e_{1} e_{2}*, a sequence.
5. *e_{1} / e_{2}*, prioritized choice.
6. *e\star{}*, zero or more repetitions.
7. *!e*, a not predicate.

** Desugaring Concrete Syntax

| sugared                    | desugared                     |
|----------------------------+-------------------------------|
| *.*                        | all the terminals in *V_{T}*  |
| *a_{1}, a_{2}, ..., a_{n}* | *a_{1} / a_{2} / ... / a_{n}* |
| *e?*                       | *e_{d} / ε*                   |
| *e+*                       | *e_{d}e\star{}_{d}*           |
| *&e*                       | *!(!e_{d})*                   |

Where *e_{d}* is the desugaring of *e*.
