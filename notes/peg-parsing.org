* Parsing Expression Grammars

*Parsing Expression Grammars: A Recognition-Based Syntactic Foundation*, Bryan Ford

** Generative System

*{s ∈ a\star{} | s = (aa)ⁿ}*

** Recognition-Based System

*{s ∈ a\star{} | (|s| mod 2 = 0)}*

** PEG Operators

| operator | type         | precedence | description        |
|----------+--------------+------------+--------------------|
| ' '      | primary      |          5 | literal string     |
| " "      | primary      |          5 | literal string     |
| [ ]      | primary      |          5 | character class    |
| .        | primary      |          5 | any character      |
| (e)      | primary      |          5 | grouping           |
| e?       | unary suffix |          4 | optional           |
| e*       | unary suffix |          4 | zero-or-more       |
| e+       | unary suffix |          4 | one-or-more        |
| &e       | unary prefix |          3 | and-predicate      |
| !e       | unary prefix |          3 | not-predicate      |
| e1 e2    | binary       |          2 | sequence           |
| e1 / e2  | binary       |          1 | prioritized choice |

The *?*, *\star{}*, and *+* operators behave as in common regular expressions syntax, except
that they are greedy rather than nondeterministic. The option expression *e?* unconditionally
consumes the text matched by *e* if *e* succeeds, and the repetition expressions *e\star{}*
and *e+* always consume as many successive matches of *e* as possible.

The *&* and *!* operators denote syntactic predicates. The expression *&e* attempts to match
patter *e*, then unconditionally backtracks to the starting point, preserving only the
knowledge of whether *e* succeeded or failed. Conversely, the expression *!e* fails if *e*
succeeds, but succeeds if *e* fails. *Identifier !LEFTARROW* matches any identifier not
followed by a *LEFTARROW*.

** PEG ASCII Syntax

#+begin_example
# Hierarchical syntax

Grammar    <- Spacing Definition+ EndOfFile
Definition <- Identifier LEFTARROW expression

Expression <- Sequence (SLASH Sequence)*
Sequence   <- Prefix*
Prefix     <- (AND / NOT)? Suffix
Suffix     <- Primary (QUESTION / STAR / PLUS)?
Primary    <- Identifier !LEFTARROW
            / OPEN Expression CLOSE
            / Literal / Class / DOT

# Lexical Syntax
Identifier <- IdentStart IdentCont* Spacing
IdentStart <- [a-zA-Z]
IdentCont  <- IdentStart / [0-9]

Literal    <- ['] (!['] Char)* ['] Spacing
            / ["] (!["] Char)* ["] Spacing
Class      <- '[' (![']' Range)* ']' Spacing
Range      <- Char '-' Char / Char
Char       <- '\\' [nrt'"\[\]\\]
            / '\\' [0-2][0-7][0-7]
            / '\\' [0-7][0-7]?
            / !'\\' .

LEFTARROW  <- '<-' Spacing
SLASH      <- '/' Spacing
AND        <- '&' Spacing
NOT        <- '!' Spacing
QUESTION   <- '?' Spacing
STAR       <- '*' Spacing
PLUS       <- '+' Spacing
OPEN       <- '(' Spacing
CLOSE      <- ')' Spacing
DOT        <- '.' Spacing

Spacing    <- (Space / Comment)*
Comment    <- '#' (!EndOfLine .)* EndOfLine
Space      <- ' ' / '\t' / EndOfLine
EndOfLine  <- '\r\n' / '\n' / '\r'
EndOfFile  <- !.
#+end_example

** PEG Abstract Syntax

A 4-tuple *G = (V_{N}, V_{T}, R, e_{S})* where

- V_{N} :: a finite set of nonterminal symbols.

- V_{T} :: a finite set of terminal symbols.

- R :: a finite set of rules.

- e_{S} :: a parsing expression termed the *start expression*.

- V_{N} ∩ V_{T} = ∅ :: the intersection of the nonterminals and terminal sets are the empty set,
  meaning they share no members.

- r ∈ R :: is a pair *(A, e)*, written as *A ← e*, where *A ∈ V_{N}* and *e* is a parsing expression.

- For any nonterminal *A*, there is exactly one *e* such that *A ← e ∈ R*. *R* is therefore
  a function from nonterminals to expressions.

- R(A) :: denotes the unique expression *e* such that *A ← e ∈ R*.

** Desugaring Concrete Syntax

| sugared                    | desugared                     |
|----------------------------+-------------------------------|
| *.*                        | all the terminals in *V_{T}*  |
| *a_{1}, a_{2}, ..., a_{n}* | *a_{1} / a_{2} / ... / a_{n}* |
| *e?*                       | *e_{d} / ε*                   |
| *e+*                       | *e_{d}e\star{}_{d}*           |
| *&e*                       | *!(!e_{d})*                   |

Where *e_{d}* is the desugaring of *e*.
