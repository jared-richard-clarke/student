* LPEG Parsing Machine

** Sources

| source                                                              | author                |
|---------------------------------------------------------------------+-----------------------|
| *A Text Pattern-Matching Tool Based on Parsing Expression Grammars* | Roberto Ierusalimschy |
| *Parsing Expression Grammars for Lua*                               | Roberto Ierusalimschy |

** Introduction

#+begin_quote
  "PEGs present several similarities with parsing combinators. Both use ordered choice
   and have an interface based on the acceptance of input prefixes. Moreover, both share
   the restrictions common to all top-down parsers, such as no support for left recursion.

   Typically, parsing combinators work either deterministically, by using the first result
   from a parsing function, or with full backtracking."

  — Roberto Ierusalimschy
#+end_quote

*** Basic Operations

| operation             | description                              |
|-----------------------+------------------------------------------|
| ~lpeg.P(string)~      | Literal                                  |
| ~lpeg.P(n)~           | ~n~ characters                           |
| ~lpeg.S(string)~      | Set                                      |
| ~lpeg.R("xy")~        | Range                                    |
| ~lpeg.utfR(cp1, cp2)~ | UTF-8 code point between ~cp1~ and ~cp2~ |
| ~pattern ^ n~         | At least ~n~ repetitions                 |
| ~pattern ^ -n~        | At most ~n~ repetitions                  |
| ~p1 * p2~             | Concatenation                            |
| ~p1 + p2~             | Ordered choice                           |
| ~p1 - p2~             | ~p1~ if not ~p2~                         |
| ~-p~                  | Not ~p~ or ~("" - p)~                    |
| ~#p~                  | ~p~ but consumes no input                |
| ~lpeg.B(p)~           | Current position is preceded by ~p~      |

*** ~lpeg.P(value)~ Conversion Rules

| value               | conversion                                                      |
|---------------------+-----------------------------------------------------------------|
| pattern             | Pattern                                                         |
| string              | Pattern literal                                                 |
| non-negative number | Pattern match *n* characters                                    |
| negative number     | Pattern match less than *n* characters                          |
| boolean             | Pattern that always succeeds (*true*) or always fails (*false*) |
| table               | Grammar                                                         |
| function            | Pattern equivalent of match-time capture over empty string      |

*** Captures

A capture is a pattern that produces values — the semantic information — according
to the matched string and the capture type.

| operation                     | result                                         |
|-------------------------------+------------------------------------------------|
| ~lpeg.C(pattern)~             | Match for ~pattern~ plus all its captures      |
| ~lpeg.Carg(n)~                | nth extra argument to ~lpeg.match~             |
| ~lpeg.Cb(key)~                | Previous group capture                         |
| ~lpeg.Cc(values)~             | Constant capture  of the given values          |
| ~lpeg.Cg(pattern [, key])~    | Group capture, optionally named by ~key~       |
| ~lpeg.Cp()~                   | Position capture                               |
| ~lpeg.Cs(pattern)~            | Substitution capture                           |
| ~lpeg.Ct(pattern)~            | Table capture                                  |
| ~pattern / string~            | String capture                                 |
| ~pattern / number~            | Numbered capture                               |
| ~pattern / table~             | ~table[c]~, where ~c~ is the ~pattern~ capture |
| ~pattern / function~          | Maps ~function~ over ~pattern~ captures        |
| ~pattern % function~          | Accumulates ~pattern~ captures with ~function~ |
| ~lpeg.Cmt(pattern, function)~ | Maps ~function~ over match-time captures       |

** Repetition

#+begin_quote
  "Restricted backtracking means that a PEG does only local backtracking, that is, it only
   backtracks while choosing an appropriate option in a rule. Once an option has been chosen,
   it cannot be changed because of a later failure.

   This difference in semantics has several important consequences. Among other things, it
   allows the grammar to formally specify the kind of repetition it wants, without extra
   constructions and arbitrary conventions like "the longest match rule". Repetitions in
   PEG may be greedy or non-greedy, and blind or non-blind."

   — Roberto Ierusalimschy
#+end_quote

| Repetition           | PEG              |
|----------------------+------------------|
| blind greedy         | *S <- E S / ε*   |
| non-blind greedy     | *S <- E₁ S / E₂* |
| non-blind non-greedy | *S <- E₂ / E₁ S* |

- blind greedy (possessive) :: Always matches the maximum possible span, disregarding what
  comes afterward. Equivalent to PEG's *E\star{}* operation.

- non-blind greedy :: Repeats as many times as possible so long as the rest of the pattern
  matches. Common in conventional pattern-matching tools. Usually implies some form of
  backtracking.

- blind non-greedy :: Always matches *ε*. Not useful.

- non-blind non-greedy (lazy or reluctant) :: Match the minimum number of *E₁* up to the
  first *E₂*. Equivalent to Perl's *E\star{}?* operation.

** ~lpeg~ Parsing Examples

*** Split Function

#+begin_src lua
  lpeg = require("lpeg")

  Pattern = lpeg.P
  Capture = lpeg.C
  Table   = lpeg.Ct

  function split(text, separator)
    separator = Pattern(separator)
    local element = Capture((1 - separator) ^ 0)
    -- Make table capture.
    local pattern = Table(element * (separator * element) ^ 0)
    return lpeg.match(pattern, text)
  end
#+end_src

*** Arithmetic Evaluator

#+begin_src lua
  lpeg = require("lpeg")

  Pattern  = lpeg.P
  Set      = lpeg.S
  Range    = lpeg.R
  Capture  = lpeg.C
  Var      = lpeg.V

  -- Lexical elements
  Spaces = Set(" \n\t") ^ 0
  Number = Capture(Pattern("-") ^ -1 * Range("09") ^ 1) * Spaces
  AddSub = Capture(Set("+-")) * Spaces
  MulDiv = Capture(Set("*/")) * Spaces
  Open   = "(" * Spaces
  Close  = ")" * Spaces

  -- Evaluator
  function eval(v1, op, v2)
    if (op == "+") then return v1 + v2
    elseif (op == "-") then return v1 - v2
    elseif (op == "*") then return v1 * v2
    elseif (op == "/") then return v1 / v2
    end
  end

  -- Grammar
  Grammar = Pattern{
    "Expression",
    Expression = Var("Term") * (AddSub * Var("Term") % eval) ^ 0;
    Term       = Var("Factor") * (MulDiv * Var("Factor") % eval) ^ 0;
    Factor     = Number / tonumber + Open * Var("Expression") * Close;
  }

  total = lpeg.match(Grammar, "3 + 5 * 9 / (1 + 1) - 11") --> 14.5
#+end_src

** PEG and LPEG

#+begin_quote
  "Unlike other PEG implementations, which aim at parsing, LPEG aims at pattern matching.
   Therefore, it turns PEG inside out: while PEGs define grammars using pattern expressions
   as an auxiliary construction, in LPEG the main construction is the pattern and grammars
   are only a particular way to create patterns."

   — Roberto Ierusalimschy
#+end_quote

1. Emphasizes expressions over grammars

2. Unifies the concepts of captures, semantic actions, and substitutions.

3. Novel parsing machine.

*** Notational Differences

| peg      | lpeg           |
|----------+----------------|
| &pattern | ~#pattern~     |
| !pattern | ~-pattern~     |
| p1 / p2  | ~p1 + p2~      |
| pattern* | ~pattern ^ 0~  |
| pattern+ | ~pattern ^ 1~  |
| pattern? | ~pattern ^ -1~ |

*** Grammatical Differences

#+begin_example
  # === LPEG ===

  # LPEG = [a-z]+ or S <- [a-z]+
  #        ^----^    ^---------^
  #        pattern   grammar
  #
  # PEG  = S <- [a-z]+

 >
| pattern        <- grammar / simple-pattern
|
| grammar        <- (non-terminal "<-" spaces simple-pattern)+
|
| simple-pattern <- alternative ("/" spaces alternative)*
 >
  alternative    <- ([!&]? spaces suffix)+

  suffix         <- primary ([*+?] space)*

  primary        <- "(" spaces pattern ")" spaces
                  / "." spaces
                  / literal
                  / char-class
                  / non-terminal !"<-"

  literal        <- ["] (!["] .)* ["] spaces

  char-class     <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal   <- [a-zA-Z]+ spaces

  spaces         <- [ \t\n]*
#+end_example

** ~re~ Module

LPEG provides a regex-like expression syntax via the ~re~ module. Constructions are
listed in order of decreasing precedence.

*** Syntax

| syntax              | description                   |
|---------------------+-------------------------------|
| ( p )               | Grouping                      |
| & p                 | and predicate                 |
| ! p                 | not predicate                 |
| p1 p2               | Concatenation                 |
| p1 / p2             | Ordered choice                |
| p ?                 | Optional match                |
| p *                 | Zero or more                  |
| p +                 | One or more                   |
| p ^ n               | Exactly *n* repetitions       |
| p ^ +n              | At least *n* repetitions      |
| p ^ -n              | At most *n* repetitions       |
| (name <- p)+        | Grammar                       |
| 'string'            | Literal string                |
| "string"            | Literal string                |
| [class]             | Character class               |
| .                   | Any character                 |
| %name               | Predefined character class    |
| name                | Non-terminal                  |
| <name>              | Non-terminal                  |
| {}                  | Position capture              |
| { p }               | Simple capture                |
| {: p :}             | Anonymous capture             |
| {:name: p :}        | Named capture                 |
| {~ p ~}             | Substitution capture          |
| {\vert{} p \vert{}} | Table capture                 |
| =name               | Back reference                |
| p -> 'string'       | String capture                |
| p -> "string"       | String capture                |
| p -> number         | Numbered capture              |
| p -> name           | Function/query/string capture |
| p => name           | Match-time capture            |
| p >> name           | Accumulator capture           |

*** Grammar

#+begin_src lua
  grammar = [=[

  pattern         <- expression !.
  expression      <- S (grammar / alternative)

  alternative     <- sequence ('/' S sequence)*
  sequence        <- prefix*
  prefix          <- '&' S prefix / '!' S prefix / suffix
  suffix          <- primary S (([+*?]
                   / '^' [+-]? number
                   / '->' S (string / '{}' / name)
                   / '>>' S name
                   / '=>' S name) S)*

  primary         <- '(' expression ')' / string / class / defined
                   / '{:' (name ':')? expression ':}'
                   / '=' name
                   / '{}'
                   / '{~' expression '~}'
                   / '{|' expression '|}'
                   / '{' expression '}'
                   / '.'
                   / name S !arrow
                   / '<' name '>'

  grammar         <- definition+
  definition      <- name S arrow expression

  class           <- '[' '^'? item (!']' item)* ']'
  item            <- defined / range / .
  range           <- . '-' [^]]

  S               <- (%s / '--' [^%nl]*)*
  name            <- [A-Za-z_][A-Za-z0-9_]*
  arrow           <- '<-'
  number          <- [0-9]+
  string          <- '"' [^"]* '"' / "'" [^']* "'"
  defined         <- '%' name

  ]=]

  print(re.match(grammar, grammar))   -- A self description matches itself
#+end_src

** ~re~ Parsing Examples

*** String Reversal

#+begin_src lua
  reverse = re.compile[[ R <- (!.) -> "" / ({.} R) -> "%2%1" ]]
  text = reverse:match("1234567") --> "7654321"
#+end_src

*** CSV Decoder

#+begin_src lua
  record = re.compile[[
      record  <- {| field ("," field)* |} (%nl / !.)
      field   <- escaped / content
      content <- { [^,"%nl]* }
      escaped <- '"' {~ ([^"] / '""' -> '"')* ~} '"'
  ]]
#+end_src

*** Macro Expander

#+begin_src lua
  pattern = re.compile[[
      text  <- {~ item* ~}
      item  <- macro / [^()] / "(" item* ")"
      arg   <- " "* {~ (!"," item)* ~}
      args  <- "(" arg ("," arg)* ")"
      macro <- ("apply" args) -> "%1(%2)"
             / ("add" args)   -> "%1 + %2"
             / ("mul" args)   -> "%1 * %2"
  ]]

  text = pattern:match("add(mul(a, b), apply(f, x))") --> "a * b + f(x)"
#+end_src

** The Parsing Machine

- State = (N ∪ Fail, N, StackEntry*, Capture*) :: The virtual machine keeps its state in
  four registers: *instruction*, *subject position*, *stack*, and *capture list*.

- N ∪ Fail (instruction) :: Keeps the index of the next instruction to be executed
  (a natural number). It may also have a special *Fail* value, meaning that some match
  failed and the machine must backtrack.

- N (subject position) :: Keeps the current position in the subject (a natural number).

- StackEntry* (stack) :: A list of two kinds of entries: *N ∪ (N, N, Capture\star{})*.
  The first kind represents return addresses (a natural number). Each nonterminal
  translates to a call to its corresponding production. When that production finishes
  in success it must return to the point after the call, which will be at the top of
  the stack. The second kind of entry represents pending alternatives (backtrack entries).
  Whenever there is a choice, the machine follows the first option and pushes on the
  stack information on how to pursue the other option if the first one fails. Each such
  entry comprises the instruction to follow in case of failure plus all information needed
  to backtrack to the current state (that is, the subject position and the capture list).

- Capture* (capture list) :: Keeps information about captures made by the pattern: *Capture = (N, N)*.
  Each entry stores the subject position and the index of the instruction that created the entry,
  wherein there is extra information about the capture.

*** Basic Instructions

| current state                 | instruction      | next state                 |
|-------------------------------+------------------+----------------------------|
| (p, i, e, c)                  | Char x, S[i] = x | (p+1, i+1, e, c)           |
| (p, i, e, c)                  | Char x, S[i] ≠ x | (Fail, i, e, c)            |
| (p, i, e, c)                  | Jump L           | (p+L, i, e, c)             |
| (p, i, e, c)                  | Choice L         | (p+1, i, (p+L, i, c):e, c) |
| (p, i, e, c)                  | Call L           | (p+L, i, (p+1):e, c)       |
| (p₀, i, p₁:e, c)              | Return           | (p₁, i, e, c)              |
| (p, i, h:e, c)                | Commit L         | (p+L, i, e, c)             |
| (p, i, e, c)                  | Capture K        | (p+1, i, e, (i, p):c)      |
| (p, i, e, c)                  | Fail             | (Fail, i, e, c)            |
| (Fail, i, p:e, c)             | any              | (Fail, i, e, c)            |
| (Fail, i₀, (p, i₁, c₁):e, c₀) | any              | (p, i₁, e, c₁)             |

- Char x :: If the character in the current subject position is equal to *x*. the machine
  consumes the current character and moves to the next instruction.

- Fail :: Forces failure. First the machine pops any return addresses from the top of the stack.
  If the stack is empty, the machine halts and the whole pattern fails. Otherwise, the machine
  pops the top backtrack entry and assigns the saved values to their respective registers.

- Jump label :: Jumps to instruction *label*. All instructions that need a label express the label
  as an offset from the current instruction. Jump instructions organize grammars and implement
  proper tail calls.

- Choice label :: Pushes a backtrack entry onto the stack, saving the current machine state plus
  the given label as the alternative instruction.

- Call label :: Calls instruction *label* by saving the stack address of the next instruction
  and then jumping to instruction *label*. *Call* implements non-terminals.

- Return :: Returns from a *Call*, popping an address from the stack and jumping to it. Complete
  patterns leave no entries on the stack.

- Commit label :: Commits to a *Choice*. Discards the top entry from the stack and jumps to *label*.

- Capture extra-info :: Adds an entry to the capture list with the current subject position and
  instruction. If the complete pattern matches, a post-processor traverses the capture list and,
  using the pointers to the instructions that created each entry, builds the capture values.

- End :: The machine returns, signalling that the match succeeds. This instruction appears only
  as the last one of a complete pattern.

*** Extra Instructions

| current state                | instruction                    | next state                     |
|------------------------------+--------------------------------+--------------------------------|
| (p, i, e, c)                 | Charset X, S[i] ∈ X            | (p+1, i+1, e, c)               |
| (p, i, e, c)                 | Charset X, S[i] ∉ X            | (Fail, i, e, c)                |
| (p, i, e, c)                 | Any n, i + n ≤ \vert{}S\vert{} | (p+1, i+n, e, c)               |
| (p, i, e, c)                 | Any n, i + n > \vert{}S\vert{} | (Fail, i, e, c)                |
| (p₀, i₀, (p₁, i₁, c₁):e, c₀) | PartialCommit L                | (p₀+L, i₀, (p₁, i₀, c₀):e, c₀) |
| (p, i, e, c)                 | Span X, S[i] ∈ X               | (p, i+1, e, c)                 |
| (p, i, e, c)                 | Span X, S[i] ∉ X               | (p+1, i, e, c)                 |
| (p, i, h:e, c)               | FailTwice                      | (Fail, i, e, c)                |
| (p₀, i₀, (p₁, i₁, c₁):e, c₀) | BackCommit L                   | (p₀+L, i₁, e, c₁)              |

- Charset set :: Is the current character a member of the *set*. Sets are represented as bit sets,
  with one bit for each possible character value.

- Any n :: Checks whether there are at least *n* characters in the current subject position.

** Grammars to Instructions

*** Literals

A literal string translates to a sequence of ~Char~ instructions, one for each character.
~lpeg.P(n)~ translates to ~Any n~. Both sets and ranges translate to ~Charset X~.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("ana")

  -- === Virtual Machine ===
  -- Char "a"    (p+1, i+1, e, c)
  -- Char "n"    (p+1, i+1, e, c)
  -- Char "a"    (p+1, i+1, e, c)
#+end_src

*** Concatenation

Sequences instructions.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") * lpeg.P("b") * lpeg.P("c")

  -- === Virtual Machine ===
  --  Char "a"    (p+1, i+1, e, c)
  --  Char "b"    (p+1, i+1, e, c)
  --  Char "c"    (p+1, i+1, e, c)
#+end_src

*** Ordered Choice

The machine saves the state and then runs *p1*. If *p1* successsful, executes *Commit L2*,
which removes the saved state from the stack and jumps to the end of the pattern, *L2*.
If *p1* fails, the machine backtracks to the initial saved state and jumps to *L1* and
tries *p2*. If *p2* fails then choice fails.

*Optimization 1*: If both *p1* and *p2* are character sets, *p1 + p2* translates to a single
*charset* instruction with the union of both sets.

*Optimization 2*: If the first alternative succeeds, associating left for *n* alternatives
would require traversing *n* choices plus *n* commits, whereas associating right would
require traversing only one choice-commit pair.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") + lpeg.P("b")

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L1, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L2, i, e, c)
  -- L1: Char "b"     (p+1, i+1, e, c)
  -- L2: ...

  -- === LPEG ===
  (lpeg.P("a") + lpeg.P("b")) + lpeg.P("c")

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L1, i, c):e, c)
  --     Choice L2    (p+1, i, (p+L2, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L3    (p, i, h:e, c) -> (p+L3, i, e, c)
  -- L2: Char "b"     (p+1, i+1, e, c)
  -- L3: Commit L4    (p, i, h:e, c) -> (p+L4, i, e, c)
  -- L1: Char "c"     (p+1, i+1, e, c)
  -- L4: ...

  -- === LPEG (optimization) ===
  lpeg.P("a") + (lpeg.P("b") + lpeg.P("c"))

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L1, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L2, i, e, c)
  -- L1: Choice L3    (p+1, i, (p+L3, i, c):e, c)
  --     Char "b"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L2, i, e, c)
  -- L3: Char "c"     (p+1, i+1, e, c)
  -- L2: ...
#+end_src

*** Repetition

The ~Choice~ and ~PartialCommit~ operations together create a loop where only the subject
position and the capture list are repeatedly updated. Instead of removing an entry from the stack
and adding a new one, the instruction simply updates the top entry.

Repeated character classes have a dedicated instruction, ~Span charset~ that consumes a maximum
span of input characters that belong to the given character set.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") ^ 0

  -- === Virtual Machine ===
  -- L1: Choice L2    (p+1, i, (p+L2, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L1    (p, i, h:e, c) -> (p+L1, i, e, c)
  -- L2: ...

  -- === Virtual Machine (optimization) ===
  --     Choice L2           (p+1, i, (p+L2, i, c):e, c)
  -- L1: Char "a"            (p+1, i+1, e, c)
  --     PartialCommit L1    (p₀, i₀, (p₁, i₁, c₁):e, c₀) -> (p₀+L1, i₀, (p₁, i₀, c₀):e, c₀)
  -- L2: ...
#+end_src

*** Not Predicate

The ~Choice~ and ~FailTwice~ operations together act like two consecutive fails, removing
the top entry from the stack and then failing.

The difference operator for two patterns, *p1 - p2*, is usually encoded according to *-p2 * p1*.
In the case where *p1* and *p2* are characters sets, they are encoded as a single *Charset X*
instruction that is the set difference between the two patterns.

#+begin_src lua
  -- === LPEG ===
  -lpeg.P("a")

  -- === Virtual Machine ===
  --     Choice L2    (p+1, i, (p+L2, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L1    (p, i, h:e, c) -> (p+L1, i, e, c)
  -- L1: Fail
  -- L2: ...

  -- === Virtual Machine (optimization) ===
  --     Choice L1    (p+1, i, (p+L1, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     FailTwice    (p, i, h:e, c) -> (Fail, i, e, c)
  -- L1: ...
#+end_src

*** And Predicate

If *p* succeeds, the *BackCommit* instruction backtracks to the initial subject position and
jumps to the pattern's end. If *p* fails, control goes to *L1* wherein the whole pattern fails.

#+begin_src lua
  -- === LPEG ===
  #lpeg.P("a")

  -- === Virtual Machine ===
  --     Choice L1        (p+1, i, (p+L1, i, c):e, c)
  --     Char "a"         (p+1, i+1, e, c)
  --     BackCommit L2    (p₀, i₀, (p₁, i₁, c₁):e, c₀) -> (p₀+L2, i₁, e, c₁)
  -- L1: Fail
  -- L2: ...
#+end_src

*** Calling Grammars

Each non-terminal translates to a *Call* opcode, and each rule ends with a *Return* opcode.
At its creation, a non-terminal is not yet part of a grammar, so *LPEG* inserts the placeholder
instruction *OpenCall*. Then, when the grammar is complete, *LPEG* combines the rules, ending
each with a *Return* instruction and translating each *OpenCall* to a *Call* instruction
with the appropriate offset.

#+begin_src lua
  -- === LPEG ===

  Pattern  = lpeg.P
  Var      = lpeg.V
  Set      = lpeg.S

  Grammar = Pattern {
        "S",                            -- start symbol
        S = Var("B") + (1 - Set("()")), -- S <- B / [^()]
        B = "(" * Var("S") * ")"        -- B <- "(" S ")"
  }

  -- === Virtual Machine ===
  --
  --     Call S           (p+S, i, (p+1):e, c
  --     Jump L1          (p+L1, i, e, c)
  --
  --  S: Choice L2        (p+1, i, (p+L2, i, c):e, c)
  --     Call B           (p+B, i, (p+1):e, c)
  --     Commit L3        (p, i, h:e, c) -> (p+L3, i, e, c)
  -- L2: Charset [^()]    (p+1, i+1, e, c)
  -- L3: Return           (p₀, i, p₁:e, c) -> (p₁, i, e, c)
  --
  --  B: Char '('         (p+1, i+1, e, c)
  --     Call S           (p+S, i, (p+1):e, c
  --     Char ')'         (p+1, i+1, e, c)
  --     Return           (p₀, i, p₁:e, c) -> (p₁, i, e, c)
  --
  -- L1: End
#+end_src

*** Tail Call Optimization

An *OpenCall* followed by a *Return* instruction is translated to a *Jump* instruction
— otherwise known as a tail call.

#+begin_src lua
  -- === LPEG ===

  grammar = re.compile[[ X <- "abc" / . X ]]

  -- === Virtual Machine ===
  --
  --     Call X                  (p+X, i, (p+1):e, c)
  --     Jump L1                 (p+L1, i, e, c)
  --  X: Choice L2               (p+1, i, (p+L2, i, c):e, c)
  --     Char "a"                (p+1, i+1, e, c)
  --     Char "b'                (p+1, i+1, e, c)
  --     Char "c"                (p+1, i+1, e, c)
  --     Commit L3               (p, i, h:e, c) -> (p+L3, i, e, c)
  -- L2: Any 1                   (p+1, i+n, e, c)
  --     Jump X <- Tail Call     (p+X, i, e, c)
  -- L3: Return                  (p₀, i, p₁:e, c) -> (p₁, i, e, c)
  -- L1: End
#+end_src

*** Head Fail Optimizations

#+begin_quote
  "A head fail occurs when a pattern fails at its very first check. Without optimizations,
   a head fail is somewhat costly. Typically, it involves a *Choice* operator followed by a
   failing check operator (*Char* or *Charset*). Both operations are expensive, when compared
   with other operations: the choice must save the entire machine’s state, and the failing
   check must restore that state."

   — Roberto Ierusalimschy
#+end_quote

| current state | instruction                        | next state                   |
|---------------+------------------------------------+------------------------------|
| (p, i, e, c)  | TestChar x L, S[i] = x             | (p+1, i+1, e, c)             |
| (p, i, e, c)  | TestChar x L, S[i] ≠ x             | (p+L, i, e, c)               |
| (p, i, e, c)  | TestCharset X L, S[i] ∈ X          | (p+1, i+1, e, c)             |
| (p, i, e, c)  | TestCharset X L, S[i] ∉ X          | (p+L, i, e, c)               |
| (p, i, e, c)  | TestAny n L, i+n ≤ \vert{}S\vert{} | (p+1, i+1, e, c)             |
| (p, i, e, c)  | TestAny n L, i+n > \vert{}S\vert{} | (p+L, i, e, c)               |

#+begin_src lua
  -- === LPEG ===

  grammar = re.compile[[ X <- "abc" / . X ]]

  -- === Virtual Machine ===
  --
  --     Call X
  --     Jump L1
  --  X: Choice L2 <- Expensive storing and restoring of state
  --     Char "a"  <- for a repeatedly-failing pattern
  --     Char "b'
  --     Char "c"
  --     Commit L3
  -- L2: Any 1
  --     Jump X
  -- L3: Return
  -- L1: End

  -- === Optimization ===
  --
  --     Call X            (p+X, i, (p+1):e, c)
  --     Jump L1           (p+L1, i, e, c)
  --  X: TestChar "a" L2   (p+1, i+1, e, c) or (p+L2, i, e, c)
  --     Choice L2         (p+1, i, (p+L2, i, c):e, c)
  --     Any 1             (p+1, i+n, e, c)
  --     Char "b"          (p+1, i+1, e, c)
  --     Char "c"          (p+1, i+1, e, c)
  --     Commit L3         (p, i, h:e, c) -> (p+L3, i, e, c)
  -- L2: Any 1             (p+1, i+n, e, c)
  --     Jump X            (p+X, i, e, c)
  -- L3: Return            (p₀, i, p₁:e, c) -> (p₁, i, e, c)
  -- L1: End
#+end_src

** Extended Examples

Examples as they are actually output in the ~lpeg~ debugger.

*** String to Number

#+begin_src lua
  -- === LPEG ===

  number = re.compile([[
      Real       <- (Integer Fractional Exponent) -> convert !.
      Integer    <- Sign Whole
      Whole      <- "0" / ([1-9] [0-9]*)
      Fractional <- ("." [0-9]+)?
      Exponent   <- ([eE] Sign [0-9]+)?
      Sign       <- ("+" / "-")?
  ]], { convert = tonumber })

  -- === Match ===

  n = number:match("-1.2e3") + 1 --> -1199

  -- === AST ===
  --
  -- [
  --   1 = Integer  2 = Fractional  3 = Exponent  4 = function
  --   5 = Sign     6 = Whole       7 = Sign      8 = Real
  -- ]
  --
  -- grammar 6
  --   rule key: 8
  --     xinfo n: 0
  --       sequence
  --         capture kind: 'function'  key: 4
  --           sequence
  --              call key: 1  (rule: 2)
  --              sequence
  --               call key: 2  (rule: 3)
  --               call key: 3  (rule: 4)
  --         not
  --           any
  --   rule key: 7
  --     xinfo n: 1
  --       choice
  --         set(05-1) [(2b)(2d)]
  --         true
  --   rule key: 1
  --     xinfo n: 2
  --       sequence
  --         call key: 5  (rule: 1)
  --         call key: 6  (rule: 5)
  --   rule key: 2
  --     xinfo n: 3
  --       choice
  --         sequence
  --           char '.'
  --           sequence
  --             set(06-2) [(30-39)]
  --             repeat
  --               set(06-2) [(30-39)]
  --         true
  --   rule key: 3
  --     xinfo n: 4
  --       choice
  --         seqence
  --           set(08-5) [(45)(65)]
  --           sequence
  --             call key: 7  (rule: 1)
  --             sequence
  --               set(06-2) [(30-39)]
  --               repeat
  --                 set(06-2) [(30-39)]
  --         true
  --   rule key: 6
  --     xinfo n: 5
  --       choice
  --         char '0'
  --         sequence
  --           set(06-2) [(31-39)]
  --           repeat
  --             set(06-2) [(30-39)]

  -- === VM Instructions ===
  --
  -- 00: call -> 4
  -- 02: end
  -- 03: --
  -- 04: opencapture function (idx = 4)
  -- 05: call -> 21
  -- 07: call -> 26
  -- 09: call -> 38
  -- 11: closecapture
  -- 12: testany -> 15
  -- 14: fail
  -- 15: return
  -- 16: testset (28-1) [(2b)(2d)]-> 20
  -- 19: any
  -- 20: return
  -- 21: call -> 16
  -- 23: jump -> 54
  -- 25: return
  -- 26: testchar '.' (2e)-> 37
  -- 28: choice -> 37
  -- 30: any
  -- 31: set (30-1) [(30-39)]
  -- 33: span (30-1) [(30-39)]
  -- 35: commit -> 37
  -- 37: return
  -- 38: testset (40-2) [(45)(65)]-> 53
  -- 42: choice -> 53
  -- 44: any
  -- 45: call -> 16
  -- 47: set (30-1) [(30-39)]
  -- 49: span (30-1) [(30-39)]
  -- 51: commit -> 53
  -- 53: return
  -- 54: testchar '0' (30)-> 59
  -- 56: any
  -- 57: return
  -- 58: --
  -- 59: set (30-1) [(31-39)]
  -- 61: span (30-1) [(30-39)]
  -- 63: return
  -- 64: end
#+end_src

*** Add Numbers List

#+begin_src lua
  -- === LPEG ===

  Set   = lpeg.S
  Range = lpeg.R

  spaces = Set(" \t\r\n") ^ 0
  trim   = function (x) return spaces * x * spaces end

  number = trim(Range("09") ^ 1) / tonumber

  add = function (accum, value) return accum + value end

  sum = "[" * number * ("," * number % add) ^ 0 * "]"

  -- === Match ===

  total = sum:match("[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]") --> 55

  -- === AST ===
  --
  -- [ 1 = function  2 = function  3 = function ]
  --
  -- sequence
  --   sequence
  --     sequence
  --       char '['
  --       capture kind: 'function'  key: 1
  --         sequence
  --           sequence
  --             repeat
  --               set(01-4) [(09-0a)(0d)(20)]
  --             sequence
  --               set(06-2) [(30-39)]
  --               repeat
  --                 set(06-2) [(30-39)]
  --           repeat
  --             set(01-4) [(09-0a)(0d)(20)]
  --     repeat
  --       capture kind: 'accumulator'  key: 3
  --         sequence
  --           char ','
  --          capture kind: 'function'  key: 2
  --            sequence
  --               sequence
  --                 repeat
  --                   set(01-4) [(09-0a)(0d)(20)]
  --                 sequence
  --                   set(06-2) [(30-39)]
  --                   repeat
  --                     set(06-2) [(30-39)]
  --               repeat
  --                 set(01-4) [(09-0a)(0d)(20)]
  --   char ']'

  -- === VM Instructions ===
  --
  -- 00: char '[' (5b)
  -- 01: opencapture function (idx = 1)
  -- 02: span (08-1) [(09-0a)(0d)(20)]
  -- 04: set (30-1) [(30-39)]
  -- 06: span (30-1) [(30-39)]
  -- 08: span (08-1) [(09-0a)(0d)(20)]
  -- 10: closecapture
  -- 11: testchar ',' (2c)-> 28
  -- 13: opencapture accumulator (idx = 3)
  -- 14: any
  -- 15: opencapture function (idx = 2)
  -- 16: span (08-1) [(09-0a)(0d)(20)]
  -- 18: set (30-1) [(30-39)]
  -- 20: span (30-1) [(30-39)]
  -- 22: span (08-1) [(09-0a)(0d)(20)]
  -- 24: closecapture
  -- 25: closecapture
  -- 26: jump -> 11
  -- 28: char ']' (5d)
  -- 29: end
#+end_src

*** Balanced Parentheses

#+begin_src lua
  -- === LPEG ===

  pattern = re.compile[[ Balanced <- "(" ([^()] / Balanced)* ")" ]]

  -- === Match ===

  index = pattern:match("((1 + 2) * 3)") --> 14

  -- === AST ===
  --
  -- [1 = Balanced]
  --
  -- grammar 1
  --   rule key: 1
  --     xinfo n: 0
  --       sequence
  --         char '('
  --         sequence
  --           repeat
  --             choice
  --               set(05-1) [(00-27)(2a-ff)]
  --               call key: 1  (rule: 0)
  --           char ')'

  -- === VM Instructions ===
  --
  -- 00: call -> 4
  -- 02: end
  -- 03: --
  -- 04: char '(' (28)
  -- 05: testset (28-1) [(00-28)(2a-ff)]-> 18
  -- 08: testset (28-1) [(00-27)(2a-ff)]-> 14
  -- 11: any
  -- 12: jump -> 5
  -- 14: call -> 4
  -- 16: jump -> 5
  -- 18: char ')' (29)
  -- 19: return
  -- 20: end
#+end_src

** Virtual Machine Internals

Samples of C source code from LPEG's ~match~ function, a function that runs
the opcode interpreter — otherwise known as the virtual machine.

*Side Note:* Some of the actual opcode instructions are subtly different from the examples
explicated by Ierusalimschy in his paper *A Text Pattern-Matching Tool Based on Parsing Expression Grammars*.
I have, to the best of my knowledge, updated my notes accordingly.

*** Basic Instructions

#+begin_src c
  // Side Note: "stack" points to first empty slot in "Stack".

  // Char x, s[i] = x [ (p, i, e, c) -> (p+1, i+1, e, c) ]
  // Char x, S[i] ≠ x [ (p, i, e, c) -> (Fail, i, e, c)  ]
  case IChar: {
    if ((byte)*s == p->i.aux1 && s < e) { p++; s++; }
    else { goto fail; }
    continue;
  }
  // TestChar x L, S[i] = x [ (p, i, e, c) -> (p+1, i, e, c) ]
  // TestChar x L, S[i] ≠ x [ (p, i, e, c) -> (p+L, i, e, c) ]
  case ITestChar: {
    if ((byte)*s == p->i.aux1 && s < e) { p += 2; }
    else { p += getoffset(p); }
    continue;
  }
  // Jump L [ (p, i, e, c) -> (p+L, i, e, c) ]
  case IJmp: {
    p += getoffset(p);
    continue;
  }
  // Choice L   [ (p, i, e, c) -> (p+1, i, (p+L, i, c):e, c) ]
  case IChoice: {
    if (stack == stacklimit) {
      stack = doublestack(L, &stacklimit, ptop);
    }
    stack->p = p + getoffset(p);
    stack->s = s;
    stack->caplevel = captop;
    stack++;
    p += 2;
    continue;
  }
  // Call L [ (p, i, e, c) -> (p+L, i, (p+1):e, c) ]
  case ICall: {
    if (stack == stacklimit) {
      stack = doublestack(L, &stacklimit, ptop);
    }
    stack->s = NULL;
    // Save return address.
    stack->p = p + 2;
    stack++;
    p += getoffset(p);
    continue;
  }
  // Return [ (p₀, i, p₁:e, c) -> (p₁, i, e, c) ]
  case IRet: {
    assert(stack > getstackbase(L, ptop) && (stack - 1)->s == NULL);
    p = (--stack)->p;
    continue;
  }
  // Commit L [ (p, i, h:e, c) -> (p+L, i, e, c) ]
  case ICommit: {
    assert(stack > getstackbase(L, ptop) && (stack - 1)->s != NULL);
    stack--;
    p += getoffset(p);
    continue;
  }
  // Capture (i, p) [ (p, i, e, c) -> (p+1, i, e, (i, p):c) ]
  case ICloseCapture: {
    Capture *open = findopen(capture + captop, s - o);
    assert(captop > 0);
    // If possible, turn capture into a full capture.
    if (open) {
      open->siz = (s - o) - open->index + 1;
      p++;
      continue;
    }
    // Must create a close capture.
    else {
      // Mark entry as closed.
      capture[captop].siz = 1;
      capture[captop].index = s - o;
      goto pushcapture;
    }
  }
  case IOpenCapture: {
    // Mark entry as open.
    capture[captop].siz = 0;
    capture[captop].index = s - o;
    goto pushcapture;
  }
  case IFullCapture: {
    // Save capture size.
    capture[captop].siz = getoff(p) + 1;
    capture[captop].index = s - o - getoff(p);
  }
  pushcapture: {
    capture[captop].idx = p->i.aux2.key;
    capture[captop].kind = getkind(p);
    captop++;
    capture = growcap(L, capture, &capsize, captop, 0, ptop);
    p++;
    continue;
  }
  // FailTwice [ (p, i, h:e, c) -> (Fail, i, e, c) ]
  case IFailTwice: {
    assert(stack > getstackbase(L, ptop));
    stack--;
  }
  // FALLTHROUGH
  // Fail [ (Fail, i, p:e, c)             -> (Fail, i, e, c) ]
  //      [ (Fail, i₀, (p, i₁, c₁):e, c₀) -> (p, i₁, e, c₁)  ]
  case IFail:
  // Pattern failed. Try to backtrack.
  fail: {
    // Remove pending calls.
    do {
      assert(stack > getstackbase(L, ptop));
      s = (--stack)->s;
    } while (s == NULL);
    // Are there matchtime captures?
    if (ndyncap > 0) {
      ndyncap -= removedyncap(L, capture, stack->caplevel, captop);
    }
    captop = stack->caplevel;
    p = stack->p;
    continue;
  }
  // End
  case IEnd: {
    assert(stack == getstackbase(L, ptop) + 1);
    capture[captop].kind = Cclose;
    capture[captop].index = MAXINDT;
    return s;
  }
#+end_src

*** Extra Instructions

#+begin_src c
  // Charset X, S[i] ∈ X [ (p, i, e, c) -> (p+1, i+1, e, c) ]
  // Charset X, S[i] ∉ X [ (p, i, e, c) -> (Fail, i, e, c)  ]
  case ISet: {
    uint c = (byte)*s;
    if (charinset(p, (p+1)->buff, c) && s < e)
      { p += 1 + p->i.aux2.set.size; s++; }
    else goto fail;
    continue;
  }
  // TestCharset X L, S[i] ∈ X [ (p, i, e, c) -> (p+1, i, e, c) ]
  // TestCharset X L, S[i] ∉ X [ (p, i, e, c) -> (p+L, i, e, c)   ]
  case ITestSet: {
    uint c = (byte)*s;
    if (charinset(p, (p + 2)->buff, c) && s < e) {
      p += 2 + p->i.aux2.set.size;
    }
    else { p += getoffset(p); }
    continue;
  }
  // Any n, i + n ≤ |S| [ (p, i, e, c) -> (p+1, i+n, e, c) ]
  // Any n, i + n > |S| [ (p, i, e, c) -> (Fail, i, e, c)  ]
  case IAny: {
    if (s < e) { p++; s++; }
    else goto fail;
    continue;
  }
  // TestAny n L, i+n ≤ |S| [ (p, i, e, c) -> (p+1, i, e, c) ]
  // TestAny n L, i+n > |S| [ (p, i, e, c) -> (Fail, i, e, c)  ]
  case ITestAny: {
    if (s < e) { p += 2; }
    else { p += getoffset(p); }
    continue;
  }
  // PartialCommit L [ (p₀, i₀, (p₁, i₁, c₁):e, c₀) -> (p₀+L, i₀, (p₁, i₀, c₀):e, c₀) ]
  case IPartialCommit: {
    assert(stack > getstackbase(L, ptop) && (stack - 1)->s != NULL);
    (stack - 1)->s = s;
    (stack - 1)->caplevel = captop;
    p += getoffset(p);
    continue;
  }
  // Span X, S[i] ∈ X [ (p, i, e, c) -> (p, i+1, e, c) ]
  // Span X, S[i] ∉ X [ (p, i, e, c) -> (p+1, i, e, c) ]
  case ISpan: {
    for (; s < e; s++) {
      uint c = (byte)*s;
      if (!charinset(p, (p+1)->buff, c)) { break; }
    }
    p += 1 + p->i.aux2.set.size;
    continue;
  }
  // BackCommit L [ (p₀, i₀, (p₁, i₁, c₁):e, c₀) -> (p₀+L, i₁, e, c₁) ]
  case IBackCommit: {
    assert(stack > getstackbase(L, ptop) && (stack - 1)->s != NULL);
    s = (--stack)->s;
    // Matchtime captures?
    if (ndyncap > 0) {
      ndyncap -= removedyncap(L, capture, stack->caplevel, captop);
    }
    captop = stack->caplevel;
    p += getoffset(p);
    continue;
  }
#+end_src
