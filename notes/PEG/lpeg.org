* LPEG

** Sources

| source                                                              | author                |
|---------------------------------------------------------------------+-----------------------|
| *A Text Pattern-Matching Tool Based on Parsing Expression Grammars* | Roberto Ierusalimschy |

** Introduction

#+begin_quote
  "PEGs present several similarities with parsing combinators. Both use ordered choice
   and have an interface based on the acceptance of input prefixes. Moreover, both share
   the restrictions common to all top-down parsers, such as no support for left recursion.

   Typically, parsing combinators work either deterministically, by using the first result
   from a parsing function, or with full backtracking."

  — Roberto Ierusalimschy
#+end_quote

** PEG and LPEG

#+begin_quote
  "Unlike other PEG implementations, which aim at parsing, LPEG aims at pattern matching.
   Therefore, it turns PEG inside out: while PEGs define grammars using pattern expressions
   as an auxiliary construction, in LPEG the main construction is the pattern and grammars
   are only a particular way to create patterns."

   — Roberto Ierusalimschy
#+end_quote

1. Emphasizes expressions over grammars

2. Unifies the concepts of captures, semantic actions, and substitutions.

3. Novel parsing machine.

#+begin_example
  # === PEG ===

  grammar      <- (non-terminal "<-" spaces pattern)+

  pattern      <- alternative ("/" spaces alternative)*

  alternative  <- ([!&]? spaces suffix)+

  suffix       <- primary ([*+?] space)*

  primary      <- "(" spaces pattern ")" spaces
                  / "." spaces
                  / literal
                  / char-class
                  / non-terminal !"<-"

  literal      <- ["] (!["] .)* ["] spaces

  char-class   <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal <- [a-zA-Z]+ spaces

  spaces       <- [ \t\n]*

  # === LPEG ===

  # LPEG = [a-z]+ or S <- [a-z]+
  # PEG  = S <- [a-z]+

 >
| pattern        <- grammar / simple-pattern
|
| grammar        <- (non-terminal "<-" spaces simple-pattern)+
|
| simple-pattern <- alternative ("/" spaces alternative)*
 >
  alternative    <- ([!&]? spaces suffix)+

  suffix         <- primary ([*+?] space)*

  primary        <- "(" spaces pattern ")" spaces
                    / "." spaces
                    / literal
                    / char-class
                    / non-terminal !"<-"

  literal        <- ["] (!["] .)* ["] spaces

  char-class     <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal   <- [a-zA-Z]+ spaces

  spaces         <- [ \t\n]*
#+end_example

** Repetition

- blind greedy (possessive) :: Always matches the maximum possible span, diseregarding what
  comes afterward.

- non-blind greedy :: Repeats as many times as possible so long as the rest of the pattern
  matches.

- blind non-greedy :: Always matches *ε*. Not useful.

- non-blind non-greedy (lazy or reluctant) :: Match the minimum number of *E₁* up to the
  first *E₂*.

| Repetition           | PEG              |
|----------------------+------------------|
| blind greedy         | *S <- E S / ε*   |
| non-blind greedy     | *S <- E₁ S / E₂* |
| non-blind non-greedy | *S <- E₂ / E₁ S* |

** Finite Automata to PEG

Depending on the order of the terms in rule *A*, the grammar matches the longest or the
shortest subject's prefix ending with *"ana"*.

#+begin_example
  === NFA ===

  +-.->
   \ /
   [A]-a->[B]-n->[C]-a->(D)

  === PEG ===

  A <- . A / "a" B
  B <- "n" C
  C <- "a" D
  D <- ε
#+end_example

** The Parsing Machine

- State = (N ∪ Fail, N, StackEntry*, Capture*) :: The virtual machine keeps its state in
  four registers: (current instruction, current subject position, stack, capture list)

- N ∪ Fail (current instruction) :: Keeps the index of the next instruction to be executed
  (a natural number). It may also have a special *Fail* value, meaning that some match
  failed and the machine must backtrack.

- N (current subject position) :: keeps the current position in the subject
  (a natural number).

- StackEntry* (stack) :: A list of two kinds of entries: *N ∪ (N, N, Capture\star{})*.
  The first kind represents return addresses (a natural number). Each nonterminal
  translates to a call to its corresponding production; when that production finishes
  in success it must return to the point after the call, which will be at the top of
  the stack. The second kind of entry represents pending alternatives (backtrack entries).
  Whenever there is a choice, the machine follows the first option and pushes on the
  stack information on how to pursue the other option if the first one fails. Each such
  entry comprises the instruction to follow in case of fail plus all information needed
  to backtrack to the current state (that is, the subject position and the capture list).

- Capture* (capture list) :: Keeps information about captures made by the pattern: *(N, N)*.
  Each entry stores the subject position and the index of the instruction that created the
  entry, wherein there is extra information about the capture.

*** Basic Instructions

| current state                 | instruction      | next state                 |
|-------------------------------+------------------+----------------------------|
| (p, i, e, c)                  | Char x, S[i] = x | (p+1, i+1, e, c)           |
| (p, i, e, c)                  | Char x, S[i] ≠ x | (Fail, i, e, c)            |
| (p, i, e, c)                  | Jump l           | (p+l, i, e, c)             |
| (p, i, e, c)                  | Choice l         | (p+1, i, (p+l, i, c):e, c) |
| (p, i, e, c)                  | Call l           | (p+l, i, (p+1):e, c)       |
| (p₀, i, p₁:e, c)              | Return           | (p₁, i, e, c)              |
| (p, i, h:e, c)                | Commit l         | (p+l, i, e, c)             |
| (p, i, e, c)                  | Capture k        | (p+1, i, e, (i, p):c)      |
| (p. i, e, c)                  | Fail             | (Fail, i, e, c)            |
| (Fail, i, p:e, c)             | any              | (Fail, i, e, c)            |
| (Fail, i₀, (p, i₁, c₁):e, c₀) | any              | (p, i₁, e, c₁)             |

*** Extra Instructions

| current state                | instruction                    | next state                   |
|------------------------------+--------------------------------+------------------------------|
| (p, i, e, c)                 | Charset X, S[i] ∈ X            | (p+1, i+1, e, c)             |
| (p, i, e, c)                 | Charset X, S[i] ∉ X            | (Fail, i, e, c)              |
| (p, i, e, c)                 | Any n, i + n ≤ \vert{}S\vert{} | (p+1, i+n, e, c)             |
| (p, i, e, c)                 | Any n, i + n > \vert{}S\vert{} | (Fail, i, e, c)              |
| (p₀, i₀, (p₁, i₁, c₁):e, c₀) | PartialCommit l                | (p₀+l, i₀, (p₁,i₀,c₀):e, c₀) |
| (p, i, e, c)                 | Span X, S[i] ∈ X               | (p, i+1, e, c)               |
| (p, i, e, c)                 | Span X, S[i] ∉ X               | (p+1, i, e, c)               |
| (p, i, h:e, c)               | FailTwice                      | (Fail, i, e, c)              |
| (p₀, i₀, (p₁, i₁, c₁):e, c₀) | BackCommit l                   | (p₀+l, i₁, e, c₁)            |
