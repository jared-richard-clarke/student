* LPEG

** Sources

| source                                                              | author                |
|---------------------------------------------------------------------+-----------------------|
| *A Text Pattern-Matching Tool Based on Parsing Expression Grammars* | Roberto Ierusalimschy |

** Introduction

#+begin_quote
  "PEGs present several similarities with parsing combinators. Both use ordered choice
   and have an interface based on the acceptance of input prefixes. Moreover, both share
   the restrictions common to all top-down parsers, such as no support for left recursion.

   Typically, parsing combinators work either deterministically, by using the first result
   from a parsing function, or with full backtracking."

  — Roberto Ierusalimschy
#+end_quote

** PEG and LPEG

#+begin_quote
  "Unlike other PEG implementations, which aim at parsing, LPEG aims at pattern matching.
   Therefore, it turns PEG inside out: while PEGs define grammars using pattern expressions
   as an auxiliary construction, in LPEG the main construction is the patternm and grammars
   are only a particular way to create patterns."

   — Roberto Ierusalimschy
#+end_quote

1. Emphasizes expressions over grammars

2. Unifies the concepts of captures, semantic actions, and substitutions.

3. Novel parsing machine.

#+begin_example
  # === PEG ===

  grammar      <- (non-terminal "<-" spaces pattern)+

  pattern      <- alternative ("/" spaces alternative)*

  alternative  <- ([!&]? spaces suffix)+

  suffix       <- primary ([*+?] space)*

  primary      <- "(" spaces pattern ")" spaces
                  / "." spaces
                  / literal
                  / char-class
                  / non-terminal !"<-"

  literal      <- ["] (!["] .)* ["] spaces

  char-class   <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal <- [a-zA-Z]+ spaces

  spaces       <- [ \t\n]*

  # === LPEG ===

  # LPEG = [a-z]+ or S <- [a-z]+
  # PEG  = S <- [a-z]+

 >
| pattern        <- grammar / simple-pattern
|
| grammar        <- (non-terminal "<-" spaces simple-pattern)+
|
| simple-pattern <- alternative ("/" spaces alternative)*
 >
  alternative    <- ([!&]? spaces suffix)+

  suffix         <- primary ([*+?] space)*

  primary        <- "(" spaces pattern ")" spaces
                    / "." spaces
                    / literal
                    / char-class
                    / non-terminal !"<-"

  literal        <- ["] (!["] .)* ["] spaces

  char-class     <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal   <- [a-zA-Z]+ spaces

  spaces         <- [ \t\n]*
#+end_example

** Repetition

- blind greedy (possessive) :: Always matches the maximum possible span, diseregarding what
  comes afterward.

- non-blind greedy :: Repeats as many times as possible so long as the rest of the pattern
  matches.

- blind non-greedy :: Always matches *ε*. Not useful.

- non-blind non-greedy (lazy or reluctant) :: Match the minimum number of *E₁* up to the
  first *E₂*.

| Repetition           | PEG              |
|----------------------+------------------|
| blind greedy         | *S <- E S / ε*   |
| non-blind greedy     | *S <- E₁ S / E₂* |
| non-blind non-greedy | *S <- E₂ / E₁ S* |

** Finite Automata to PEG

Depending on the order of the terms in rule *A*, the grammar matches the longest or the
shortest subject's prefix ending with *ana*.

#+begin_example
  === NFA ===

  +-.->
   \ /
   [A]-a->[B]-n->[C]-a->(D)

  === PEG ===

  A <- . A / "a" B
  B <- "n" C
  C <- "a" D
  D <- ε
#+end_example
