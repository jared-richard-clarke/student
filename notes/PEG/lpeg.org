* LPEG Parsing Machine

** Sources

| source                                                              | author                |
|---------------------------------------------------------------------+-----------------------|
| *A Text Pattern-Matching Tool Based on Parsing Expression Grammars* | Roberto Ierusalimschy |
| *Parsing Expression Grammars for Lua*                               | Roberto Ierusalimschy |

** Introduction

#+begin_quote
  "PEGs present several similarities with parsing combinators. Both use ordered choice
   and have an interface based on the acceptance of input prefixes. Moreover, both share
   the restrictions common to all top-down parsers, such as no support for left recursion.

   Typically, parsing combinators work either deterministically, by using the first result
   from a parsing function, or with full backtracking."

  — Roberto Ierusalimschy
#+end_quote

*** Basic Operations

| operator              | description                                                       |
|-----------------------+-------------------------------------------------------------------|
| ~lpeg.P(string)~      | Matches literal string                                            |
| ~lpeg.P(n)~           | Matches *n* characters                                            |
| ~lpeg.S(string)~      | Matches any character in string (Set)                             |
| ~lpeg.R("xy")~        | Matches any character between *x* and *y* (Range)                 |
| ~lpeg.utfR(cp1, cp2)~ | Matches UTF-8 code point between *cp1* and *cp2*                  |
| ~pattern ^ n~         | Matches at least *n* repetitions of *pattern*                     |
| ~pattern ^ -n~        | Matches at most *n* repetitions of *pattern*                      |
| ~p1 * p2~             | Matches *p1* followed by *p2*                                     |
| ~p1 + p2~             | Matches *p1* or *p2* (ordered choice)                             |
| ~p1 - p2~             | Matches *p1* if *p2* does not match                               |
| ~-pattern~            | Equivalent to ~("" - pattern)~                                    |
| ~#pattern~            | Matches *pattern* but consumes no input                           |
| ~lpeg.B(pattern)~     | Matches *pattern* behind the current position, consuming no input |

** PEG and LPEG

#+begin_quote
  "Unlike other PEG implementations, which aim at parsing, LPEG aims at pattern matching.
   Therefore, it turns PEG inside out: while PEGs define grammars using pattern expressions
   as an auxiliary construction, in LPEG the main construction is the pattern and grammars
   are only a particular way to create patterns."

   — Roberto Ierusalimschy
#+end_quote

1. Emphasizes expressions over grammars

2. Unifies the concepts of captures, semantic actions, and substitutions.

3. Novel parsing machine.

*** Notational Differences

| peg      | lpeg           |
|----------+----------------|
| &pattern | ~#pattern~     |
| !pattern | ~-pattern~     |
| p1 / p2  | ~p1 + p2~      |
| pattern* | ~pattern ^ 0~  |
| pattern+ | ~pattern ^ 1~  |
| pattern? | ~pattern ^ -1~ |

*** Grammatical Differences

#+begin_example
  # === PEG ===

  grammar      <- (non-terminal "<-" spaces pattern)+

  pattern      <- alternative ("/" spaces alternative)*

  alternative  <- ([!&]? spaces suffix)+

  suffix       <- primary ([*+?] space)*

  primary      <- "(" spaces pattern ")" spaces
                  / "." spaces
                  / literal
                  / char-class
                  / non-terminal !"<-"

  literal      <- ["] (!["] .)* ["] spaces

  char-class   <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal <- [a-zA-Z]+ spaces

  spaces       <- [ \t\n]*

  # === LPEG ===

  # LPEG = [a-z]+ or S <- [a-z]+
  #        ^----^    ^---------^
  #        pattern   grammar
  #
  # PEG  = S <- [a-z]+

 >
| pattern        <- grammar / simple-pattern
|
| grammar        <- (non-terminal "<-" spaces simple-pattern)+
|
| simple-pattern <- alternative ("/" spaces alternative)*
 >
  alternative    <- ([!&]? spaces suffix)+

  suffix         <- primary ([*+?] space)*

  primary        <- "(" spaces pattern ")" spaces
                    / "." spaces
                    / literal
                    / char-class
                    / non-terminal !"<-"

  literal        <- ["] (!["] .)* ["] spaces

  char-class     <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal   <- [a-zA-Z]+ spaces

  spaces         <- [ \t\n]*
#+end_example

** Repetition

- blind greedy (possessive) :: Always matches the maximum possible span, disregarding what
  comes afterward.

- non-blind greedy :: Repeats as many times as possible so long as the rest of the pattern
  matches.

- blind non-greedy :: Always matches *ε*. Not useful.

- non-blind non-greedy (lazy or reluctant) :: Match the minimum number of *E₁* up to the
  first *E₂*.

| Repetition           | PEG              |
|----------------------+------------------|
| blind greedy         | *S <- E S / ε*   |
| non-blind greedy     | *S <- E₁ S / E₂* |
| non-blind non-greedy | *S <- E₂ / E₁ S* |

** Finite Automata to PEG

Depending on the order of the terms in rule *A*, the grammar matches the longest or the
shortest subject's prefix ending with *ana*.

#+begin_example
  === NFA ===

  +-.->
   \ /
   [A]-a->[B]-n->[C]-a->(D)

  === PEG ===

  A <- . A / "a" B
  B <- "n" C
  C <- "a" D
  D <- ε
#+end_example

** The Parsing Machine

- State = (N ∪ Fail, N, StackEntry*, Capture*) :: The virtual machine keeps its state in
  four registers: (current instruction, current subject position, stack, capture list)

- N ∪ Fail (current instruction) :: Keeps the index of the next instruction to be executed
  (a natural number). It may also have a special *Fail* value, meaning that some match
  failed and the machine must backtrack.

- N (current subject position) :: keeps the current position in the subject (a natural number).

- StackEntry* (stack) :: A list of two kinds of entries: *N ∪ (N, N, Capture\star{})*.
  The first kind represents return addresses (a natural number). Each nonterminal
  translates to a call to its corresponding production. When that production finishes
  in success it must return to the point after the call, which will be at the top of
  the stack. The second kind of entry represents pending alternatives (backtrack entries).
  Whenever there is a choice, the machine follows the first option and pushes on the
  stack information on how to pursue the other option if the first one fails. Each such
  entry comprises the instruction to follow in case of failure plus all information needed
  to backtrack to the current state (that is, the subject position and the capture list).

- Capture* (capture list) :: Keeps information about captures made by the pattern: *(N, N)*.
  Each entry stores the subject position and the index of the instruction that created the
  entry, wherein there is extra information about the capture.

*** Basic Instructions

| current state                 | instruction      | next state                 |
|-------------------------------+------------------+----------------------------|
| (p, i, e, c)                  | Char x, S[i] = x | (p+1, i+1, e, c)           |
| (p, i, e, c)                  | Char x, S[i] ≠ x | (Fail, i, e, c)            |
| (p, i, e, c)                  | Jump l           | (p+l, i, e, c)             |
| (p, i, e, c)                  | Choice l         | (p+1, i, (p+l, i, c):e, c) |
| (p, i, e, c)                  | Call l           | (p+l, i, (p+1):e, c)       |
| (p₀, i, p₁:e, c)              | Return           | (p₁, i, e, c)              |
| (p, i, h:e, c)                | Commit l         | (p+l, i, e, c)             |
| (p, i, e, c)                  | Capture k        | (p+1, i, e, (i, p):c)      |
| (p, i, e, c)                  | Fail             | (Fail, i, e, c)            |
| (Fail, i, p:e, c)             | any              | (Fail, i, e, c)            |
| (Fail, i₀, (p, i₁, c₁):e, c₀) | any              | (p, i₁, e, c₁)             |

- Char char :: If the character in the current subject position is equal to *char*. the machine
  consumes the current character and moves to the next instruction.

- Fail :: Forces failure. First the machine pops any return addresses from the top of the stack.
  If the stack is empty, the machine halts and the whole pattern fails. Otherwise, the machine
  pops the top backtrack entry and assigns the saved values to their respective registers.

- Jump label :: Jumps to instruction *label*. All instructions that need a label express the label
  as an offset from the current instruction. Jump instructions organize grammars and implement
  proper tail calls.

- Choice label :: Pushes a backtrack entry onto the stack, saving the current machine state plus
  the given label as the alternative instruction.

- Call label :: Calls instruction *label* by saving the stack address of the next instruction
  and then jumping to instruction *label*. *Call* implements non-terminals.

- Return :: Returns from a *Call*, popping an address from the stack and jumping to it. Complete
  patterns leave no entries on the stack.

- Commit label :: Commits to a *Choice*. Discards the top entry from the stack and jumps to *label*.

- Capture extra-info :: Adds an entry to the capture list with the current subject position and
  instruction. If the complete pattern matches, a postprocessor traverses the capture list and,
  using the pointers to the instructions that created each entry, builds the capture values.

- End :: The machine returns, signalling that the match succeeds.

*** Extra Instructions

| current state                | instruction                    | next state                   |
|------------------------------+--------------------------------+------------------------------|
| (p, i, e, c)                 | Charset X, S[i] ∈ X            | (p+1, i+1, e, c)             |
| (p, i, e, c)                 | Charset X, S[i] ∉ X            | (Fail, i, e, c)              |
| (p, i, e, c)                 | Any n, i + n ≤ \vert{}S\vert{} | (p+1, i+n, e, c)             |
| (p, i, e, c)                 | Any n, i + n > \vert{}S\vert{} | (Fail, i, e, c)              |
| (p₀, i₀, (p₁, i₁, c₁):e, c₀) | PartialCommit l                | (p₀+l, i₀, (p₁,i₀,c₀):e, c₀) |
| (p, i, e, c)                 | Span X, S[i] ∈ X               | (p, i+1, e, c)               |
| (p, i, e, c)                 | Span X, S[i] ∉ X               | (p+1, i, e, c)               |
| (p, i, h:e, c)               | FailTwice                      | (Fail, i, e, c)              |
| (p₀, i₀, (p₁, i₁, c₁):e, c₀) | BackCommit l                   | (p₀+l, i₁, e, c₁)            |

- Charset set :: Is the current character a member of the *set*. Sets are represented as bit sets,
  with one bit for each possible character value.

- Any n :: Checks whether there are at least *n* characters in the current subject position.

*** Code for Grammars

#+begin_example
  === LPEG ==

  g = lpeg.P{
        "S",                                  -- start symbol
        S = lpeg.V("B") + (1 - lpeg.S("()")), -- S <- <B> / [^()]
        B = '(' * lpeg.V("S") * ')'           -- B <- '(' <S> ')'
  }

  === Virtual Machine ===

      Call S
      Jump L2

   S: Choice L4
      Call B
      Commit L5
  L4: Charset [^()]
  L5: Return

   B: Char '('
      Call S
      Char ')'
      Return

  L2: End
#+end_example
