* LPEG Parsing Machine

** Sources

| source                                                              | author                                    |
|---------------------------------------------------------------------+-------------------------------------------|
| *A Text Pattern-Matching Tool Based on Parsing Expression Grammars* | Roberto Ierusalimschy                     |
| *Parsing Expression Grammars for Lua*                               | Roberto Ierusalimschy                     |
| *A Parsing Machine for PEGs*                                        | Sérgio Medeiros and Roberto Ierusalimschy |

** Introduction

#+begin_quote
  "PEGs present several similarities with parsing combinators. Both use ordered choice
   and have an interface based on the acceptance of input prefixes. Moreover, both share
   the restrictions common to all top-down parsers, such as no support for left recursion.

   Typically, parsing combinators work either deterministically, by using the first result
   from a parsing function, or with full backtracking."

  — Roberto Ierusalimschy
#+end_quote

*** Basic Operations

| operation             | description                              |
|-----------------------+------------------------------------------|
| ~lpeg.P(string)~      | Literal                                  |
| ~lpeg.P(n)~           | ~n~ characters                           |
| ~lpeg.S(string)~      | Set                                      |
| ~lpeg.R("xy")~        | Range                                    |
| ~lpeg.utfR(cp1, cp2)~ | UTF-8 code point between ~cp1~ and ~cp2~ |
| ~pattern ^ n~         | At least ~n~ repetitions                 |
| ~pattern ^ -n~        | At most ~n~ repetitions                  |
| ~p1 * p2~             | Concatenation                            |
| ~p1 + p2~             | Ordered choice                           |
| ~p1 - p2~             | ~p1~ if not ~p2~                         |
| ~-p~                  | Not ~p~ or ~("" - p)~                    |
| ~#p~                  | ~p~ but consumes no input                |
| ~lpeg.B(p)~           | Current position is preceded by ~p~      |

*** ~lpeg.P(value)~ Conversion Rules

| value               | conversion                                                      |
|---------------------+-----------------------------------------------------------------|
| pattern             | Pattern                                                         |
| string              | Pattern literal                                                 |
| non-negative number | Pattern match *n* characters                                    |
| negative number     | Pattern match less than *n* characters                          |
| boolean             | Pattern that always succeeds (*true*) or always fails (*false*) |
| table               | Grammar                                                         |
| function            | Pattern equivalent of match-time capture over empty string      |

*** Captures

A capture is a pattern that produces values — the semantic information — according
to the matched string and the capture type.

| operation                     | result                                         |
|-------------------------------+------------------------------------------------|
| ~lpeg.C(pattern)~             | Match for ~pattern~ plus all its captures      |
| ~lpeg.Carg(n)~                | nth extra argument to ~lpeg.match~             |
| ~lpeg.Cb(key)~                | Previous group capture                         |
| ~lpeg.Cc(values)~             | Constant capture  of the given values          |
| ~lpeg.Cg(pattern [, key])~    | Group capture, optionally named by ~key~       |
| ~lpeg.Cp()~                   | Position capture                               |
| ~lpeg.Cs(pattern)~            | Substitution capture                           |
| ~lpeg.Ct(pattern)~            | Table capture                                  |
| ~pattern / string~            | String capture                                 |
| ~pattern / number~            | Numbered capture                               |
| ~pattern / table~             | ~table[c]~, where ~c~ is the ~pattern~ capture |
| ~pattern / function~          | Maps ~function~ over ~pattern~ captures        |
| ~pattern % function~          | Accumulates ~pattern~ captures with ~function~ |
| ~lpeg.Cmt(pattern, function)~ | Maps ~function~ over match-time captures       |

** Repetition

#+begin_quote
  "Restricted backtracking means that a PEG does only local backtracking, that is, it only
   backtracks while choosing an appropriate option in a rule. Once an option has been chosen,
   it cannot be changed because of a later failure.

   This difference in semantics has several important consequences. Among other things, it
   allows the grammar to formally specify the kind of repetition it wants, without extra
   constructions and arbitrary conventions like "the longest match rule". Repetitions in
   PEG may be greedy or non-greedy, and blind or non-blind."

   — Roberto Ierusalimschy
#+end_quote

| Repetition           | PEG              |
|----------------------+------------------|
| blind greedy         | *S <- E S / ε*   |
| non-blind greedy     | *S <- E₁ S / E₂* |
| non-blind non-greedy | *S <- E₂ / E₁ S* |

- blind greedy (possessive) :: Always matches the maximum possible span, disregarding what
  comes afterward. Equivalent to PEG's *E\star{}* operation.

- non-blind greedy :: Repeats as many times as possible so long as the rest of the pattern
  matches. Common in conventional pattern-matching tools. Usually implies some form of
  backtracking.

- blind non-greedy :: Always matches *ε*. Not useful.

- non-blind non-greedy (lazy or reluctant) :: Match the minimum number of *E₁* up to the
  first *E₂*. Equivalent to Perl's *E\star{}?* operation.

** ~lpeg~ Parsing Examples

*** Split Function

#+begin_src lua
  lpeg = require("lpeg")

  Pattern = lpeg.P
  Capture = lpeg.C
  Table   = lpeg.Ct

  function split(text, separator)
    separator = Pattern(separator)
    local element = Capture((1 - separator) ^ 0)
    -- Make table capture.
    local pattern = Table(element * (separator * element) ^ 0)
    return lpeg.match(pattern, text)
  end
#+end_src

*** Arithmetic Evaluator

#+begin_src lua
  lpeg = require("lpeg")

  Pattern  = lpeg.P
  Set      = lpeg.S
  Range    = lpeg.R
  Capture  = lpeg.C
  Var      = lpeg.V

  -- Lexical elements
  Spaces = Set(" \n\t") ^ 0
  Number = Capture(Pattern("-") ^ -1 * Range("09") ^ 1) * Spaces
  AddSub = Capture(Set("+-")) * Spaces
  MulDiv = Capture(Set("*/")) * Spaces
  Open   = "(" * Spaces
  Close  = ")" * Spaces

  -- Evaluator
  function eval(v1, op, v2)
    if (op == "+") then return v1 + v2
    elseif (op == "-") then return v1 - v2
    elseif (op == "*") then return v1 * v2
    elseif (op == "/") then return v1 / v2
    end
  end

  -- Grammar
  Grammar = Pattern {
    "Expression",
    Expression = Var("Term") * (AddSub * Var("Term") % eval) ^ 0,
    Term       = Var("Factor") * (MulDiv * Var("Factor") % eval) ^ 0,
    Factor     = Number / tonumber + Open * Var("Expression") * Close
  }

  total = lpeg.match(Grammar, "3 + 5 * 9 / (1 + 1) - 11") --> 14.5
#+end_src

** PEG and LPEG

#+begin_quote
  "Unlike other PEG implementations, which aim at parsing, LPEG aims at pattern matching.
   Therefore, it turns PEG inside out: while PEGs define grammars using pattern expressions
   as an auxiliary construction, in LPEG the main construction is the pattern and grammars
   are only a particular way to create patterns."

   — Roberto Ierusalimschy
#+end_quote

1. Emphasizes expressions over grammars

2. Unifies the concepts of captures, semantic actions, and substitutions.

3. Novel parsing machine.

*** Notational Differences

| peg      | lpeg           |
|----------+----------------|
| &pattern | ~#pattern~     |
| !pattern | ~-pattern~     |
| p1 / p2  | ~p1 + p2~      |
| pattern* | ~pattern ^ 0~  |
| pattern+ | ~pattern ^ 1~  |
| pattern? | ~pattern ^ -1~ |

*** Grammatical Differences

#+begin_example
  # === LPEG ===

  # LPEG = [a-z]+ or S <- [a-z]+
  #        ^----^    ^---------^
  #        pattern   grammar
  #
  # PEG  = S <- [a-z]+

 >
| pattern        <- grammar / simple-pattern
|
| grammar        <- (non-terminal "<-" spaces simple-pattern)+
|
| simple-pattern <- alternative ("/" spaces alternative)*
 >
  alternative    <- ([!&]? spaces suffix)+

  suffix         <- primary ([*+?] space)*

  primary        <- "(" spaces pattern ")" spaces
                  / "." spaces
                  / literal
                  / char-class
                  / non-terminal !"<-"

  literal        <- ["] (!["] .)* ["] spaces

  char-class     <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal   <- [a-zA-Z]+ spaces

  spaces         <- [ \t\n]*
#+end_example

** ~re~ Module

LPEG provides a regex-like expression syntax via the ~re~ module. Constructions are
listed in order of decreasing precedence.

*** Syntax

| syntax              | description                   |
|---------------------+-------------------------------|
| ( p )               | Grouping                      |
| & p                 | and predicate                 |
| ! p                 | not predicate                 |
| p1 p2               | Concatenation                 |
| p1 / p2             | Ordered choice                |
| p ?                 | Optional match                |
| p *                 | Zero or more                  |
| p +                 | One or more                   |
| p ^ n               | Exactly *n* repetitions       |
| p ^ +n              | At least *n* repetitions      |
| p ^ -n              | At most *n* repetitions       |
| (name <- p)+        | Grammar                       |
| 'string'            | Literal string                |
| "string"            | Literal string                |
| [class]             | Character class               |
| .                   | Any character                 |
| %name               | Predefined character class    |
| name                | Non-terminal                  |
| <name>              | Non-terminal                  |
| {}                  | Position capture              |
| { p }               | Simple capture                |
| {: p :}             | Anonymous capture             |
| {:name: p :}        | Named capture                 |
| {~ p ~}             | Substitution capture          |
| {\vert{} p \vert{}} | Table capture                 |
| =name               | Back reference                |
| p -> 'string'       | String capture                |
| p -> "string"       | String capture                |
| p -> number         | Numbered capture              |
| p -> name           | Function/query/string capture |
| p => name           | Match-time capture            |
| p >> name           | Accumulator capture           |

*** Grammar

#+begin_src lua
  grammar = [=[
    pattern     <- expression !.
    expression  <- S (grammar / alternative)

    alternative <- sequence ('/' S sequence)*
    sequence    <- prefix*
    prefix      <- '&' S prefix / '!' S prefix / suffix
    suffix      <- primary S (([+*?]
                              / '^' [+-]? number
                              / '->' S (string / '{}' / name)
                              / '>>' S name
                              / '=>' S name) S)*

    primary     <- '(' expression ')' / string / class / defined
                 / '{:' (name ':')? expression ':}'
                 / '=' name
                 / '{}'
                 / '{~' expression '~}'
                 / '{|' expression '|}'
                 / '{' expression '}'
                 / '.'
                 / name S !arrow
                 / '<' name '>'

    grammar     <- definition+
    definition  <- name S arrow expression

    class       <- '[' '^'? item (!']' item)* ']'
    item        <- defined / range / .
    range       <- . '-' [^]]

    S           <- (%s / '--' [^%nl]*)*
    name        <- [A-Za-z_][A-Za-z0-9_]*
    arrow       <- '<-'
    number      <- [0-9]+
    string      <- '"' [^"]* '"' / "'" [^']* "'"
    defined     <- '%' name
  ]=]

  print(re.match(grammar, grammar)) -- A self description matches itself.
#+end_src

** ~re~ Parsing Examples

*** CSV Decoder

#+begin_src lua
  record = re.compile[[
      record  <- {| field ("," field)* |} (%nl / !.)
      field   <- escaped / content
      content <- { [^,"%nl]* }
      escaped <- '"' {~ ([^"] / '""' -> '"')* ~} '"'
  ]]
#+end_src

*** Macro Expander

#+begin_src lua
  pattern = re.compile[[
      text  <- {~ item* ~}
      item  <- macro / [^()] / "(" item* ")"
      arg   <- " "* {~ (!"," item)* ~}
      args  <- "(" arg ("," arg)* ")"
      macro <- ("apply" args) -> "%1(%2)"
             / ("add" args)   -> "%1 + %2"
             / ("mul" args)   -> "%1 * %2"
  ]]

  text = pattern:match("add(mul(a, b), apply(f, x))") --> "a * b + f(x)"
#+end_src

** The Parsing Machine

- State = (N ∪ Fail, N, StackEntry*, Capture*) :: The virtual machine keeps its state in
  four registers: *instruction*, *subject position*, *stack*, and *capture list*.

- N ∪ Fail (instruction) :: Keeps the index of the next instruction to be executed
  (a natural number). It may also have a special *Fail* value, meaning that some match
  failed and the machine must backtrack.

- N (subject position) :: Keeps the current position in the subject (a natural number).

- StackEntry* (stack) :: A list of two kinds of entries: *N ∪ (N, N, Capture\star{})*.
  The first kind represents return addresses (a natural number). Each nonterminal
  translates to a call to its corresponding production. When that production finishes
  in success it must return to the point after the call, which will be at the top of
  the stack. The second kind of entry represents pending alternatives (backtrack entries).
  Whenever there is a choice, the machine follows the first option and pushes on the
  stack information on how to pursue the other option if the first one fails. Each such
  entry comprises the instruction to follow in case of failure plus all information needed
  to backtrack to the current state (that is, the subject position and the capture list).

- Capture* (capture list) :: Keeps information about captures made by the pattern: *Capture = (N, N)*.
  Each entry stores the subject position and the index of the instruction that created the entry,
  wherein there is extra information about the capture.

*** Basic Instructions

| current state                 | instruction      | next state                 |
|-------------------------------+------------------+----------------------------|
| (p, i, e, c)                  | Char x, S[i] = x | (p+1, i+1, e, c)           |
| (p, i, e, c)                  | Char x, S[i] ≠ x | (Fail, i, e, c)            |
| (p, i, e, c)                  | Jump L           | (p+L, i, e, c)             |
| (p, i, e, c)                  | Choice L         | (p+1, i, (p+L, i, c):e, c) |
| (p, i, e, c)                  | Call L           | (p+L, i, (p+1):e, c)       |
| (p₂, i, p₁:e, c)              | Return           | (p₁, i, e, c)              |
| (p, i, h:e, c)                | Commit L         | (p+L, i, e, c)             |
| (p, i, e, c)                  | Capture K        | (p+1, i, e, (i, p):c)      |
| (p, i, e, c)                  | Fail             | (Fail, i, e, c)            |
| (Fail, i, p:e, c)             | any              | (Fail, i, e, c)            |
| (Fail, i₂, (p, i₁, c₁):e, c₂) | any              | (p, i₁, e, c₁)             |

- Char x :: Tries to match the character *x* against the current subject position, advancing
  one position if successful.

- Fail :: Forces failure. First the machine pops any return addresses from the top of the stack.
  If the stack is empty, the machine halts and the whole pattern fails. Otherwise, the machine
  pops the top backtrack entry and assigns the saved values to their respective registers.

- Jump label :: Jumps to the instruction at offset *label*.

- Choice label :: Pushes a backtrack entry onto the stack, saving the current machine state plus
  the given label as an offset to the alternative instruction.

- Call label :: Pushes the address of the next instruction onto the stack and then jumps to the
  instruction at offset *label*.

- Return :: Pops an address from the stack and jumps to it.

- Commit label :: Commits to a *Choice*. Discards the top entry from the stack and jumps to the
  instruction at offset *label*.

- Capture extra-info :: Adds an entry to the capture list with the current subject position and
  instruction. If the complete pattern matches, a post-processor traverses the capture list and,
  using the pointers to the instructions that created each entry, builds the capture values.

- End :: The machine returns, signaling a successful match. This instruction appears only
  as the last instruction of a complete pattern.

*** Extra Instructions
| current state                | instruction                  | next state                     |
|------------------------------+------------------------------+--------------------------------|
| (p, i, e, c)                 | Charset X, S[i] ∈ X          | (p+1, i+1, e, c)               |
| (p, i, e, c)                 | Charset X, S[i] ∉ X          | (Fail, i, e, c)                |
| (p, i, e, c)                 | Any, i + 1 ≤ \vert{}S\vert{} | (p+1, i+1, e, c)               |
| (p, i, e, c)                 | Any, i + 1 > \vert{}S\vert{} | (Fail, i, e, c)                |
| (p₂, i₂, (p₁, i₁, c₁):e, c₂) | PartialCommit L              | (p₂+L, i₂, (p₁, i₂, c₂):e, c₂) |
| (p, i, e, c)                 | Span X, S[i] ∈ X             | (p, i+1, e, c)                 |
| (p, i, e, c)                 | Span X, S[i] ∉ X             | (p+1, i, e, c)                 |
| (p, i, h:e, c)               | FailTwice                    | (Fail, i, e, c)                |
| (p₂, i₂, (p₁, i₁, c₁):e, c₂) | BackCommit L                 | (p₂+L, i₁, e, c₁)              |

- Charset set :: If the current character is a member of *set*, instruction consumes the character
  and moves forward one instruction. Fails otherwise. Sets are represented as bit sets, with one
  bit for each possible value of a character. Each instruction uses 256 extra bits, or 16 bytes, to
  represent its set.

- Any :: Advances one position if the current position plus one is less than or equal to the length
  of the input. Fails otherwise.

** Patterns to Instructions

*** Literals

A literal string translates to a sequence of ~Char~ instructions, one for each character.
~lpeg.P(n)~ translates to ~Any n~. Both sets and ranges translate to ~Charset X~.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("abc")

  -- === Virtual Machine ===
  -- Char "a"    (p+1, i+1, e, c)
  -- Char "b"    (p+1, i+1, e, c)
  -- Char "c"    (p+1, i+1, e, c)
#+end_src

*** Concatenation

Sequences instructions. Instruction ~p1~ is followed by instruction ~p2~.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") * lpeg.P("b") * lpeg.P("c")

  -- === Virtual Machine ===
  --  Char "a"    (p+1, i+1, e, c)
  --  Char "b"    (p+1, i+1, e, c)
  --  Char "c"    (p+1, i+1, e, c)
#+end_src

*** Ordered Choice

The machine saves the state and then runs ~p1~. If ~p1~ successsful, executes ~Commit L2~,
which removes the saved state from the stack and jumps to the end of the pattern, ~L2~.
If ~p1~ fails, the machine backtracks to the initial saved state and jumps to ~L1~ and
tries ~p2~. If ~p2~ fails then choice fails.

*Optimization 1*: If both ~p1~ and ~p2~ are character sets, ~p1 + p2~ translates to a single
*Charset* instruction with the union of both sets.

*Optimization 2*: If the first alternative succeeds, associating left for *n* alternatives
would require traversing *n* choices plus *n* commits, whereas associating right would
require traversing only one choice-commit pair.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") + lpeg.P("b")

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L1, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L2, i, e, c)
  -- L1: Char "b"     (p+1, i+1, e, c)
  -- L2: ...

  -- === LPEG ===
  (lpeg.P("a") + lpeg.P("b")) + lpeg.P("c")

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L1, i, c):e, c)
  --     Choice L2    (p+1, i, (p+L2, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L3    (p, i, h:e, c) -> (p+L3, i, e, c)
  -- L2: Char "b"     (p+1, i+1, e, c)
  -- L3: Commit L4    (p, i, h:e, c) -> (p+L4, i, e, c)
  -- L1: Char "c"     (p+1, i+1, e, c)
  -- L4: ...

  -- === LPEG (optimization) ===
  lpeg.P("a") + (lpeg.P("b") + lpeg.P("c"))

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L1, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L2, i, e, c)
  -- L1: Choice L3    (p+1, i, (p+L3, i, c):e, c)
  --     Char "b"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L2, i, e, c)
  -- L3: Char "c"     (p+1, i+1, e, c)
  -- L2: ...
#+end_src

*** Repetition

The ~Choice~ and ~PartialCommit~ instructions together create a loop where only the subject
position and the capture list are repeatedly updated. Instead of ~Choice~ repeatedly adding
and removing whole entries on the stack, ~PartialCommit~ simply updates the top entry.
~Choice~ need execute only once.

Repeated character classes have a dedicated instruction, ~Span charset~ that consumes a maximum
span of input characters that belong to the given character set.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") ^ 0

  -- === Virtual Machine ===
  -- L1: Choice L2    (p+1, i, (p+L2, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L1    (p, i, h:e, c) -> (p+L1, i, e, c)
  -- L2: ...

  -- === Virtual Machine (optimization) ===
  --     Choice L2           (p+1, i, (p+L2, i, c):e, c)
  -- L1: Char "a"            (p+1, i+1, e, c)
  --     PartialCommit L1    (p₂, i₂, (p₁, i₁, c₁):e, c₂) -> (p₂+L1, i₂, (p₁, i₂, c₂):e, c₂)
  -- L2: ...
#+end_src

*** Not Predicate

If the first pattern to ~Choice~ succeeds, the subsequent instruction, ~FailTwice~, discards the top
entry of the stack — the entry pushed by the most recent ~Choice~ instruction — and then fails
similarly to the ~Fail~ instruction.

The difference operator for two patterns, ~p1 - p2~, is usually encoded according to ~-p2 * p1~.
In the case where ~p1~ and ~p2~ are characters sets, they are encoded as a single ~Charset X~
instruction that is the set difference between the two patterns.

#+begin_src lua
  -- === LPEG ===
  -lpeg.P("a")

  -- === Virtual Machine ===
  --     Choice L2    (p+1, i, (p+L2, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L1    (p, i, h:e, c) -> (p+L1, i, e, c)
  -- L1: Fail
  -- L2: ...

  -- === Virtual Machine (optimization) ===
  --     Choice L1    (p+1, i, (p+L1, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     FailTwice    (p, i, h:e, c) -> (Fail, i, e, c)
  -- L1: ...
#+end_src

*** And Predicate

If first pattern to ~Choice~ succeeds, the ~BackCommit~ instruction backtracks to the initial subject
position and jumps to the end of the instruction set. If the first pattern fails, control goes to ~L1~
wherein the whole instruction set fails.

#+begin_src lua
  -- === LPEG ===
  #lpeg.P("a")

  -- === Virtual Machine (double negation)
  --     Choice L1
  --     Choice L2
  --     Char "a"
  --     FailTwice
  -- L2: FailTwice
  -- L1: ...

  -- === Virtual Machine (dedicated instruction) ===
  --     Choice L1
  --     Choice L2
  --     Char "a"
  -- L2: Commit L3
  -- L3: Fail
  -- L1: ...

  -- === Virtual Machine (optimization) ===
  --     Choice L1        (p+1, i, (p+L1, i, c):e, c)
  --     Char "a"         (p+1, i+1, e, c)
  --     BackCommit L2    (p₂, i₂, (p₁, i₁, c₁):e, c₂) -> (p₂+L2, i₁, e, c₁)
  -- L1: Fail
  -- L2: ...
#+end_src

*** Calling Grammars

Each non-terminal translates to a ~Call~ opcode, and each rule ends with a ~Return~ opcode.
At its creation, a non-terminal is not yet part of a grammar, so *LPEG* inserts the placeholder
instruction ~OpenCall~. Then, when the grammar is complete, *LPEG* combines the rules, ending
each with a ~Return~ instruction and translating each ~OpenCall~ to a ~Call~ instruction
with the appropriate offset to the enclosing grammar.

Grammars, like patterns, contain a single *End* instruction. This allows grammars to be composed
with other patterns, including other grammars.

#+begin_src lua
  -- === LPEG ===

  Pattern  = lpeg.P
  Var      = lpeg.V
  Set      = lpeg.S

  Grammar = Pattern {
        "S",                            -- start symbol
        S = Var("B") + (1 - Set("()")), -- S <- B / [^()]
        B = "(" * Var("S") * ")"        -- B <- "(" S ")"
  }

  -- === Virtual Machine ===
  --
  --     Call S           (p+S, i, (p+1):e, c
  --     Jump L1          (p+L1, i, e, c)
  --
  --  S: Choice L2        (p+1, i, (p+L2, i, c):e, c)
  --     Call B           (p+B, i, (p+1):e, c)
  --     Commit L3        (p, i, h:e, c) -> (p+L3, i, e, c)
  -- L2: Charset [^()]    (p+1, i+1, e, c)
  -- L3: Return           (p₂, i, p₁:e, c) -> (p₁, i, e, c)
  --
  --  B: Char '('         (p+1, i+1, e, c)
  --     Call S           (p+S, i, (p+1):e, c
  --     Char ')'         (p+1, i+1, e, c)
  --     Return           (p₂, i, p₁:e, c) -> (p₁, i, e, c)
  --
  -- L1: End
#+end_src

*** Tail Call Optimization

An ~OpenCall~ followed by a ~Return~ instruction is translated to a ~Jump~ instruction
— otherwise known as a tail call.

#+begin_src lua
  -- === LPEG ===

  grammar = re.compile[[ X <- "abc" / . X ]]

  -- === Virtual Machine ===
  --
  --     Call X                  (p+X, i, (p+1):e, c)
  --     Jump L1                 (p+L1, i, e, c)
  --  X: Choice L2               (p+1, i, (p+L2, i, c):e, c)
  --     Char "a"                (p+1, i+1, e, c)
  --     Char "b'                (p+1, i+1, e, c)
  --     Char "c"                (p+1, i+1, e, c)
  --     Commit L3               (p, i, h:e, c) -> (p+L3, i, e, c)
  -- L2: Any 1                   (p+1, i+n, e, c)
  --     Jump X <- Tail Call     (p+X, i, e, c)
  -- L3: Return                  (p₂, i, p₁:e, c) -> (p₁, i, e, c)
  -- L1: End
#+end_src

*** Head Fail Optimizations

#+begin_quote
  "A head fail occurs when a pattern fails at its very first check. Without optimizations,
   a head fail is somewhat costly. Typically, it involves a *Choice* operator followed by a
   failing check operator (*Char* or *Charset*). Both operations are expensive, when compared
   with other operations: the choice must save the entire machine’s state, and the failing
   check must restore that state."

   — Roberto Ierusalimschy
#+end_quote

| current state | instruction                        | next state                   |
|---------------+------------------------------------+------------------------------|
| (p, i, e, c)  | TestChar x L, S[i] = x             | (p+1, i+1, e, c)             |
| (p, i, e, c)  | TestChar x L, S[i] ≠ x             | (p+L, i, e, c)               |
| (p, i, e, c)  | TestCharset X L, S[i] ∈ X          | (p+1, i+1, e, c)             |
| (p, i, e, c)  | TestCharset X L, S[i] ∉ X          | (p+L, i, e, c)               |
| (p, i, e, c)  | TestAny n L, i+n ≤ \vert{}S\vert{} | (p+1, i+1, e, c)             |
| (p, i, e, c)  | TestAny n L, i+n > \vert{}S\vert{} | (p+L, i, e, c)               |

#+begin_src lua
  -- === LPEG ===

  grammar = re.compile[[ X <- "abc" / . X ]]

  -- === Virtual Machine ===
  --
  --     Call X
  --     Jump L1
  --  X: Choice L2 <- Expensive storing and restoring of state
  --     Char "a"  <- for a repeatedly-failing pattern
  --     Char "b'
  --     Char "c"
  --     Commit L3
  -- L2: Any 1
  --     Jump X
  -- L3: Return
  -- L1: End

  -- === Optimization ===
  --
  --     Call X            (p+X, i, (p+1):e, c)
  --     Jump L1           (p+L1, i, e, c)
  --  X: TestChar "a" L2   (p+1, i, e, c) or (p+L2, i, e, c)
  --     Choice L2         (p+1, i, (p+L2, i, c):e, c)
  --     Any 1             (p+1, i+1, e, c)
  --     Char "b"          (p+1, i+1, e, c)
  --     Char "c"          (p+1, i+1, e, c)
  --     Commit L3         (p, i, h:e, c) -> (p+L3, i, e, c)
  -- L2: Any 1             (p+1, i+n, e, c)
  --     Jump X            (p+X, i, e, c)
  -- L3: Return            (p₂, i, p₁:e, c) -> (p₁, i, e, c)
  -- L1: End
#+end_src

** Patterns to Programs: Formal Transformation

*Side Note*: Captures are excluded from these examples.

The transformation function *Π* operates on the domain *Grammar × N × Pattern*, where
*Π(g, i, p)* is the translation of pattern *p* in the context of grammar *g* with position
*i* relative to the beginning of the closed grammar that contains *p*.

*|Π(g, i, p)|* = the number of instructions in *(g, i, p)*.

*V* = the countably infinite set of variables or non-terminals: *A_{1}, A_{2}, ... A_{k}*.

*g(A_{k})* = the pattern associated with non-terminal *A_{k}* of grammar *g*.

*(g, A_{k})* = a closed grammar, where all variables of *g(A_{k})* are resolved in *g*.

#+begin_example
  === Character Match ===
  Π(g, i, 'c') ≡ Char c

  === Concatenation ===
  Π(g, i, p₁p₂) ≡ Π(g, i, p₁) Π(g, i + |Π(g, x, p₁)|, p₂)

  === Ordered Choice ===
  Π(g, i, p₁/p₂) ≡ Choice |Π(g, x, p₁)| + 2
                   Π(g, i + 1, p₁)
                   Commit |Π(g, x, p₂)| + 1
                   Π(g, i + |Π(g, x, p₁)| + 1, p₂)

  === Not Predicate ===
  Π(g, i, !p) ≡ Choice |Π(g, x, p)| + 2
                Π(g, i + 1, p)
                FailTwice

  === Repetition ===
  Π(g, i, p*) ≡ Choice |Π(g, x, p)| + 2
                Π(g, i + 1, p)
                PartialCommit − |Π(g, x, p)|

  === Variables ===
  Π(g, i, Ak) ≡ Call o(g, Ak) − i

  === Closed Grammars ===
  Π(g', i, (g, Ak)) ≡ Call o(g, Ak)
                      Jump |Π'(g, x)| + 1
                      Π'(g, 2) <--------- Keeps the invariant that all positions are relative
                                          to the first rule of the closed grammar.

  where Π'(g, i) = Π(g, i, g(A1))
                   Return
                   ...
                           k-1
                   Π(g, i + Σ |Π(g, x, Aj)| + 1, g(Ak))
                           j=1
                   Return
                   ...
                           n-1
                   Π(g, i + Σ |Π(g, x, Aj)| + 1, g(An))
                           j=1
                   Return

  === Offset Function ===

                      k-1
  o: Grammar × V → N = Σ (|Π(g, x, Aj)| + 1)
                      j=1       ^         ^ The size of the "Return" instruction.
                                |
                                  Position relative to "i" of the first rule.
#+end_example

** Extended Examples

Examples as they are actually output in the ~lpeg~ debugger.

*** String to Number

#+begin_src lua
  -- === LPEG ===

  number = re.compile([[
      Real       <- (Integer Fractional Exponent) -> convert !.
      Integer    <- Sign Whole
      Whole      <- "0" / ([1-9] [0-9]*)
      Fractional <- ("." [0-9]+)?
      Exponent   <- ([eE] Sign [0-9]+)?
      Sign       <- ("+" / "-")?
  ]], { convert = tonumber })

  -- === Match ===

  n = number:match("-1.2e3") + 1 --> -1199

  -- === AST ===
  --
  -- [
  --   1 = Integer  2 = Fractional  3 = Exponent  4 = function
  --   5 = Sign     6 = Whole       7 = Sign      8 = Real
  -- ]
  --
  -- grammar 6
  --   rule key: 8 -- Real: body
  --     xinfo n: 0
  --       sequence
  --         capture kind: 'function'  key: 4 -- convert
  --           sequence
  --              call key: 1  (rule: 2) -- Integer: call
  --              sequence
  --               call key: 2  (rule: 3) -- Fractional: call
  --               call key: 3  (rule: 4) -- Exponent: call
  --         not
  --           any
  --   rule key: 7 -- Sign: body
  --     xinfo n: 1
  --       choice
  --         set(05-1) [(2b)(2d)]
  --         true
  --   rule key: 1 -- Integer: body
  --     xinfo n: 2
  --       sequence
  --         call key: 5  (rule: 1) -- Sign: call
  --         call key: 6  (rule: 5) -- Whole: call
  --   rule key: 2 -- Fractional
  --     xinfo n: 3
  --       choice
  --         sequence
  --           char '.'
  --           sequence
  --             set(06-2) [(30-39)]
  --             repeat
  --               set(06-2) [(30-39)]
  --         true
  --   rule key: 3 -- Exponent: body
  --     xinfo n: 4
  --       choice
  --         sequence
  --           set(08-5) [(45)(65)]
  --           sequence
  --             call key: 7  (rule: 1) -- Sign: call
  --             sequence
  --               set(06-2) [(30-39)]
  --               repeat
  --                 set(06-2) [(30-39)]
  --         true
  --   rule key: 6 -- Whole: body
  --     xinfo n: 5
  --       choice
  --         char '0'
  --         sequence
  --           set(06-2) [(31-39)]
  --           repeat
  --             set(06-2) [(30-39)]

  -- === VM Instructions ===
  --
  -- 00: call -> 4 -- Real: call
  -- 02: end
  -- 03: --
  -- 04: opencapture function (idx = 4) -- Real: body
  -- 05: call -> 21 -- Integer: call
  -- 07: call -> 26 -- Exponent: call
  -- 09: call -> 38 -- Fractional: call
  -- 11: closecapture
  -- 12: testany -> 15
  -- 14: fail
  -- 15: return
  -- 16: testset (28-1) [(2b)(2d)]-> 20 -- Sign: body
  -- 19: any
  -- 20: return
  -- 21: call -> 16 -- Integer: body, Sign: call
  -- 23: jump -> 54
  -- 25: return
  -- 26: testchar '.' (2e)-> 37 -- Exponent: body
  -- 28: choice -> 37
  -- 30: any
  -- 31: set (30-1) [(30-39)]
  -- 33: span (30-1) [(30-39)]
  -- 35: commit -> 37
  -- 37: return
  -- 38: testset (40-2) [(45)(65)]-> 53 -- Fractional: body
  -- 42: choice -> 53
  -- 44: any
  -- 45: call -> 16 -- Sign: call
  -- 47: set (30-1) [(30-39)]
  -- 49: span (30-1) [(30-39)]
  -- 51: commit -> 53
  -- 53: return
  -- 54: testchar '0' (30)-> 59 -- Whole: body
  -- 56: any
  -- 57: return
  -- 58: --
  -- 59: set (30-1) [(31-39)]
  -- 61: span (30-1) [(30-39)]
  -- 63: return
  -- 64: end
#+end_src

*** Add Numbers List

#+begin_src lua
  -- === LPEG ===

  Set   = lpeg.S
  Range = lpeg.R

  spaces = Set(" \t\r\n") ^ 0
  trim   = function (x) return spaces * x * spaces end

  number = trim((Range("09") ^ 1) / tonumber)

  add = function (accum, value) return accum + value end

  sum = "[" * number * ("," * number % add) ^ 0 * "]"

  -- === Match ===

  total = sum:match("[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]") --> 55

  -- === AST ===
  --
  -- [1 = function  2 = function  3 = function]
  --
  -- sequence
  --   sequence
  --     sequence
  --       char '['
  --       sequence
  --         sequence
  --           repeat
  --             set(01-4) [(09-0a)(0d)(20)]
  --           capture kind: 'function'  key: 1 --> tonumber
  --             sequence
  --               set(06-2) [(30-39)]
  --               repeat
  --                 set(06-2) [(30-39)]
  --         repeat
  --           set(01-4) [(09-0a)(0d)(20)]
  --     repeat
  --       capture kind: 'accumulator'  key: 3 --> accumulator add
  --         sequence
  --           char ','
  --           sequence
  --             sequence
  --               repeat
  --                 set(01-4) [(09-0a)(0d)(20)]
  --               capture kind: 'function'  key: 2 --> tonumber
  --                 sequence
  --                   set(06-2) [(30-39)]
  --                   repeat
  --                     set(06-2) [(30-39)]
  --             repeat
  --               set(01-4) [(09-0a)(0d)(20)]
  --   char ']'

  -- === VM Instructions ===
  --
  -- 00: char '[' (5b)
  -- 01: span (08-1) [(09-0a)(0d)(20)]
  -- 03: opencapture function (idx = 1) --> tonumber
  -- 04: set (30-1) [(30-39)]
  -- 06: span (30-1) [(30-39)]
  -- 08: closecapture
  -- 09: span (08-1) [(09-0a)(0d)(20)]
  -- 11: testchar ',' (2c)-> 28
  -- 13: opencapture accumulator (idx = 3) --> accumulator add
  -- 14: any
  -- 15: span (08-1) [(09-0a)(0d)(20)]
  -- 17: opencapture function (idx = 2) --> tonumber
  -- 18: set (30-1) [(30-39)]
  -- 20: span (30-1) [(30-39)]
  -- 22: closecapture
  -- 23: span (08-1) [(09-0a)(0d)(20)]
  -- 25: closecapture
  -- 26: jmp -> 11
  -- 28: char ']' (5d)
  -- 29: end
#+end_src

*** C Comment Block

#+begin_src lua
  -- === LPEG ===

  Pattern = lpeg.P
  Any     = lpeg.P(1)

  open  = Pattern("/*")
  close = Pattern("*/")

  -- comment_block = re.compile[[ "/*" (!"*/" .)* "*/" ]]
  comment_block = open * (Any - close) ^ 0 * close

  -- === AST ===
  --
  -- sequence
  --   sequence
  --     sequence
  --       char '/'
  --       char '*'
  --     repeat
  --       sequence
  --         not
  --           sequence
  --             char '*'
  --             char '/'
  --         any
  --    sequence
  --      char '*'
  --      char '/'

  -- === VM Instructions ===
  --
  -- 00: char '/' (2f)
  -- 01: char '*' (2a)
  -- 02: testany -> 16
  -- 04: choice -> 16
  -- 06: testchar '*' (2a) -> 13
  -- 08: choice -> 13
  -- 10: char '*' (2a)
  -- 11: char '/' (2f)
  -- 12: failtwice
  -- 13: any
  -- 14: partial_commit -> 6
  -- 16: char '*' (2a)
  -- 17: char '/' (2f)
  -- 18: end
#+end_src

** Virtual Machine Internals

Samples of C source code from LPEG's ~match~ function, a function that runs
the opcode interpreter — otherwise known as the virtual machine.

*Side Note:* Some of the actual opcode instructions are subtly different from the examples
explicated by Ierusalimschy in his paper *A Text Pattern-Matching Tool Based on Parsing Expression Grammars*.
I have, to the best of my knowledge, updated my notes accordingly.

*** Match Function

#+begin_src c
  // The main match function for all LPEG patterns.
  static int lp_match (lua_State *L) {
    // Initialize capture list.
    Capture capture[INITCAPSIZE];
    const char *r;
    size_t l;
    // Build and/or retrieve pattern from userdata.
    Pattern *p = (getpatt(L, 1, NULL), getpattern(L, 1));
    // Compile tree into instruction list, if not already compiled.
    Instruction *code = (p->code != NULL) ? p->code : prepcompile(L, p, 1);
    // Retrieve input text.
    const char *s = luaL_checklstring(L, SUBJIDX, &l);
    // Locate initial position in input.
    size_t i = initposition(L, l);
    int ptop = lua_gettop(L);
    luaL_argcheck(L, l < MAXINDT, SUBJIDX, "subject too long");
    // Initialize subcache.
    lua_pushnil(L);
    // Push pointer to capture list.
    lua_pushlightuserdata(L, capture);
    // Retrieve key table.
    lua_getuservalue(L, 1);
    // Run the virtual machine.
    r = match(L, s, s + i, s + l, code, capture, ptop);
    if (r == NULL) {
      lua_pushnil(L);
      return 1;
    }
    // Pull the captures out of the capture list.
    return getcaptures(L, s, r, ptop);
  }

  int getcaptures (lua_State *L, const char *s, const char *r, int ptop) {
    // Retrieve the capture list.
    Capture *capture = (Capture *)lua_touserdata(L, caplistidx(ptop));
    int n = 0;
    // Are there any captures?
    if (!isclosecap(capture)) {
      CapState cs;
      cs.ocap = cs.cap = capture;
      cs.L = L;
      cs.reclevel = 0;
      cs.s = s;
      cs.valuecached = 0;
      cs.ptop = ptop;
      cs.firstcap = lua_gettop(L) + 1;
      // Collect and process captures, pushing results
      // onto the stack.
      do {
        n += pushcapture(&cs);
      } while (!isclosecap(cs.cap));
      assert(lua_gettop(L) - cs.firstcap == n - 1);
    }
    // Are there any capture values?
    if (n == 0) {
      // Return end position in match.
      lua_pushinteger(L, r - s + 1);
      n = 1;
    }
    return n;
  }

  // The state machine for collecting match captures.
  typedef struct CapState {
    Capture *cap;    // The current capture.
    Capture *ocap;   // The original capture list.
    lua_State *L;
    int ptop;        // Stack index of last match.
    int firstcap;    // Stack index of first capture.
    const char *s;   // Input text.
    int valuecached; // Value stored in cache.
    int reclevel;    // Recursion level.
  } CapState;
#+end_src

*** VM Interpreter

#+begin_src c
  // Bytecode instruction as defined in "lpvm.h".
  typedef union Instruction {
    struct Inst {
      byte code;
      byte aux1;
      union {
        short key;
        struct {
          byte offset;
          byte size;
        } set;
      } aux2;
    } i;
    int offset;
    uint codesize;
    byte buff[1];
  } Instruction;

  // Entry stack as defined in "lpvm.c".
  // Side Note: "stack" points to first empty slot in "Stack".
  typedef struct Stack {
    const char *s;        // Saved position (NULL for calls)
    const Instruction *p; // Next instruction
    int caplevel;
  } Stack;

  // An unsigned integer large enough to index any subject in a captures array.
  // "size_t" would also work, but it would double the size of the captures array
  // on a 64-bit machine. "uint" is a macro for "unsigned int".
  typedef uint Index_t;

  // Captures array as defined in "lpcap.c".
  typedef struct Capture {
    Index_t index;       // Subject position
    unsigned short idx;  // Extra info (group name, argument index, etc.)
    byte kind;           // Kind of capture
    byte siz;            // Size of full capture + 1 (0 = not a full capture)
  } Capture;

  // The opcode interpreter as called in "lp_match":
  //     match(L, o, s,     e,     op,   capture, ptop)
  // r = match(L, s, s + i, s + l, code, capture, ptop);
  // where L       = lua_State
  //       s       = input string
  //       s + i   = input start
  //       s + l   = input end
  //       code    = instruction list
  //       capture = capture list
  //       ptop    = top index in Lua stack

  // Initialize entries list.
  Stack stackbase[INITBACK];
  Stack *stacklimit = stackbase + INITBACK;
  // Point to first empty slot in stack.
  Stack *stack = stackbase;

  int capsize = INITCAPSIZE;
  // Point to first empty slot in captures.
  int captop = 0;
  // Number of dynamic captures (in Lua stack)
  int ndyncap = 0;

  // Current instruction.
  const Instruction *p = op;

  // static const Instruction giveup = {{IGiveup, 0, {0}}};
  stack->p = &giveup;
  stack->s = s;
  stack->caplevel = 0;
  stack++;

  lua_pushlightuserdata(L, stackbase);

  // The following chunks of code are executed within a "for (;;) {...}" loop
  // and a "switch ((Opcode)p->i.code) {...}" statement.

  // Char x, S[i] = x [ (p, i, e, c) -> (p+1, i+1, e, c) ]
  // Char x, S[i] ≠ x [ (p, i, e, c) -> (Fail, i, e, c)  ]
  case IChar: {
    if ((byte)*s == p->i.aux1 && s < e) { p++; s++; }
    else { goto fail; }
    continue;
  }
  // TestChar x L, S[i] = x [ (p, i, e, c) -> (p+1, i, e, c) ]
  // TestChar x L, S[i] ≠ x [ (p, i, e, c) -> (p+L, i, e, c) ]
  case ITestChar: {
    if ((byte)*s == p->i.aux1 && s < e) { p += 2; }
    else { p += getoffset(p); }
    continue;
  }
  // Jump L [ (p, i, e, c) -> (p+L, i, e, c) ]
  case IJmp: {
    p += getoffset(p);
    continue;
  }
  // Choice L [ (p, i, e, c) -> (p+1, i, (p+L, i, c):e, c) ]
  case IChoice: {
    if (stack == stacklimit) {
      stack = doublestack(L, &stacklimit, ptop);
    }
    stack->p = p + getoffset(p);
    stack->s = s;
    stack->caplevel = captop;
    stack++;
    p += 2;
    continue;
  }
  // Call L [ (p, i, e, c) -> (p+L, i, (p+1):e, c) ]
  case ICall: {
    if (stack == stacklimit) {
      stack = doublestack(L, &stacklimit, ptop);
    }
    stack->s = NULL;
    // Save return address.
    stack->p = p + 2;
    stack++;
    p += getoffset(p);
    continue;
  }
  // Return [ (p₂, i, p₁:e, c) -> (p₁, i, e, c) ]
  case IRet: {
    assert(stack > getstackbase(L, ptop) && (stack - 1)->s == NULL);
    p = (--stack)->p;
    continue;
  }
  // Commit L [ (p, i, h:e, c) -> (p+L, i, e, c) ]
  case ICommit: {
    assert(stack > getstackbase(L, ptop) && (stack - 1)->s != NULL);
    stack--;
    p += getoffset(p);
    continue;
  }
  // Capture (i, p) [ (p, i, e, c) -> (p+1, i, e, (i, p):c) ]
  case ICloseCapture: {
    Capture *open = findopen(capture + captop, s - o);
    assert(captop > 0);
    // If possible, turn capture into a full capture.
    if (open) {
      open->siz = (s - o) - open->index + 1;
      p++;
      continue;
    }
    // Must create a close capture.
    else {
      // Mark entry as closed.
      capture[captop].siz = 1;
      capture[captop].index = s - o;
      goto pushcapture;
    }
  }
  case IOpenCapture: {
    // Mark entry as open.
    capture[captop].siz = 0;
    capture[captop].index = s - o;
    goto pushcapture;
  }
  case IFullCapture: {
    // Save capture size.
    capture[captop].siz = getoff(p) + 1;
    capture[captop].index = s - o - getoff(p);
  }
  pushcapture: {
    capture[captop].idx = p->i.aux2.key;
    capture[captop].kind = getkind(p);
    captop++;
    capture = growcap(L, capture, &capsize, captop, 0, ptop);
    p++;
    continue;
  }
  // FailTwice [ (p, i, h:e, c) -> (Fail, i, e, c) ]
  case IFailTwice: {
    assert(stack > getstackbase(L, ptop));
    stack--;
  }
  // FALLTHROUGH
  // Fail [ (Fail, i, p:e, c)             -> (Fail, i, e, c) ]
  //      [ (Fail, i₂, (p, i₁, c₁):e, c₂) -> (p, i₁, e, c₁)  ]
  case IFail:
  // Pattern failed. Try to backtrack.
  fail: {
    // Remove pending calls.
    do {
      assert(stack > getstackbase(L, ptop));
      s = (--stack)->s;
    } while (s == NULL);
    // Are there matchtime captures?
    if (ndyncap > 0) {
      ndyncap -= removedyncap(L, capture, stack->caplevel, captop);
    }
    captop = stack->caplevel;
    p = stack->p;
    continue;
  }
  // End
  case IEnd: {
    assert(stack == getstackbase(L, ptop) + 1);
    capture[captop].kind = Cclose;
    capture[captop].index = MAXINDT;
    return s;
  }
#+end_src

*** Extra VM Instructions

#+begin_src c
  // Charset X, S[i] ∈ X [ (p, i, e, c) -> (p+1, i+1, e, c) ]
  // Charset X, S[i] ∉ X [ (p, i, e, c) -> (Fail, i, e, c)  ]
  case ISet: {
    uint c = (byte)*s;
    if (charinset(p, (p+1)->buff, c) && s < e)
      { p += 1 + p->i.aux2.set.size; s++; }
    else goto fail;
    continue;
  }
  // TestCharset X L, S[i] ∈ X [ (p, i, e, c) -> (p+1, i, e, c) ]
  // TestCharset X L, S[i] ∉ X [ (p, i, e, c) -> (p+L, i, e, c) ]
  case ITestSet: {
    uint c = (byte)*s;
    if (charinset(p, (p + 2)->buff, c) && s < e) {
      p += 2 + p->i.aux2.set.size;
    }
    else { p += getoffset(p); }
    continue;
  }
  // Any, i + 1 ≤ |S| [ (p, i, e, c) -> (p+1, i+1, e, c) ]
  // Any, i + 1 > |S| [ (p, i, e, c) -> (Fail, i, e, c)  ]
  case IAny: {
    if (s < e) { p++; s++; }
    else goto fail;
    continue;
  }
  // TestAny n L, i+n ≤ |S| [ (p, i, e, c) -> (p+1, i, e, c)  ]
  // TestAny n L, i+n > |S| [ (p, i, e, c) -> (Fail, i, e, c) ]
  case ITestAny: {
    if (s < e) { p += 2; }
    else { p += getoffset(p); }
    continue;
  }
  // PartialCommit L [ (p₂, i₂, (p₁, i₁, c₁):e, c₂) -> (p₂+L, i₂, (p₁, i₂, c₂):e, c₂) ]
  case IPartialCommit: {
    assert(stack > getstackbase(L, ptop) && (stack - 1)->s != NULL);
    (stack - 1)->s = s;
    (stack - 1)->caplevel = captop;
    p += getoffset(p);
    continue;
  }
  // Span X, S[i] ∈ X [ (p, i, e, c) -> (p, i+1, e, c) ]
  // Span X, S[i] ∉ X [ (p, i, e, c) -> (p+1, i, e, c) ]
  case ISpan: {
    for (; s < e; s++) {
      uint c = (byte)*s;
      if (!charinset(p, (p+1)->buff, c)) { break; }
    }
    p += 1 + p->i.aux2.set.size;
    continue;
  }
  // BackCommit L [ (p₂, i₂, (p₁, i₁, c₁):e, c₂) -> (p₂+L, i₁, e, c₁) ]
  case IBackCommit: {
    assert(stack > getstackbase(L, ptop) && (stack - 1)->s != NULL);
    s = (--stack)->s;
    // Matchtime captures?
    if (ndyncap > 0) {
      ndyncap -= removedyncap(L, capture, stack->caplevel, captop);
    }
    captop = stack->caplevel;
    p += getoffset(p);
    continue;
  }
#+end_src
