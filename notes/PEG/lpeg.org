* LPEG Parsing Machine

** Sources

| source                                                              | author                |
|---------------------------------------------------------------------+-----------------------|
| *A Text Pattern-Matching Tool Based on Parsing Expression Grammars* | Roberto Ierusalimschy |
| *Parsing Expression Grammars for Lua*                               | Roberto Ierusalimschy |

** Introduction

#+begin_quote
  "PEGs present several similarities with parsing combinators. Both use ordered choice
   and have an interface based on the acceptance of input prefixes. Moreover, both share
   the restrictions common to all top-down parsers, such as no support for left recursion.

   Typically, parsing combinators work either deterministically, by using the first result
   from a parsing function, or with full backtracking."

  — Roberto Ierusalimschy
#+end_quote

*** Basic Operations

| operation             | description                                                   |
|-----------------------+---------------------------------------------------------------|
| ~lpeg.P(string)~      | Matches literal string                                        |
| ~lpeg.P(n)~           | Matches ~n~ characters                                        |
| ~lpeg.S(string)~      | Matches any character in string (Set)                         |
| ~lpeg.R("xy")~        | Matches any character between ~x~ and ~y~ (Range)             |
| ~lpeg.utfR(cp1, cp2)~ | Matches UTF-8 code point between ~cp1~ and ~cp2~              |
| ~pattern ^ n~         | Matches at least ~n~ repetitions of ~pattern~                 |
| ~pattern ^ -n~        | Matches at most ~n~ repetitions of ~pattern~                  |
| ~p1 * p2~             | Matches ~p1~ followed by ~p2~                                 |
| ~p1 + p2~             | Matches ~p1~ or ~p2~ (ordered choice)                         |
| ~p1 - p2~             | Matches ~p1~ if ~p2~ does not match                           |
| ~-pattern~            | Equivalent to ~("" - pattern)~                                |
| ~#pattern~            | Matches ~pattern~ but consumes no input                       |
| ~lpeg.B(pattern)~     | Matches only if the current position is preceded by ~pattern~ |

*** Captures

A capture is a pattern that produces values — the semantic information — according
to what it matches.

| operation                     | result                                         |
|-------------------------------+------------------------------------------------|
| ~lpeg.C(pattern)~             | Match for ~pattern~ plus all its captures      |
| ~lpeg.Carg(n)~                | nth extra argument to ~lpeg.match~             |
| ~lpeg.Cb(key)~                | Previous group capture                         |
| ~lpeg.Cc(values)~             | Constant capture  of the given values          |
| ~lpeg.Cg(pattern [, key])~    | Group capture, optionally named by ~key~       |
| ~lpeg.Cp()~                   | Position capture                               |
| ~lpeg.Cs(pattern)~            | Substitution capture                           |
| ~lpeg.Ct(pattern)~            | Table capture                                  |
| ~pattern / string~            | String capture                                 |
| ~pattern / number~            | Numbered capture                               |
| ~pattern / table~             | ~table[c]~, where ~c~ is the ~pattern~ capture |
| ~pattern / function~          | Maps ~function~ over ~pattern~ captures        |
| ~pattern % function~          | Accumulates ~pattern~ captures with ~function~ |
| ~lpeg.Cmt(pattern, function)~ | Maps ~function~ over match-time captures       |

** Parsing Examples

*** Adding Numbers

#+begin_src lua
  lpeg = require("lpeg")

  -- Matches a numeral and captures its numerical value.
  number = lpeg.R("09")^1 / tonumber

  -- Auxiliary function to add two numbers.
  function add(accum, value) return accum + value end

  -- Matches a list of numbers, adding their values.
  sum = number * ("," * number % add)^0

  sum:match("1, 2, 3, 4, 5, 6, 7, 8, 9, 10") --> 55
#+end_src

*** Split Function

#+begin_src lua
  lpeg = require("lpeg")

  function split(text, separator)
    separator = lpeg.P(separator)
    local element = lpeg.C((1 - separator)^0)
    -- Make table capture.
    local pattern = lpeg.Ct(element * (separator * element)^0)
    return lpeg.match(pattern, text)
  end
#+end_src

*** Arithmetic Evaluator

#+begin_src lua
  lpeg = require("lpeg")

  -- Lexical elements
  Spaces = lpeg.S(" \n\t")^0
  Number = lpeg.C(lpeg.P("-"^-1) * lpeg.R("09")^1) * Spaces
  AddSub = lpeg.C(lpeg.S("+-")) * Spaces
  MulDiv = lpeg.C(lpeg.S("*/")) * Spaces
  Open   = "(" * Spaces
  Close  = ")" * Spaces

  -- Evaluator
  function eval(v1, op, v2)
    if (op == "+") then return v1 + v2
    elseif (op == "-") then return v1 - v2
    elseif (op == "*") then return v1 * v2
    elseif (op == "/") then return v1 / v2
    end
  end

  -- Grammar
  Var = lpeg.V
  Grammar = lpeg.P{
    "Expression",
    Expression = Var("Term") * (AddSub * Var("Term") % eval)^0;
    Term = Var("Factor") * (MulDiv * Var("Factor") % eval)^0;
    Factor = Number / tonumber + Open * Var("Expression") * Close;
  }

  lpeg.Match(Grammar, "3 + 5 * 9 / (1 + 1) - 11") --> 14.5
#+end_src

** PEG and LPEG

#+begin_quote
  "Unlike other PEG implementations, which aim at parsing, LPEG aims at pattern matching.
   Therefore, it turns PEG inside out: while PEGs define grammars using pattern expressions
   as an auxiliary construction, in LPEG the main construction is the pattern and grammars
   are only a particular way to create patterns."

   — Roberto Ierusalimschy
#+end_quote

1. Emphasizes expressions over grammars

2. Unifies the concepts of captures, semantic actions, and substitutions.

3. Novel parsing machine.

*** Notational Differences

| peg      | lpeg           |
|----------+----------------|
| &pattern | ~#pattern~     |
| !pattern | ~-pattern~     |
| p1 / p2  | ~p1 + p2~      |
| pattern* | ~pattern ^ 0~  |
| pattern+ | ~pattern ^ 1~  |
| pattern? | ~pattern ^ -1~ |

*** Grammatical Differences

#+begin_example
  # === PEG ===

  grammar      <- (non-terminal "<-" spaces pattern)+

  pattern      <- alternative ("/" spaces alternative)*

  alternative  <- ([!&]? spaces suffix)+

  suffix       <- primary ([*+?] space)*

  primary      <- "(" spaces pattern ")" spaces
                  / "." spaces
                  / literal
                  / char-class
                  / non-terminal !"<-"

  literal      <- ["] (!["] .)* ["] spaces

  char-class   <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal <- [a-zA-Z]+ spaces

  spaces       <- [ \t\n]*

  # === LPEG ===

  # LPEG = [a-z]+ or S <- [a-z]+
  #        ^----^    ^---------^
  #        pattern   grammar
  #
  # PEG  = S <- [a-z]+

 >
| pattern        <- grammar / simple-pattern
|
| grammar        <- (non-terminal "<-" spaces simple-pattern)+
|
| simple-pattern <- alternative ("/" spaces alternative)*
 >
  alternative    <- ([!&]? spaces suffix)+

  suffix         <- primary ([*+?] space)*

  primary        <- "(" spaces pattern ")" spaces
                    / "." spaces
                    / literal
                    / char-class
                    / non-terminal !"<-"

  literal        <- ["] (!["] .)* ["] spaces

  char-class     <- "[" (!"]" (. "-" . / .))* "]" spaces

  non-terminal   <- [a-zA-Z]+ spaces

  spaces         <- [ \t\n]*
#+end_example

** Repetition

- blind greedy (possessive) :: Always matches the maximum possible span, disregarding what
  comes afterward.

- non-blind greedy :: Repeats as many times as possible so long as the rest of the pattern
  matches.

- blind non-greedy :: Always matches *ε*. Not useful.

- non-blind non-greedy (lazy or reluctant) :: Match the minimum number of *E₁* up to the
  first *E₂*.

| Repetition           | PEG              |
|----------------------+------------------|
| blind greedy         | *S <- E S / ε*   |
| non-blind greedy     | *S <- E₁ S / E₂* |
| non-blind non-greedy | *S <- E₂ / E₁ S* |

** Finite Automata to PEG

Depending on the order of the terms in rule *A*, the grammar matches the longest or the
shortest subject's prefix ending with *ana*.

#+begin_example
  === NFA ===

  +-.->
   \ /
   [A]-a->[B]-n->[C]-a->(D)

  === PEG ===

  A <- . A / "a" B
  B <- "n" C
  C <- "a" D
  D <- ε
#+end_example

** The Parsing Machine

- State = (N ∪ Fail, N, StackEntry*, Capture*) :: The virtual machine keeps its state in
  four registers: (instruction, subject position, stack, capture list)

- N ∪ Fail (instruction) :: Keeps the index of the next instruction to be executed
  (a natural number). It may also have a special *Fail* value, meaning that some match
  failed and the machine must backtrack.

- N (subject position) :: keeps the current position in the subject (a natural number).

- StackEntry* (stack) :: A list of two kinds of entries: *N ∪ (N, N, Capture\star{})*.
  The first kind represents return addresses (a natural number). Each nonterminal
  translates to a call to its corresponding production. When that production finishes
  in success it must return to the point after the call, which will be at the top of
  the stack. The second kind of entry represents pending alternatives (backtrack entries).
  Whenever there is a choice, the machine follows the first option and pushes on the
  stack information on how to pursue the other option if the first one fails. Each such
  entry comprises the instruction to follow in case of failure plus all information needed
  to backtrack to the current state (that is, the subject position and the capture list).

- Capture* (capture list) :: Keeps information about captures made by the pattern: *(N, N)*.
  Each entry stores the subject position and the index of the instruction that created the
  entry, wherein there is extra information about the capture.

*** Basic Instructions

| current state                 | instruction      | next state                 |
|-------------------------------+------------------+----------------------------|
| (p, i, e, c)                  | Char x, S[i] = x | (p+1, i+1, e, c)           |
| (p, i, e, c)                  | Char x, S[i] ≠ x | (Fail, i, e, c)            |
| (p, i, e, c)                  | Jump L           | (p+L, i, e, c)             |
| (p, i, e, c)                  | Choice L         | (p+1, i, (p+L, i, c):e, c) |
| (p, i, e, c)                  | Call L           | (p+L, i, (p+1):e, c)       |
| (p₀, i, p₁:e, c)              | Return           | (p₁, i, e, c)              |
| (p, i, h:e, c)                | Commit L         | (p+L, i, e, c)             |
| (p, i, e, c)                  | Capture K        | (p+1, i, e, (i, p):c)      |
| (p, i, e, c)                  | Fail             | (Fail, i, e, c)            |
| (Fail, i, p:e, c)             | any              | (Fail, i, e, c)            |
| (Fail, i₀, (p, i₁, c₁):e, c₀) | any              | (p, i₁, e, c₁)             |

- Char char :: If the character in the current subject position is equal to *char*. the machine
  consumes the current character and moves to the next instruction.

- Fail :: Forces failure. First the machine pops any return addresses from the top of the stack.
  If the stack is empty, the machine halts and the whole pattern fails. Otherwise, the machine
  pops the top backtrack entry and assigns the saved values to their respective registers.

- Jump label :: Jumps to instruction *label*. All instructions that need a label express the label
  as an offset from the current instruction. Jump instructions organize grammars and implement
  proper tail calls.

- Choice label :: Pushes a backtrack entry onto the stack, saving the current machine state plus
  the given label as the alternative instruction.

- Call label :: Calls instruction *label* by saving the stack address of the next instruction
  and then jumping to instruction *label*. *Call* implements non-terminals.

- Return :: Returns from a *Call*, popping an address from the stack and jumping to it. Complete
  patterns leave no entries on the stack.

- Commit label :: Commits to a *Choice*. Discards the top entry from the stack and jumps to *label*.

- Capture extra-info :: Adds an entry to the capture list with the current subject position and
  instruction. If the complete pattern matches, a post-processor traverses the capture list and,
  using the pointers to the instructions that created each entry, builds the capture values.

- End :: The machine returns, signalling that the match succeeds.

*** Extra Instructions

| current state                | instruction                    | next state                   |
|------------------------------+--------------------------------+------------------------------|
| (p, i, e, c)                 | Charset X, S[i] ∈ X            | (p+1, i+1, e, c)             |
| (p, i, e, c)                 | Charset X, S[i] ∉ X            | (Fail, i, e, c)              |
| (p, i, e, c)                 | Any n, i + n ≤ \vert{}S\vert{} | (p+1, i+n, e, c)             |
| (p, i, e, c)                 | Any n, i + n > \vert{}S\vert{} | (Fail, i, e, c)              |
| (p₀, i₀, (p₁, i₁, c₁):e, c₀) | PartialCommit L                | (p₀+L, i₀, (p₁,i₀,c₀):e, c₀) |
| (p, i, e, c)                 | Span X, S[i] ∈ X               | (p, i+1, e, c)               |
| (p, i, e, c)                 | Span X, S[i] ∉ X               | (p+1, i, e, c)               |
| (p, i, h:e, c)               | FailTwice                      | (Fail, i, e, c)              |
| (p₀, i₀, (p₁, i₁, c₁):e, c₀) | BackCommit L                   | (p₀+L, i₁, e, c₁)            |

- Charset set :: Is the current character a member of the *set*. Sets are represented as bit sets,
  with one bit for each possible character value.

- Any n :: Checks whether there are at least *n* characters in the current subject position.

* Grammars to Instructions

** Literals

A literal string translates to a sequence of ~Char~ instructions, one for each character.
~lpeg.P(n)~ translates to ~Any n~. Both sets and ranges translate to ~Charset X~.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("ana")

  -- === Virtual Machine ===
  -- Char "a"    (p+1, i+1, e, c)
  -- Char "n"    (p+1, i+1, e, c)
  -- Char "a"    (p+1, i+1, e, c)
#+end_src

*** Concatenation

Sequences instructions.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") * lpeg.P("b") * lpeg.P("c")

  -- === Virtual Machine ===
  --  Char "a"    (p+1, i+1, e, c)
  --  Char "b"    (p+1, i+1, e, c)
  --  Char "c"    (p+1, i+1, e, c)
#+end_src

*** Ordered Choice

The machine saves the state and then runs *p1*. If *p1* successsful, executes *Commit L2*,
which removes the saved state from the stack and jumps to the end of the pattern, *L2*.
If *p1* fails, the machine backtracks to the initial saved state and jumps to *L1* and
tries *p2*. If *p2* fails then choice fails.

*Optimization 1*: If both *p1* and *p2* are character sets, *p1 + p2* translates to a single
*charset* instruction with the union of both sets.

*Optimization 2*: If the first alternative succeeds, associating left for *n* alternatives
would require *n* choices plus *n* commits, whereas associating right would require only one
choice-commit pair.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") + lpeg.P("b")

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L, i, e, c)
  -- L1: Char "b"     (p+1, i+1, e, c)
  -- L2: ...

  --- === LPEG ===
  (lpeg.P("a") + lpeg.P("b")) + lpeg.P("c")

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L, i, c):e, c)
  --     Choice L2    (p+1, i, (p+L, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L3    (p, i, h:e, c) -> (p+L, i, e, c)
  -- L2: Char "b"     (p+1, i+1, e, c)
  -- L3: Commit L4    (p, i, h:e, c) -> (p+L, i, e, c)
  -- L1: Char "c"     (p+1, i+1, e, c)
  -- L4: ...

  -- === LPEG (optimization) ===
  lpeg.P("a") + (lpeg.P("b") + lpeg.P("c"))

  -- === Virtual Machine ===
  --     Choice L1    (p+1, i, (p+L, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L, i, e, c)
  -- L1: Choice L3    (p+1, i, (p+L, i, c):e, c)
  --     Char "b"     (p+1, i+1, e, c)
  --     Commit L2    (p, i, h:e, c) -> (p+L, i, e, c)
  -- L3: Char "c"     (p+1, i+1, e, c)
  -- L2: ...
#+end_src

*** Repetition

The ~Choice~ and ~PartialCommit~ operations together create a loop where only the subject
position and the the capture list are repeatedly updated.

Repeated character classes have a dedicated instruction, ~Span charset~ that consumes a maximum
span of input characters that belong to the given character set.

#+begin_src lua
  -- === LPEG ===
  lpeg.P("a") ^ 0

  -- === Virtual Machine ===
  -- L1: Choice L2    (p+1, i, (p+L, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L1    (p, i, h:e, c) -> (p+L, i, e, c)
  -- L2: ...

  -- === Virtual Machine (optimization) ===
  --     Choice L2           (p+1, i, (p+L, i, c):e, c)
  -- L1: Char "a"            (p+1, i+1, e, c)
  --     PartialCommit L1    (p₀, i₀, (p₁, i₁, c₁):e, c₀) -> (p₀+L, i₀, (p₁,i₀,c₀):e, c₀)
  -- L2: ...
#+end_src

*** Predicates

The ~Choice~ and ~FailTwice~ operations together act like two consecutive fails, removing
the top entry from the stack and then failing.

The difference operator for two patterns, *p1 - p2*, is usually encoded according to *-p2 * p1*.
In the case where *p1* and *p2* are characters sets, they are encoded as a single *Charset X*
instruction that is the set difference between the two patterns.

#+begin_src lua
  -- === LPEG ===
  -lpeg.P("a")

  -- === Virtual Machine ===
  --     Choice L2    (p+1, i, (p+L, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     Commit L1    (p, i, h:e, c) -> (p+L, i, e, c)
  -- L1: Fail
  -- L2: ...

  -- === Virtual Machine (optimization) ===
  --     Choice L1    (p+1, i, (p+L, i, c):e, c)
  --     Char "a"     (p+1, i+1, e, c)
  --     FailTwice    (p, i, h:e, c) -> (Fail, i, e, c)
  -- L1: ...
#+end_src

*** Grammar Example

#+begin_src lua
  -- === LPEG ===

  lpeg = require("lpeg")

  Var = lpeg.V
  Set = lpeg.S

  Grammar = lpeg.P{
        "S",                            -- start symbol
        S = Var("B") + (1 - Set("()")), -- S <- <B> / [^()]
        B = '(' * Var("S") * ')'        -- B <- '(' <S> ')'
  }

  -- === Virtual Machine ===
  --
  --     Call S           (p+S, i, (p+1):e, c
  --     Jump L2          (p+L, i, e, c)
  --
  --  S: Choice L4        (p+1, i, (p+L, i, c):e, c)
  --     Call B           (p+B, i, (p+1):e, c
  --     Commit L5        (p, i, h:e, c) -> (p+L, i, e, c)
  -- L4: Charset [^()]    (p+1, i+1, e, c)
  -- L5: Return           (p₀, i, p₁:e, c) -> (p₁, i, e, c)
  --
  --  B: Char '('         (p+1, i+1, e, c)
  --     Call S           (p+S, i, (p+1):e, c
  --     Char ')'         (p+1, i+1, e, c)
  --     Return           (p₀, i, p₁:e, c) -> (p₁, i, e, c)
  --
  -- L2: End
#+end_src
