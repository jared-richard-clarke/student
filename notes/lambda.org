* The Lambda Calculus

** Sources

| source                                             | author                                 |
|----------------------------------------------------+----------------------------------------|
| *Lambda Calculus*                                  | Wikipedia                              |
| *The Little Schemer*                               | Daniel Friedman and Matthias Felleisen |
| *The Essentials of Programming Languages*          | Daniel Friedman and Mitchell Wand      |
| *Church's Thesis and Functional Programming*       | David Turner                           |
| *Some History of Functional Programming Languages* | David Turner                           |
| *The Lambda Calculus*                              | Stanford Encyclopedia of Philosophy    |

** Definitions

- lambda calculus :: A formal system in mathematical logic for expressing computation
  based on function abstraction and application using variable binding and substitution.
  Consists of constructing lambda terms and performing reduction operations on them.

- δ-rules :: Rules for an applied lambda calculus, where constants representing various types
  of primitive data and operations are added for extended utility.

#+begin_quote
  "The lambda calculus originates from an endeavour by Church, Curry and others
   to define an alternative foundation for mathematics based on functions rather
   than sets. The attempt foundered in the late 1920's on paradoxes analogous
   to those which sank Cantor's untyped set theory. What remained after the
   propositional parts of the theory were removed is a consistent equational
   theory of functions."

  — *Some History of Functional Programming Languages*, David Turner
#+end_quote

For lambda terms *Λ*:

1. If *x* is a variable, then *x ∈ Λ*.

2. If *M*, *N ∈ Λ*, then *(M N) ∈ Λ*.

3. If *x* is a variable and *M ∈ Λ*, then *(λx.M) ∈ Λ*.

#+begin_example
  e ::= x                 # Variables
    |   λx.e              # Abstraction
    |   e1 e2             # Application

  λx.M[x] → λy.M[y]       # α-conversion

  (λx.M)N → M[x := N]     # β-reduction

  λx.M x → M              # η-conversion
    where x ∉ FV(M)

  === example ===

  λx.+ x 7

  - translates ->

  λ                x  .    +   x    7
  ^                ^  ^    ^   ^    ^
  |                |  |    |   |    |
  That function of x that adds x to 7

  === syntactic sugar: named constants ===

  # Aside: "x" cannot be referenced inside "B"
           because "B" is outside the scope of "x".

  let x = B
      y = C
  in A

  - equivalent ->

  let x = B
  in let y = C
     in A

  - equivalent ->
  
  (λx.λy.A) B C

  === syntactic sugar: recursion ===
  
  letrec v = B in A

  - equivalent ->

  let v = Y (λv.B) in A
          where Y = (λf.(λx.f (x x)) (λx.f (x x)))

  - equivalent ->

  (λv.A) (Y (λv.B))
#+end_example

- λ-conversion :: Written *⇔*, the smallest reflexive, symmetric, transitive, and substitutive relation
  on terms *→α*, *→β* and *→η*.

- λ-reduction :: Written *⇒*, omits the symmetry of the previous definition for an oriented relation.

- redex :: Called the *reducible expression*, it is the left-hand side of rule *β* or *η*.

- reduct :: An expression to which a redex reduces. *M[x := N]* is the reduct of *(λx.M) N*.

- normal form :: A term containing no redex.

- normalizing :: A term that can be converted to normal form.

- non-normalizing :: A term that *cannot* be converted to normal form, such as
  *(λx.xx)(λx.xx) →β (λx.xx)(λx.xx)*.

- Church-Rosser Theorem :: If *A ⇔ B*, there is a term *C* such that *A ⇒ C* and *B ⇒ C*.

- Normal Order Theorem :: Stated informally: the normal form of a normalizing term can be found by
  repeatedly reducing its left-most (outer-most) redex.

- Normal Order Reduction :: A sequential procedure — provided by the normal order theorem —
  that is guaranteed to reach normal form for a normalizing expression. Substitutes arguments
  into function bodies without first reducing any redexes inside their arguments.

*** Conversion and Reduction Operations

- λx.M[x] → λy.M[y] :: α-conversion, which renames bound variables in an expression. Used to avoid
  name collisions.

- (λx.M) N → M[x := N] :: β-reduction, which replaces bound variables with the argument expression
  in the body of the abstraction.

- λx.M → M, where x ∉ FV(M) :: η-conversion, which allows adding or dropping an abstraction
  over a function as long as the variable within the abstraction is bound within the function.

*** Notational Conventions

- Outermost parentheses are dropped: *M N* implies *(M N)*.

- Applications are assumed to be left associative: *M N P* implies *(M N) P*.

- When all variables are single-letter, spaces in applications may be removed.
  *MNP* instead of *M N P*.

- The body of an abstraction extends as far right as possible:
  *λx.M N* means *λx.(M N)*, not *(λx.M) N*.

- A sequence of abstractions can be contracted: *λx.λy.λz.N* equals *λxyz.N*.

** Free and Bound Variables

The operator *λ* binds its variable wherever it occurs in the body of the abstraction.
Variables that fall within the scope of an abstraction are *bound*. All other variables
are *free*. *λ* is analogous to the universal and existential quantifiers *∀* and *∃*
of first-order logic.

| free                      | bound                     |
|---------------------------+---------------------------|
| *FV(x) = {x}*             | *BV(x) = ∅*               |
| *FV(M N) = FV(M) ∪ FV(N)* | *BV(M N) = BV(M) ∪ BV(N)* |
| *FV(λx[M]) = FV(M) \ {x}* | *BV(λx[M]) = BV(M) ∪ {x}* |

If *FV(M) = ∅* then *M* is called a *combinator*.

*** Avoiding Variable Capture

- M[x := N] :: Substitute *N* for every free occurrence of *x* in *M*.

1. x[x := N] = N, y[x := N] = y if y ≠ x

2. (M_{1}M_{2})[x := N] = (M_{1}[x := N])(M_{2}[x := N])

3. (λx.M)[x := N] = λx.M

4. (λy.M)[x := N] = λy.(M[x := N]) if y ∉ FV(N)

5. If y ∈ FV(N), α-convert λy.M to λy'.M[y := y']

** Combinators

An expression that contains no free variables is *closed*. Closed lambda expressions are also known as
*combinators* and are equivalent to terms in *combinatory logic*.

| combinator                    | meaning              |
|-------------------------------+----------------------|
| *S = λx.λy.λz.xz(yz)*         | Substitute-and-apply |
| *K = λx.λy.x*                 | Constant             |
| *I = λx.x*                    | Identity             |
| *B = λx.λy.λz.x(yz)*          | Composition          |
| *C = λx.λy.λz.xzy*            | Swap                 |
| *T = λx.λy.x*                 | True                 |
| *F = λx.λy.y*                 | False                |
| *Y = λf.(λx.f(xx))(λx.f(xx))* | Fixed Point          |

** Encoding Datatypes

The basic lambda calculus may be used to model arithmetic, booleans, data structures, and recursion.

*** Arithmetic

#+begin_example
  === Church Numerals ===
  0 := λf.λx.x
  1 := λf.λx.f x
  2 := λf.λx.f (f x)
  3 := λf.λx.f (f (f x))

  === or ===

  0 := λfx.x
  1 := λfx.f x
  2 := λfx.f (f x)
  3 := λfx.f (f (f x))

  === Operations ===

  Takes a Church numeral "n" and returns "n + 1".
  INC := λn.λf.λx.f (n f x)

  Addition: "m + nth" composition of "f"
  ADD := λm.λn.λf.λx.m f (n f x)
  ADD := λm.λn.m INC n

  Multiplication
  MUL := λm.λn.λf.m (n f)
  MUL := λm.λn.m (ADD n) 0

  Exponentiation
  POW := λb.λe.e b
#+end_example

*** Logic and Predicates

#+begin_example
  TRUE  := λx.λy.x
  FALSE := λx.λy.y

  AND := λp.λq.p q p
  OR  := λp.λq.p p q
  NOT := λp.p FALSE TRUE

  IF := λp.λa.λb.p a b

  === example ===

  AND TRUE FALSE
    ≡ (λp.λq.p q p) TRUE FALSE → TRUE FALSE TRUE
    ≡ (λx.λy.x) FALSE TRUE → FALSE
#+end_example

*** Pairs

#+begin_example
  PAIR := λx.λy.λz.z x y

  HEAD := λp.p (λx.λy.x)

  TAIL := λp.p (λx.λy.y)
#+end_example

**** Scheme Example

#+begin_src scheme
  (define pair
    (lambda (x y)
      (lambda (f) (f x y))))

  (define head
    (lambda (p)
      (p (lambda (x y) x))))

  (define tail
    (lambda (p)
      (p (lambda (x y) y))))
#+end_src

*** Recursion

#+begin_example
  === Y Combinator ===

  Y := λf.(λx.f (x x)) (λx.f (x x))

  === fixed point ===

  Y F

  ≡ (λf.(λx.f (x x)) (λx.f (x x))) F

  ≡ (λx.F (x x)) (λx.F (x x))

  ≡ F ((λx.F (x x)) (λx.F (x x)))

  ≡ F (Y F)

  Y F → F (Y F)
#+end_example

**** Scheme Example

#+begin_src scheme
  ;; The Y combinator as implemented in The Little Schemer.

  (define Y
    (lambda (f)
      ((lambda (g)
         (f (lambda (x) ((g g) x))))
       (lambda (g)
         (f (lambda (x) ((g g) x)))))))

  ;; -- or more succinctly ->

  (define Y
    (lambda (f)
      ((lambda (g) (g g))
       (lambda (g)
         (f (lambda (x) ((g g) x)))))))

  ;; This definition of Y causes an infinite loop in a strictly-evaluated
  ;; language like Scheme.

  (define Y
    (lambda (f)
      (f (Y f))))

  ;; Scheme is a strict language so the evaluation of "(f (Y f))"
  ;; must be delayed by wrapping it in a function — also called a thunk.
  ;; This, however, is not a true combinator because "Y" is a free variable
  ;; within its own definition.

  (define Y
    (lambda (f)
      (f (lambda (x) ((Y f) x)))))
#+end_src

**** Joy Example

#+begin_src
  (* recursive *)

  y == dup [[y] cons] dip i

  (* non-recursive *)

  y == [dup cons] swap concat dup cons i
#+end_src
