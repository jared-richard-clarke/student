* LL Grammars and Parsing

** Sources

| source                                          | author                  |
|-------------------------------------------------+-------------------------|
| *Introduction to Compilers and Language Design* | Douglas Thain           |
| *Formal Languages* and *Set Theory*             | Wikipedia               |
| *Basics of Compiler Design*                     | Torben Ægidius Mogensen |

** Actions

- L :: left-to-right scan

- L :: left-most derivation

- (k) :: k symbols of lookahead

** LL(1)

*LL* parsers are top-down parsers for restricted context-free languages. An *LL* parser is called an
*LL(k)* parser if it uses *k* tokens of lookahead when parsing a sentence.

*LL(1)* grammars are a subset of CFGs that can be parsed by considering only one non-terminal and
the next token in the input stream. To make a grammar *LL(1)* we must do the following:

1. Remove ambiguous derivations.

2. Eliminate left recursion.

3. Eliminate any common left prefixes through left factoring.

4. Compute the *FIRST* sets for every production and *FOLLOW* sets for every non-terminal.

5. For non-terminal *N* and input symbol *c*, choose production *N → α*
   when *c ∈ FIRST(α)*, or *Nullable(α)* and *c ∈ FOLLOW(N)*.

** Eliminating Left Recursion

*Left Recursion*: *A → Bβ* such that *B ⇒ Aγ*.

*LL(1)* grammars cannot contain left recursion. The expression *X → X + Y* is left-recursive because *X*
appears as the first symbol on the right-hand side. Thus *X + Y* will expand into *(X + Y) + Y*,
which will expand into *((X + Y) + Y) + Y* and so on into infinity.

Rewriting the rule as *X → Y + X* will remove left recursion, but it creates a right-associative
operation and a common left prefix. To make a right-associative operation again left-associative,
transform grammar *A → Aα_{1} | Aα_{2} | ... | β_{1} | β_{2} |...* into *A → β_{1}A' | β_{2}A' | ...*,
where *A' → α_{1}A' | α_{2}A' | ε*. Common left prefixes of the grammar *A → αβ_{1} | αβ_{2} | ...*
can be replaced with *A → αA'* where *A' → β_{1} | β_{2}...*.

*Side Note*: Left recursion is primarily a theoretical problem. Looping constructs, or iteration,
are excellent real-world solutions.

*Also*: Parsing expressions with precedence requires unintuitive rewritings of context-free grammars.
It is simpler to either loop through a list of atoms separated by operators and reconstruct the
tree separately or fuse the two stages into a recursive loop — a Pratt parser.

#+begin_src c
  Program parse_statements() {
    for(;;) {
      parse_statement();
      if (next() != SEMI_COLON) {
        break;
      }
    }
  }
#+end_src

** Eliminating Common Left Prefixes

Look for all common prefixes of a given non-terminal and replace them with one rule that contains
the prefix and another that contains the variants. This process is called *left factorization*,
which eliminates backtracking and redundant parsings.

*** Before Left Factoring

| rule | production |
|------+------------|
|    1 | S → E      |
|    2 | E → id     |
|    3 | E → id[E]  |
|    4 | E → id(E)  |

#+begin_example
  P ::= E
  E ::= id
      | id[E]
      | id(E)
#+end_example

*** After Left Factoring

| rule | production |
|------+------------|
|    1 | S → E      |
|    2 | E → id E'  |
|    3 | E' → [E]   |
|    4 | E' → (E)   |
|    5 | E' → ε     |

#+begin_example
  S  ::= E
  E  ::= id E'
  E' ::= [E]
       | (E)
       | ε
#+end_example

** First and Follow Sets

In order to construct a complete parser for an *LL(1)* grammar, we must compute two sets, known as
*FIRST* and *FOLLOW*. Informally, *FIRST(α)* is the set of terminals, inlcuding *ε*, that can appear
at the start of the derivation of *α*. *FOLLOW(A)* is the set of terminals, including *$*, that can
appear after the derivation of non-terminal *A*.

*Side Note*: *α* is a sentential form, *a* is a terminal, and *A* is a nonterminal.

*** Computing First Sets

- A symbol *c* is in *FIRST(α)* if and only if *α ⇒ cβ* for some, possibly empty,
  sequence *β* of grammar symbols.

  1. *FIRST(ε)* = *∅*

  2. *FIRST(a)* = *{a}*

  3. *FIRST(αβ)* = *FIRST(α) ∪ FIRST(β)* if *Nullable(α)* or *FIRST(α)* if not *Nullable(α)*

  4. *FIRST(N)* = *FIRST(α_{1}) ∪ ... ∪ FIRST(α_{n})*, where productions for
     *N* are *N → α_{1}, ... , N → α_{n}*.

- A sequence *α* of grammar symbols is *Nullable(α)* if and only if *α ⇒ ε*.

  1. *Nullable(ε)* = *true*

  2. *Nullable(a)* = *false*

  3. *Nullable(αβ)* = *Nullable(α) ∧ Nullable(β)*

  4. *Nullable(N)* = *Nullable(α_{1}) ∨ ... ∨ Nullable(α_{n})*, where productions for
     *N* are *N → α_{1}, ... , N → α_{n}*.

#+begin_example
  FIRST(α) is the set of terminals that begin all strings given by α,
  including ε if α ⇒ ε.

  For Terminals:
  For each terminal a ∈ Σ: FIRST(a) = {a}

  For Non-Terminals:
  Repeat:
      For each rule X → Y₁Y₂...Yk in a grammar G:
          Add a to FIRST(X)
              if a is in FIRST(Y₁)
              or a is in FIRST(Yn) and Y₁...Yn-1 ⇒ ε
          If Y₁...Yk ⇒ ε then add ε to FIRST(X)
  until no more changes occur.

  For a Sentential Form α:
  For each symbol Y₁Y₂...Yk in α:
      Add a to FIRST(α)
          if a is in FIRST(Y₁)
          or a is in FIRST(Yn) and Y₁...Yn-1 ⇒ ε
      If Y₁...Yk ⇒ ε then add ε to FIRST(α).
#+end_example

*** Computing Follow Sets

- A terminal symbol *a* is in *FOLLOW(N)* if and only if there is a derivation from the
  start symbol *S* of the grammar such that *S ⇒ αNaβ*, where *α* and *β* are sequences
  of zero or more grammar symbols.

#+begin_example
  FOLLOW(A) is the set of terminals that can come after
  non-terminal A, including $ if A occurs at the end of the input.

  FOLLOW(S) = {$} where S is the start symbol.

  Repeat:
      If A → αBβ then:
          add FIRST(β) (excepting ε) to FOLLOW(B).
      If A → αB or FIRST(β) contains ε then:
          add FOLLOW(A) to FOLLOW(B).
  until no more changes occur.
#+end_example

** Recursive Descent Parsing

*LL(1)* grammars are amenable to *recursive descent parsing* in which there is one function for each
non-terminal in a grammar. The body of each function follows the right-hand sides of the corresponding
rules: non-terminals are function calls, and terminals are matches against the next input symbol.

Two special cases must be considered:

1. If rule *X* cannot produce *ε* and the token is not in *FIRST(X)*, then return error.
2. If rule *X* could produce *ε* and the token is not in *FIRST(X)*, return success.
   Another rule will consume that token.

Three helper functions are needed:

- ~next()~ :: returns the next token in the input stream.
- ~peek()~ :: looks ahead to the next token without the parser consuming it.
- ~match(t)~ :: consumes the next token if it matches ~t~.

*** Grammar Translated into a Recursive Descent Parser

This C program serves only to verify that the input program matches the following grammar:

| rule | production |
|------+------------|
|    1 | X → Z Y    |
|    2 | Y → + Z Y  |
|    3 | Y → ε      |
|    4 | Z → 0      |
|    5 | Z → 1      |

#+begin_src c
  // S ::= X $
  int parse_S() {
    return parse_E() && match(TOKEN_EOF);
  }
  // X ::= Z Y
  int parse_X() {
    return parse_Z() && parse_Y();
  }
  // Y ::= + Z Y | ε
  int parse_Y() {
    token_t t = peek();
    if (t == TOKEN_PLUS) {
      next();
      return parse_Z() && parse_Y();
    }
    return 1;
  }
  // Z ::= 0 | 1
  int parse_Z() {
    token_t t = peek();
    if (t == TOKEN_ZERO || t == TOKEN_ONE) {
      next();
      return 1;
    } else {
      printf("parse error: unexpected token %s\n", token_string(t));
      return 0;
    }
  }
#+end_src

** LL(1) Table-Driven Parsing

An *LL(1)*, table-driven parser requires a grammar, a parse table, and a stack to represent the
current set of non-terminals. The *LL(1)* parse table is used to determine which rule should be
applied for any combination of non-terminal on the stack and the next token on the input stream.

*** LL(1) Parse Table Construction

#+begin_example
  Given a grammar G and alphabet Σ, create a parse table T[A, a] that selects
  a rule for each combination of non-terminal A ∈ G and terminal a ∈ Σ.

  For each rule A → w in G:
      For each terminal a (excepting ε) in FIRST(w):
          Add A → w to T[A, a].
      if ε is in FIRST(w):
          For each terminal b (including $) in FOLLOW(A):
              Add A → w to T[A, b]

  In other words...

  T[A, a] contains the rule A → w if and only if
      a is in FIRST(w) or
      ε is in FIRST(w) and a is in FOLLOW(A)
#+end_example

** LL(1) Table Parsing Algorithm

Informally, the idea is to keep a stack that tracks the current state of the parser. In each step,
we consider the top element of the stack and the next token on the input. If they match, then pop
the stack, accept the token, and continue. If not, then consult the parse table for the next rule
to apply. If we can continue until the end-of-file symbol is matched, then the parse succeeds.

#+begin_example
  stack := empty
  push(start, $, stack)
  c := next(input)

  While not empty(stack) then
      x := peek(stack)
      if terminal(x) then
          if match(x, c):
              pop(stack)
              c = next(input)
          else
              throw(error)
          end
      end
      if table[x, c] == rule x → α then
          pop(stack)
          push(α, stack)
      else
          throw(error)
      end
  end
#+end_example

** LL(1) Example

*** Grammar

| rule | production |
|------+------------|
|    1 | X → Z Y    |
|    2 | Y → + Z Y  |
|    3 | Y → ε      |
|    4 | Z → 0      |
|    5 | Z → 1      |

*** Parse Table

| FIRST  | FOLLOW | non-terminal | + | 0 | 1 | $ |
|--------+--------+--------------+---+---+---+---|
| {0, 1} | {$}    | X            |   | 1 | 1 |   |
| {+, ε} | {$}    | Y            | 2 |   |   | ε |
| {0, 1} | {+, $} | Z            |   | 4 | 5 |   |

*** Stack Trace: ~1 + 0~ 

| stack   | input   | action             |
|---------+---------+--------------------|
| $ X     | 1 + 0 $ |                    |
| $ Y Z   | 1 + 0 $ | apply 1: X ⇒ Z Y   |
| $ Y 1   | 1 + 0 $ | apply 5: Z ⇒ 1     |
| $ Y     | + 0 $   | match 1            |
| $ Y Z + | + 0 $   | apply 2: Y ⇒ + Z Y |
| $ Y Z   | 0 $     | match +            |
| $ Y 0   | 0 $     | apply 4: Z ⇒ 0     |
| $ Y     | $       | match 0            |
| $       | $       | apply 3: Y ⇒ ε     |
| $       |         | match $            |
