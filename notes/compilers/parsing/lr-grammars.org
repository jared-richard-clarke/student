* LR Grammars and Parsing

*Introduction to Compilers and Language Design*, Douglas Thain

*LR Parsing*, Wikipedia

** Actions

- L :: left-to-right parse

- R :: Right-most derivation. Expands the right-most nonterminal. Reductions in reverse order,
  from the leaves to the root.

- (k) :: *k* symbols of lookahead.

An *LR(k)* parser has a stack and input. Given the contents of a stack and *k* tokens
of lookahead, the parser does one of the following operations:

1. *shift n*: Push the matched terminal *t* onto the parse stack and scan the next input symbol
   into the lookahead buffer. Push next state *n* onto the parse stack as the new current state.

2. *reduce r_{m}*: Apply grammar rule *r_{m}: Lhs → S_{1} S_{2} ... S_{L}*.
   - Remove the matched topmost *L* symbols from the parse stack.
   - This exposes a prior state *p* that was expecting an instance of the *Lhs* symbol.
   - Join the *L* parse trees together as one parse tree with new root symbol *Lhs*.
   - Lookup the next state *n* from row *p* and column *Lhs* of the *Goto* table.
   - Push the symbol and tree for *Lhs* onto the parse stack.
   - Push the next state *n* onto the parse stack as the new current state.
   - The lookahead and input stream remain unchanged.

3. *accept*: Lookahead *t* is the *eof* marker. End of parsing. If the state stack contains just the
   start state, report success. Otherwise report a syntax error.

4. *error*: Report a syntax error. The parser ends, or attempts some recovery.

The difference between *SLR*, *LALR*, and *LR* parsers is in the tables that they use. Different
tables use different techniques to determine when to *reduce*, and, if there is more than one grammar
rule with the same right-hand side, which left-hand-side nonterminal to push.

Two types of conflict can appear in an *LR* grammar:

| shift-reduce | reduce-reduce |
|--------------+---------------|
| T → id.( E ) | S → id( E ).  |
| T → id.      | E → id( E ).  |

The *LR(0)* automaton forms the basis of *LR* parsing by telling use which actions are available
in each state, but it does not tell us which action to take or how to resolve shift-reduce and
reduce-reduce conflicts.

** Algorithm

- *Input*: A LR-Parser for an unambiguous context-free grammar *G* over an alphabet *Σ* and a
  word *w ∈ Σ\star{}*.

- *Output*: An error if *w ∉ L(G)* or a rightmost derivation for *w* otherwise.

  - Set the cursor to the rightmost symbol of *w$*.
  - Push the initial state *s_{0}* on top of the empty stack.
  - Repeat
    - Let *s* be the state on top of the stack.
    - Let *a* be the current pointed symbol in *w$*.
    - If *action[s, a]* = *shift s_{n}* then
      - Push *a* on top of the stack.
      - Push *s_{n}* on top of the stack.
      - Advance the cursor to the next symbol on the right in *w$*.
    - else if *action[s, a]* = *reduce A → β* then
      - pop | *β* | symbols off the stack.
      - let *s_{n}* be the state on top of the stack.
      - push *A* on top of the stack.
      - push *goto[s, a]* on top of the stack.
      - output *A → β*.
    - else if *action[s, a]* = *accept* then
      - return
    - else
      - error

#+begin_example
# === parser-driving psuedo code ===

while (true) {
    switch (action[state_stack.top()][current_token]) {
        case shift sn:
            symbol_stack.push(current_token);
            state_stack.push(sn);
            next_token();
        case reduce A → β:
            pop length(β) symbols off symbol_stack and state_stack;
            symbol_stack.push(A);
            state_stack.push(goto[state_stack.top()][A]);
        case accept: return;
        default: error;
    }
}

// === parser-driving psuedo code ===

push($, 0) // <----- always pushing a symbol/state pair
lookahead = yylex();
loop
    s = top(); // <- always a state
    if action[s, lookahead] = shift s'
        push(lookahead, s');
        lookahead = yylex();
    else if action[s, lookahead] = reduce A → β
        pop size of β pairs
        s' = state on top of stack
        push(A, goto[s', A]);
    else if action[s, lookahead] = accept then return
    else error();
end loop;
#+end_example

** LR(0) Automaton

- LR(0) Automaton :: All the possible rules that are currently under consideration by a shift-reduce
  parser. Each set of rules, or box, represents a state in the machine, connected by transitions from
  both terminals to non-terminals in a grammar. Also known as the *canonical collection* or
  *compact finite state machine* of a grammar.

- Items :: The contents of each state, which are rules augmented by a *marker*.  In general, item
  *X → γ . δ* means *γ* is at the top of the stack. At the head of the input there is a string
  derivable from *δ*.

- Marker(.) :: Marks the parser's current position in a rule.

- Kernel :: *State 0* created by taking the production for the start symbol *S → E* and adding a marker
  at the beginning of the right-hand side.

- Closure ::  Any set of items can be extended by recursively adding all the appropriate items until
  all non-terminals preceded by markers are accounted for. The minimal extension is called the closure
  of an item set.

*** Grammar

| rule | production |
|------+------------|
|    1 | S → E $    |
|    2 | E → ( L )  |
|    3 | E → x      |
|    4 | L → E      |
|    5 | L → L, E   |

*** Configurating Sets

1. If state contains item *X → γ.$* then *accept*.
2. If state contains item *X → γ.* then *reduce* *X → γ*.
3. If state *i* has edge to *j* with terminal, then *shift*.

| state | set         | successor |
|-------+-------------+-----------|
| s1    | S → .E $    | s4        |
|       | E  → .( L ) | s3        |
|       | E  → .x     | s2        |
|-------+-------------+-----------|
| s2    | E → x.      | reduce 3  |
|-------+-------------+-----------|
| s3    | E → (.L )   | s5        |
|       | L → .E      | s7        |
|       | L → .L, E   | s5        |
|       | E → .( L )  |           |
|       | E → .x      |           |
|-------+-------------+-----------|
| s4    | S → E.$     | accept    |
|-------+-------------+-----------|
| s5    | E → ( L. )  | s6        |
|       | L → L., E   | s8        |
|-------+-------------+-----------|
| s6    | E → ( L ).  | reduce 2  |
|-------+-------------+-----------|
| s7    | L → E.      | reduce 4  |
|-------+-------------+-----------|
| s8    | L → L,.E    | s9        |
|       | E → .( L )  | s3        |
|       | E → .x      | s2        |
|-------+-------------+-----------|
| s9    | L → L, E.   | reduce 5  |

*** Goto Graph / Transition Diagram

#+begin_example
1.
 -------------        2.             8.                   9.
| S  → .E $   |  x    --------   x   ------------    E   -----------
| E  → .( L ) |----->| E → x. |<----| L → L,.E   |----->| L → L, E. |
| E  → .x     |-+     --------      | E → .( L ) |       -----------
 -------------  |    3.             | E → .x     |
     S |      ( |     ------------   ------------
4.     V        +--->| E → (.L )  | ( |     ^
 ------------        | L → .E     |<--+     | ,
| S → E.$    |       | L → .L, E  |         |       5.
 ------------        | E → .( L ) |  L    -----------
                     | E → .x     |----->| E → ( L.) |
                      ------------       | L → L., E |
                          |               -----------
                        E |                 |
                          V   7.            | )
                       --------             V        6.
                      | L → E. |          ------------
                       --------          | E → ( L ). |
                                          ------------
#+end_example

** LR(1) Parsing

The complete of canonical form of *LR(1)* parsing depends on the *LR(1)* automaton.
The *LR(1)* automaton is like the *LR(0)* automaton, except that each item is annotated with
the set of tokens that could potentially follow it, given the current state. This set is known
as the *lookahead* of the item. The lookahead is always a subset of the *FOLLOW* of the
relevant non-terminal.

- For an item like *A → α.B* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead of *{L}*.

- For an item like *A → α.Bβ* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead as follows:

  - If *β* cannot produce *ε*, the lookahead is *FIRST(β)*.
  - If *β* can produce *ε*, the lookahead is *FIRST(β) ∪ {L}*

** Shift-Reduce Parsing Example

*** LR(1) Grammar

| rule | production  |
|------+-------------|
|    0 | S → E $     |
|    1 | E → T E'    |
|    2 | E' → + T E' |
|    3 | E' → ε      |
|    4 | T → 1       |

*** FIRST Table

| non-terminal | first    |
|--------------+----------|
| S            | { 1 }    |
| E            | { 1 }    |
| E'           | { +, ε } |
| T            | { 1 }    |

*** LR(1) Closure Table

| goto        | kernel                   | state | closure                                                            |
|-------------+--------------------------+-------+--------------------------------------------------------------------|
|             | [ S → .E, { $ } ]        |     0 | [ S → .E, { $ } ], [ E → .T E', { $ } ], [ T → .1, { +, /, $ } ]   |
| goto(0, E)  | [ S → E., { $ } ]        |     1 | [ S → E., { $ } ]                                                  |
| goto(0, T)  | [ E → T.E', { $ } ]      |     2 | [ E → T.E', { $ } ], [ E' → .+ T E', { $ } ], [ E' → ., { $ } ]    |
| goto(0, 1)  | [ T → 1., { +, /, $ } ]  |     3 | [ T → 1., { +, /, $ } ]                                            |
| goto(2, E') | [ E → T E' ., { $ } ]    |     4 | [ E → T E'., { $ } ]                                               |
| goto(2, +)  | [ E' → +.T E', { $ } ]   |     5 | [ E' → +.T E', { $ } ], [ T → .1, { +, /, $ } ]                    |
| goto(5, T)  | [ E' → + T.E', { $ } ]   |     6 | [ E' → + T.E', { $ } ], [ E' → .+ T E', { $ } ], [ E' → ., { $ } ] |
| goto(5, 1)  | [ T → 1., { +, /, $ } ]  |     3 |                                                                    |
| goto(6, E') | [ E' → + T E' ., { $ } ] |     7 | [ E' → + T E' ., { $ } ]                                           |
| goto(6, +)  | [ E' → +.T E', { $ } ]   |     5 |                                                                    |

*** LR Table: Action and Goto

| state | +  | 1  | $      | S | E | E' | T |
|-------+----+----+--------+---+---+----+---|
|     0 |    | s3 |        |   | 1 |    | 2 |
|     1 |    |    | accept |   |   |    |   |
|     2 | s5 |    | r3     |   |   |  4 |   |
|     3 | r4 |    | r4     |   |   |    |   |
|     4 |    |    | r1     |   |   |    |   |
|     5 |    | s3 |        |   |   |    | 6 |
|     6 | s5 |    | r3     |   |   |  7 |   |
|     7 |    |    | r2     |   |   |    |   |

*** Stack Trace: ~1 + 1~

*Side Note*: ~symbol~ and ~state~ are often combined into a single stack of symbol-state pairs.

| step | symbol          | state             | input   | action |
|------+-----------------+-------------------+---------+--------|
|    1 |                 | [ 0 ]             | 1 + 1 $ | s3     |
|    2 | [ 1 ]           | [ 0, 3 ]          | + 1 $   | r4     |
|    3 | [ T ]           | [ 0 ]             | + 1 $   | 2      |
|    4 | [ T ]           | [ 0, 2 ]          | + 1 $   | s5     |
|    5 | [ T, + ]        | [ 0, 2, 5 ]       | 1 $     | s3     |
|    6 | [ T, +, 1 ]     | [ 0, 2, 5, 3 ]    | $       | r4     |
|    7 | [ T, +, T ]     | [ 0, 2, 5 ]       | $       | 6      |
|    8 | [ T, +, T ]     | [ 0, 2, 5, 6 ]    | $       | r3     |
|    9 | [ T, +, T, E' ] | [ 0, 2, 5, 6]     | $       | 7      |
|   10 | [ T, +, T, E' ] | [ 0, 2, 5, 6, 7 ] | $       | r2     |
|   11 | [ T, E' ]       | [ 0, 2 ]          | $       | 4      |
|   12 | [ T, E' ]       | [ 0, 2, 4 ]       | $       | r1     |
|   13 | [ E ]           | [ 0 ]             | $       | 1      |
|   14 | [ E ]           | [ 0, 1 ]          | $       | accept |

** LALR Parsing

The main downside to *LR(1)* parsing is that the *LR(1)* automaton can be many times larger
than an *LR(0)* automaton. *Lookahead LR* parsing is the practical answer to this problem.
To construct an *LALR* parser, the states of an *LR(1)* automaton with the same *core* must
be merged. The *core* of a state is simply the body of an *item*, ignoring lookahead.
The resulting *LALR* automaton has the same number of states as the *LR(0)* automaton, but
has more precise lookahead information available for each item.

*** LR(1) States

| state 1    | LA       | state 2    | LA       |
|------------+----------+------------+----------|
| E → .E + T | { $, + } | E → .E + T | { ), + } |
| E → .T     | { $, + } | E → .T     | { ), + } |

*** LALR State

| state      | LA          |
|------------+-------------|
| E → .E + T | { $, ), + } |
| E → .T     | { $, ), + } |

** Table Construction

*** Finding the Reachable Item Sets

1. Take the subset, *S*, of all items in the current item set where there is a dot in front of the symbol
   of interest, *x*.

2. For each item in *S*, move the dot to the right of *x*.

3. Close the resulting set of items.

*** Constructing Action and Goto

1. The columns for non-terminals are copied to the goto table.
   
2. The columns for the terminals are copied to the action table as shift actions.
   
3. An extra column for *$* (eof) is added to the action table. An *accept* action is added to the *$*
   column for each item set that contains an item of the form *S → w.$*.
   
4. If an item set *i* contains an item of the form *A → w.* and *A → w* is rule *m* with *m > 0* then
   the row for state *i* in the action table is completely filled with the reduce action *r_{m}*.
