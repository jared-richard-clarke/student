* LR Grammars and Parsing

*Introduction to Compilers and Language Design*, Douglas Thain

*LR Parsing*, Wikipedia

** Actions

- L :: left-to-right parse

- R :: Right-most derivation. Expands the right-most nonterminal. Reductions in reverse order,
  from the leaves to the root.

- (k) :: *k* symbols of lookahead.

** Algorithm

- *Input*: A LR-Parser for an unambiguous context-free grammar *G* over an alphabet *Σ* and a
  word *w ∈ Σ\star{}*.

- *Output*: An error if *w ∉ L(G)* or a rightmost derivation for *w* otherwise.

  - Set the cursor to the rightmost symbol of *w$*.
  - Push the initial state *s_{0}* on top of the empty stack.
  - Repeat
    - Let *s* be the state on top of the stack.
    - Let *a* be the current symbol in *w$*.
    - If *action[s, a]* = *shift s_{n}* then
      - Push *a* on top of the stack.
      - Push *s_{n}* on top of the stack.
      - Advance the cursor to the next symbol on the right in *w$*.
    - if *action[s, a]* = *reduce A → β* then
      - pop | *β* | symbols off the stack.
      - let *s_{n}* be the state on top of the stack.
      - push *A* on top of the stack.
      - push *goto[s, a]* on top of the stack.
    - if *action[s, a]* = *accept* then
      - return success
    - else
      - return error

#+begin_example
# === parser-driving psuedo code ===

stack.push($, 0) # <----- always push a symbol/state pair
lookahead = scan()
loop:
    s = stack.top() # <-- always a state
    switch(action[s][lookahead])
    case shift sn:
        stack.push(lookahead, sn)
        lookahead = scan()
    case reduce A → β:
        stack.pop(β)
        sn = stack.top()
        stack.push(A, goto[sn][A])
    case accept:
        return success
    default:
        return error
#+end_example

The difference between *SLR*, *LALR*, and *LR* parsers is in the tables that they use. Different
tables use different techniques to determine when to *reduce*, and, if there is more than one grammar
rule with the same right-hand side, which left-hand-side nonterminal to push.

Two types of conflict can appear in an *LR* grammar:

| shift-reduce | reduce-reduce |
|--------------+---------------|
| T → id.( E ) | S → id( E ).  |
| T → id.      | E → id( E ).  |

** LR(0) Automaton

- LR(0) Automaton :: All the possible rules that are currently under consideration by a shift-reduce
  parser. Each set of rules, or box, represents a state in the machine, connected by transitions from
  both terminals to non-terminals in a grammar. Also known as the *canonical collection* or
  *compact finite state machine* of a grammar.

- Items :: The contents of each state, which are rules augmented by a *marker*.  In general, item
  *X → γ . δ* means *γ* is at the top of the stack. At the head of the input there is a string
  derivable from *δ*.

- Marker(.) :: Marks the parser's current position in a rule.

- Kernel :: *State 0* created by taking the production for the start symbol *S → E* and adding a marker
  at the beginning of the right-hand side.

- Closure ::  Any set of items can be extended by recursively adding all the appropriate items until
  all non-terminals preceded by markers are accounted for. The minimal extension is called the closure
  of an item set.
** SLR Parser Example

An *SLR* grammar is one that has no *shift-reduce* or *reduce-reduce* conflicts when examining its
*FOLLOW* sets.

*** Grammar

| rule | production  |
|------+-------------|
|    0 | S → E $     |
|    1 | E → T E'    |
|    2 | E' → + T E' |
|    3 | E' → ε      |
|    4 | T → 1       |

*** Configurating Sets

| state | set          | successor |
|-------+--------------+-----------|
| s0    | S → .E $     | s1        |
|       | E → .T E'    | s2        |
|       | T → .1       | s3        |
|-------+--------------+-----------|
| s1    | S → E.$      | accept    |
|-------+--------------+-----------|
| s2    | E → T.E'     | s4        |
|       | E' → .+ T E' | s5        |
|       | E' → .       | r3        |
|-------+--------------+-----------|
| s3    | T → 1.       | r4        |
|-------+--------------+-----------|
| s4    | E → T E'.    | r1        |
|-------+--------------+-----------|
| s5    | E' → +.T E'  | s6        |
|       | T → .1       | s3        |
|-------+--------------+-----------|
| s6    | E' → + T.E'  | s7        |
|       | E' → .+ T E' | s5        |
|       | E' → .       | r3        |
|-------+--------------+-----------|
| s7    | E' → + T E'. | r2        |

*** Goto Graph / Transition Diagram

1. If state contains item *X → γ.$* then *accept*.
2. If state contains item *X → γ.* then *reduce* *X → γ*.
3. If state *i* has edge to *j* with terminal, then *shift*.

#+begin_example
                                   1
           +-----------------------------------------------+
           |                                               |
 ------------         ---------                            |
| state 0    |   E   | state 1 |                           |
|------------|------>|---------|                           |
| S → .E $   |       | S → E.$ |                           |
| E → .T E'  |   T    ---------                            |
| T → .1     |---+    --------------                       |
 ------------    |   | state 2      |                      |
                 +-->|--------------|                      |
                     | E → T.E'     |                      |
  --------------     | E' → .+ T E' |  E'                  |
 | state 7      |    | E' → .       |---+     -----------  |
 |--------------|     --------------    |    | state 4   | |
 | E' → + T E'. |           |           +--->|-----------| |
  --------------            | +              | E → T E'. | |
       ^                    |                 -----------  |
       | E'                 |                              |
       |                    V                              |
  --------------         -------------         ---------   |
 | state 6      |   T   | state 5     |   1   | state 3 |  |
 |--------------|<------|-------------|------>|---------|<-+
 | E' → + T.E'  |   +   | E' → +.T E' |       | T → 1.  |
 | E' → .+ T E' |------>| T → .1      |        ---------
 | E' → .       |        -------------
  --------------
#+end_example

*** First-Follow Table

| non-terminal | first    | follow   |
|--------------+----------+----------|
| S            | { 1 }    | { $ }    |
| E            | { 1 }    | { $ }    |
| E'           | { +, ε } | { $ }    |
| T            | { 1 }    | { +, $ } |

*** Goto-Action Table

Each parser state has its own row. Each possible symbol has its own column. Some state-symbol
combinations are impossible for valid input streams. These blank cells trigger syntax errors.

| state | E | E' | T | +  | 1  | $      |
|-------+---+----+---+----+----+--------|
|     0 | 1 |    | 2 |    | s3 |        |
|     1 |   |    |   |    |    | accept |
|     2 |   |  4 |   | s5 |    | r3     |
|     3 |   |    |   | r4 |    | r4     |
|     4 |   |    |   |    |    | r1     |
|     5 |   |    | 6 |    | s3 |        |
|     6 |   |  7 |   | s5 |    | r3     |
|     7 |   |    |   |    |    | r2     |

*** Stack Trace: ~1 + 1~

| state           | symbol        | input   | action |
|-----------------+---------------+---------+--------|
| [0]             | []            | 1 + 1 $ | s3     |
| [0, 3]          | [1]           | + 1 $   | r4     |
| [0]             | [T]           | + 1 $   | 2      |
| [0, 2]          | [T]           | + 1 $   | s5     |
| [0, 2, 5]       | [T, +]        | 1 $     | s3     |
| [0, 2, 5, 3]    | [T, +, 1]     | $       | r4     |
| [0, 2, 5]       | [T, +, T]     | $       | 6      |
| [0, 2, 5, 6]    | [T, +, T]     | $       | r3     |
| [0, 2, 5, 6]    | [T, +, T, E'] | $       | 7      |
| [0, 2, 5, 6, 7] | [T, +, T, E'] | $       | r2     |
| [0, 2]          | [T, E']       | $       | 4      |
| [0, 2, 4]       | [T, E']       | $       | r1     |
| [0]             | [E]           | $       | 1      |
| [0, 1]          | [E]           | $       | accept |

** LR(1) Parsing

The complete of canonical form of *LR(1)* parsing depends on the *LR(1)* automaton.
The *LR(1)* automaton is like the *LR(0)* automaton, except that each item is annotated with
the set of tokens that could potentially follow it, given the current state. This set is known
as the *lookahead* of the item. The lookahead is always a subset of the *FOLLOW* of the
relevant non-terminal.

- For an item like *A → α.B* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead of *{L}*.

- For an item like *A → α.Bβ* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead as follows:

  - If *β* cannot produce *ε*, the lookahead is *FIRST(β)*.
  - If *β* can produce *ε*, the lookahead is *FIRST(β) ∪ {L}*

** LALR Parsing

The main downside to *LR(1)* parsing is that the *LR(1)* automaton can be many times larger
than an *LR(0)* automaton. *Lookahead LR* parsing is the practical answer to this problem.
To construct an *LALR* parser, the states of an *LR(1)* automaton with the same *core* must
be merged. The *core* of a state is simply the body of an *item*, ignoring lookahead.
The resulting *LALR* automaton has the same number of states as the *LR(0)* automaton, but
has more precise lookahead information available for each item.

*** LR(1) States

| state 1    | LA       | state 2    | LA       |
|------------+----------+------------+----------|
| E → .E + T | { $, + } | E → .E + T | { ), + } |
| E → .T     | { $, + } | E → .T     | { ), + } |

*** LALR State

| state      | LA          |
|------------+-------------|
| E → .E + T | { $, ), + } |
| E → .T     | { $, ), + } |

** Table Construction

*** Finding the Reachable Item Sets

1. Take the subset, *S*, of all items in the current item set where there is a dot in front of the symbol
   of interest, *x*.

2. For each item in *S*, move the dot to the right of *x*.

3. Close the resulting set of items.

*** Constructing Action and Goto

1. The columns for non-terminals are copied to the goto table.
   
2. The columns for the terminals are copied to the action table as shift actions.
   
3. An extra column for *$* (eof) is added to the action table. An *accept* action is added to the *$*
   column for each item set that contains an item of the form *S → w.$*.
   
4. If an item set *i* contains an item of the form *A → w.* and *A → w* is rule *m* with *m > 0* then
   the row for state *i* in the action table is completely filled with the reduce action *r_{m}*.
