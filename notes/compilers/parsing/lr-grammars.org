* LR Grammars and Parsing

*Introduction to Compilers and Language Design*, Douglas Thain

*LR Parsing*, Wikipedia

** Actions

- L :: left-to-right parse

- R :: Right-most derivation. Expands the right-most nonterminal. Reductions in reverse order,
  from the leaves to the root.

- (k) :: *k* symbols of lookahead.

An *LR(k)* parser has a stack and input. Given the contents of a stack and *k* tokens
of lookahead, the parser does one of the following operations:

1. *shift n*: Push the matched terminal *t* onto the parse stack and scan the next input symbol
   into the lookahead buffer. Push next state *n* onto the parse stack as the new current state.

2. *reduce r_{m}*: Apply grammar rule *r_{m}: Lhs → S_{1} S_{2} ... S_{L}*.
   - Remove the matched topmost *L* symbols from the parse stack.
   - This exposes a prior state *p* that was expecting an instance of the *Lhs* symbol.
   - Join the *L* parse trees together as one parse tree with new root symbol *Lhs*.
   - Lookup the next state *n* from row *p* and column *Lhs* of the *Goto* table.
   - Push the symbol and tree for *Lhs* onto the parse stack.
   - Push the next state *n* onto the parse stack as the new current state.
   - The lookahead and input stream remain unchanged.

3. *accept*: Lookahead *t* is the *eof* marker. End of parsing. If the state stack contains just the
   start state, report success. Otherwise report a syntax error.

4. *error*: Report a syntax error. The parser ends, or attempts some recovery.

The difference between *SLR*, *LALR*, and *LR* parsers is in the tables that they use. Different
tables use different techniques to determine when to *reduce*, and, if there is more than one grammar
rule with the same right-hand side, which left-hand-side nonterminal to push.

Two types of conflict can appear in an *LR* grammar:

| shift-reduce | reduce-reduce |
|--------------+---------------|
| T → id.( E ) | S → id( E ).  |
| T → id.      | E → id( E ).  |

** Algorithm

- *Input*: A LR-Parser for an unambiguous context-free grammar *G* over an alphabet *Σ* and a
  word *w ∈ Σ\star{}*.

- *Output*: An error if *w ∉ L(G)* or a rightmost derivation for *w* otherwise.

  - Set the cursor to the rightmost symbol of *w$*.
  - Push the initial state *s_{0}* on top of the empty stack.
  - Repeat
    - Let *s* be the state on top of the stack.
    - Let *a* be the current pointed symbol in *w$*.
    - If *action[s, a]* = *shift s_{n}* then
      - Push *a* on top of the stack.
      - Push *s_{n}* on top of the stack.
      - Advance the cursor to the next symbol on the right in *w$*.
    - else if *action[s, a]* = *reduce A → β* then
      - pop | *β* | symbols off the stack.
      - let *s_{n}* be the state on top of the stack.
      - push *A* on top of the stack.
      - push *goto[s, a]* on top of the stack.
      - output *A → β*.
    - else if *action[s, a]* = *accept* then
      - return
    - else
      - error

#+begin_example
# === parser-driving psuedo code ===

while (true) {
    switch (action(state_stack.top(), current_token)) {
        case shift sn:
	    symbol_stack.push(current_token);
	    state_stack.push(sn);
	    next_token();
	case reduce A → β:
	    pop length(β) symbols off symbol_stack and state_stack;
	    symbol_stack.push(A);
	    state_stack.push(goto(state_stack.top(), A));
	case accept: return;
	default: error;
    }
}
#+end_example

** LR(0) Automaton

- LR(0) Automaton :: All the possible rules that are currently under consideration by a shift-reduce
  parser. Each set of rules, or box, represents a state in the machine, connected by transitions from
  both terminals to non-terminals in a grammar. Also known as the *canonical collection* or
  *compact finite state machine* of a grammar.

- Items :: The contents of each state, which are rules augmented by a *marker*.  In general, item
  *X → γ . δ* means *γ* is at the top of the stack. At the head of the input there is a string
  derivable from *δ*.

- Marker(.) :: Marks the parser's current position in a rule.

- Kernel :: *State 0* created by taking the production for the start symbol *S → E* and adding a marker
  at the beginning of the right-hand side.

- Closure :: For each item in the state with a non-terminal *X* immediately to the right of the
  marker, add all rules in the grammar that have *X* as the left-hand side. The newly added items
  have a marker at the beginning of the right-hand side.

*** Grammar

| rule | production |
|------+------------|
|    1 | S → E $    |
|    2 | E → ( L )  |
|    3 | E → x      |
|    4 | L → E      |
|    5 | L → L, E   |

*** Configurating Sets

1. If state contains item *X → γ.$* then *accept*.
2. If state contains item *X → γ.* then *reduce* *X → γ*.
3. If state *i* has edge to *j* with terminal, then *shift*.

| state | set        | successor |
|-------+------------+-----------|
| s1    | S → .E $   | s4        |
|       | E  → .(L)  | s3        |
|       | E  → .x    | s2        |
|-------+------------+-----------|
| s2    | E → x.     | reduce 3  |
|-------+------------+-----------|
| s3    | E → (.L )  | s5        |
|       | L → .E     | s7        |
|       | L → .L, E  | s5        |
|       | E → .( L ) |           |
|       | E → .x     |           |
|-------+------------+-----------|
| s4    | S → E.$    | accept    |
|-------+------------+-----------|
| s5    | E → ( L. ) | s6        |
|       | L → L., E  | s8        |
|-------+------------+-----------|
| s6    | E → ( L ). | reduce 2  |
|-------+------------+-----------|
| s7    | L → E.     | reduce 4  |
|-------+------------+-----------|
| s8    | L → L,.E   | s9        |
|       | E → .( L ) | s3        |
|       | E → .x     | s2        |
|-------+------------+-----------|
| s9    | L → L, E.  | reduce 5  |

*** Goto Graph / Transition Diagram

#+begin_example
1.
 -------------        2.             8.                   9.
| S  → .E $   |  x    --------   x   ------------    E   -----------
| E  → .( L ) |----->| E → x. |<----| L → L,.E   |----->| L → L, E. |
| E  → .x     |-+     --------      | E → .( L ) |       -----------
 -------------  |    3.             | E → .x     |
     S |      ( |     ------------   ------------
4.     V        +--->| E → (.L )  | ( |     ^
 ------------        | L → .E     |<--+     | ,
| S → E.$    |       | L → .L, E  |         |       5.
 ------------        | E → .( L ) |  L    -----------
                     | E → .x     |----->| E → ( L.) |
                      ------------       | L → L., E |
                          |               -----------
                        E |                 |
                          V   7.            | )
                       --------             V        6.
                      | L → E. |          ------------
                       --------          | E → ( L ). |
                                          ------------
#+end_example

** LR(1) Parsing

The complete of canonical form of *LR(1)* parsing depends on the *LR(1)* automaton.
The *LR(1)* automaton is like the *LR(0)* automaton, except that each item is annotated with
the set of tokens that could potentially follow it, given the current state. This set is known
as the *lookahead* of the item. The lookahead is always a subset of the *FOLLOW* of the
relevant non-terminal.

- For an item like *A → α.B* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead of *{L}*.

- For an item like *A → α.Bβ* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead as follows:

  - If *β* cannot produce *ε*, the lookahead is *FIRST(β)*.
  - If *β* can produce *ε*, the lookahead is *FIRST(β) ∪ {L}*

** Shift-Reduce Parsing Example

*** LR(1) Grammar

| number | rule | production |
|--------+------+------------|
|      0 | S    | E $        |
|      1 | E    | T E'       |
|      2 | E'   | + T E'     |
|      3 | E'   | ε          |
|      4 | T    | 1          |

*** FIRST Table

| non-terminal | first  |
|--------------+--------|
| S            | {1}    |
| E            | {1}    |
| E'           | {+, ε} |
| T            | {1}    |

*** LR(1) Closure Table

| goto        | kernel                 | state | closure                                                  |
|-------------+------------------------+-------+----------------------------------------------------------|
|             | [ S → .E, $ ]          |     0 | [ S → .E, $ ], [ E → .T E', $ ], [ T → .1, +/$ ]         |
| goto(0, E)  | [ S → E., $ ]          |     1 | [ S → E., $ ]                                            |
| goto(0, T)  | [ E → T.E', $ ]        |     2 | [ E → T.E', $ ], [ E' → .+ T E', $ ], [ E' → ., $ ]      |
| goto(0, 1)  | [ T → 1., +/$ ]        |     3 | [ T → 1., +/$ ]                                          |
| goto(2, E') | [ E → T E' ., $ ]      |     4 | [ E → T E'., $ ]                                         |
| goto(2, +)  | [ E' → +.T E', $ ]     |     5 | [ E' → +.T E', $ ], [ T → .1, +/$ ]                      |
| goto(5, T)  | [ E' → + T.E', $ ]     |     6 | [ E' → + T.E', $ ], [ E' → .+ T E', $ ], [ E' → ., $ ]   |
| goto(5, 1)  | [ T → 1., +/$ ]        |     3 |                                                          |
| goto(6, E') | [ E' → + T E' ., $ ]   |     7 | [ E' → + T E' ., $ ]                                     |
| goto(6, +)  | [ E' → +.T E', $ ]     |     5 |                                                          |

*** LR Table: Action and Goto

| state | +  | 1  | $      | S | E | E' | T |
|-------+----+----+--------+---+---+----+---|
|     0 |    | s3 |        |   | 1 |    | 2 |
|     1 |    |    | accept |   |   |    |   |
|     2 | s5 |    | r3     |   |   |  4 |   |
|     3 | r4 |    | r4     |   |   |    |   |
|     4 |    |    | r1     |   |   |    |   |
|     5 |    | s3 |        |   |   |    | 6 |
|     6 | s5 |    | r3     |   |   |  7 |   |
|     7 |    |    | r2     |   |   |    |   |

*** Stack Trace: ~1 + 1~

| step | stack                      | input   | action |
|------+----------------------------+---------+--------|
|    1 | 0,                         | 1 + 1 $ | s3     |
|    2 | 0, 1, 3                    | + 1 $   | r4     |
|    3 | 0, T                       | + 1 $   | 2      |
|    4 | 0, T, 2                    | + 1 $   | s5     |
|    5 | 0, T, 2, +, 5              | 1 $     | s3     |
|    6 | 0, T, 2, +, 5, 1, 3        | $       | r4     |
|    7 | 0, T, 2, +, 5, T           | $       | 6      |
|    8 | 0, T, 2, +, 5, T, 6        | $       | r3     |
|    9 | 0, T, 2, +, 5, T, 6, E'    | $       | 7      |
|   10 | 0, T, 2, +, 5, T, 6, E', 7 | $       | r2     |
|   11 | 0, T, 2, E'                | $       | 4      |
|   12 | 0, T, 2, E', 4             | $       | r1     |
|   13 | 0, E                       | $       | 1      |
|   14 | 0, E, 1                    | $       | accept |

** LALR Parsing

The main downside to *LR(1)* parsing is that the *LR(1)* automaton can be many times larger
than an *LR(0)* automaton. *Lookahead LR* parsing is the practical answer to this problem.
To construct an *LALR* parser, the states of an *LR(1)* automaton with the same *core* must
be merged. The *core* of a state is simply the body of an *item*, ignoring lookahead.
The resulting *LALR* automaton has the same number of states as the *LR(0)* automaton, but
has more precise lookahead information available for each item.

*** LR(1) States

| state 1    | LA     | state 2    | LA     |
|------------+--------+------------+--------|
| E → .E + T | {$, +} | E → .E + T | {), +} |
| E → .T     | {$, +} | E → .T     | {), +} |

*** LALR State

| state      | LA        |
|------------+-----------|
| E → .E + T | {$, ), +} |
| E → .T     | {$, ), +} |
