* LR Grammars and Parsing

*Introduction to Compilers and Language Design*, Douglas Thain

*LR Parsing*, Wikipedia

** Actions

- L :: left-to-right parse

- R :: Right-most derivation. Expands the right-most nonterminal. Reductions in reverse order,
  from the leaves to the root.

- (k) :: *k* symbols of lookahead.

** Algorithm

- *Input*: A LR-Parser for an unambiguous context-free grammar *G* over an alphabet *Σ* and a
  word *w ∈ Σ\star{}*.

- *Output*: An error if *w ∉ L(G)* or a rightmost derivation for *w* otherwise.

  - Set the cursor to the rightmost symbol of *w$*.
  - Push the initial state *s_{0}* on top of the empty stack.
  - Repeat
    - Let *s* be the state on top of the stack.
    - Let *a* be the current symbol in *w$*.
    - If *action[s, a]* = *shift s_{n}* then
      - Push *a* on top of the stack.
      - Push *s_{n}* on top of the stack.
      - Advance the cursor to the next symbol on the right in *w$*.
    - if *action[s, a]* = *reduce A → β* then
      - pop | *β* | symbols off the stack.
      - let *s_{n}* be the state on top of the stack.
      - push *A* on top of the stack.
      - push *goto[s, a]* on top of the stack.
    - if *action[s, a]* = *accept* then
      - return success
    - else
      - return error

#+begin_example
# === parser-driving psuedo code ===

stack.push($, 0) # <----- always push a symbol/state pair
lookahead = scan()
loop:
    s = stack.top() # <-- always a state
    switch(action[s][lookahead])
    case shift sn:
        stack.push(lookahead, sn)
        lookahead = scan()
    case reduce A → β:
        stack.pop(β)
        sn = stack.top()
        stack.push(A, goto[sn][A])
    case accept:
        return success
    default:
        return error
#+end_example

The difference between *SLR*, *LALR*, and *LR* parsers is in the tables that they use. Different
tables use different techniques to determine when to *reduce*, and, if there is more than one grammar
rule with the same right-hand side, which left-hand-side nonterminal to push.

Two types of conflict can appear in an *LR* grammar:

| shift-reduce | reduce-reduce |
|--------------+---------------|
| T → id.( E ) | S → id( E ).  |
| T → id.      | E → id( E ).  |

** LR(0) Automaton

- LR(0) Automaton :: All the possible rules that are currently under consideration by a shift-reduce
  parser. Each set of rules, or box, represents a state in the machine, connected by transitions from
  both terminals to non-terminals in a grammar. Also known as the *canonical collection* or
  *compact finite state machine* of a grammar.

- Items :: The contents of each state, which are rules augmented by a *marker*.  In general, item
  *X → γ . δ* means *γ* is at the top of the stack. At the head of the input there is a string
  derivable from *δ*.

- Marker(.) :: Marks the parser's current position in a rule.

- Kernel :: *State 0* created by taking the production for the start symbol *S → E* and adding a marker
  at the beginning of the right-hand side.

- Closure ::  Any set of items can be extended by recursively adding all the appropriate items until
  all non-terminals preceded by markers are accounted for. The minimal extension is called the closure
  of an item set.

*** Grammar

| rule | production |
|------+------------|
|    1 | S → E $    |
|    2 | E → E + T  |
|    3 | E → T      |
|    4 | T → id(E)  |
|    5 | T → id     |

*** Configurating Sets

1. If state contains item *X → γ.$* then *accept*.
2. If state contains item *X → γ.* then *reduce* *X → γ*.
3. If state *i* has edge to *j* with terminal, then *shift*.

| state | set        | successor |
|-------+------------+-----------|
| s0    | S → .E $   | s1        |
|       | E → .E + T | s1        |
|       | E → .T     | s8        |
|       | T → .id(E) | s4        |
|       | T → .id    | s4        |
|-------+------------+-----------|
| s1    | S → E.$    | accept    |
|       | E → E.+ T  | s2        |
|-------+------------+-----------|
| s2    | E → E +.T  | s3        |
|       | T → .id(E) | s4        |
|       | T → .id    | s4        |
|-------+------------+-----------|
| s3    | E → E + T. | r2        |
|-------+------------+-----------|
| s4    | T → id.(E) | s5        |
|       | T → id.    | r5        |
|-------+------------+-----------|
| s5    | T → id(.E) | s6        |
|       | E → .E + T | s6        |
|       | E → .T     | s8        |
|       | T → .id(E) | s4        |
|       | T → .id    | s4        |
|-------+------------+-----------|
| s6    | T → id(E.) | s7        |
|       | E → E.+ T  | s2        |
|-------+------------+-----------|
| s7    | T → id(E). | r5        |
|-------+------------+-----------|
| s8    | E → T.     | r3        |


*** Goto Graph / Transition Diagram

#+begin_example
    start              accept $
      |                   ^
      V                   |
 ------------        -----------        ------------
| state 0    |      | state 1   |      | state 2    |
|------------|  E   |-----------|  +   |------------|
| S → .E $   |----->| S → E.$   |----->| E → E +.T  |
| E → .E + T |      | E → E.+ T |      | T → .id(E) |
| E → .T     |       -----------       | T → .id    |
| T → .id(E) |                          ------------
| T → .id    |                          |     ^    |    T
 ------------             +-------------+     |    +---------+
  |      |             id |                   |              |
  |      | id             |                   |              V
  |      V                |   ------------    |         ------------
  |   ------------ <------+  | state 5    |   |        | state 3    |
  |  | state 4    |    id    |------------|   |        |------------|
  |  |------------|<---------| T → id(.E) |   |        | E → E + T. |
  |  | T → id.(E) |    (     | E → .E + T |   | +       ------------
  |  | T → id.    |--------->| E → .T     |   |
  |   ------------           | T → .id(E) |   |
  |                          | T → .id    |   |
  |                           ------------    |
  | T    ---------            |         |     |
  +---->| state 8 |     T     |         | E   |
        |---------|<----------+         V     |
        | E → T.  |                   ------------
         ---------                   | state 6    |
                                     |------------|
                                     | T → id(E.) |
                                     | E → E.+ T  |
                                      ------------
                                           |
                                           | )
                                           V
                                      ------------
                                     | state 7    |
                                     |------------|
                                     | T → id(E). |
                                      ------------
#+end_example

*** Goto-Action Table

| state | E  | T  | id | (  | )  | +  | $  |
|-------+----+----+----+----+----+----+----|
|     0 | g1 | g8 | s4 |    |    |    |    |
|     1 |    |    |    |    |    | s2 | r1 |
|     2 |    | g3 | s4 |    |    |    |    |
|     3 |    |    |    |    | r2 | r2 | r2 |
|     4 |    |    |    | s5 | r5 | r5 | r5 |
|     5 | g6 | g8 | s4 |    |    |    |    |
|     6 |    |    |    |    | s7 | s2 |    |
|     7 |    |    |    |    | r4 | r4 | r4 |
|     8 |    |    |    |    | r3 | r3 | r3 |

** LR(1) Parsing

The complete of canonical form of *LR(1)* parsing depends on the *LR(1)* automaton.
The *LR(1)* automaton is like the *LR(0)* automaton, except that each item is annotated with
the set of tokens that could potentially follow it, given the current state. This set is known
as the *lookahead* of the item. The lookahead is always a subset of the *FOLLOW* of the
relevant non-terminal.

- For an item like *A → α.B* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead of *{L}*.

- For an item like *A → α.Bβ* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead as follows:

  - If *β* cannot produce *ε*, the lookahead is *FIRST(β)*.
  - If *β* can produce *ε*, the lookahead is *FIRST(β) ∪ {L}*

** Shift-Reduce Parsing For LR(1) Example

*** Grammar

| rule | production  |
|------+-------------|
|    0 | S → E $     |
|    1 | E → T E'    |
|    2 | E' → + T E' |
|    3 | E' → ε      |
|    4 | T → 1       |

*** FIRST Table

| non-terminal | first    |
|--------------+----------|
| S            | { 1 }    |
| E            | { 1 }    |
| E'           | { +, ε } |
| T            | { 1 }    |

*** Closure Table

| goto        | kernel               | state | closure                                                |
|-------------+----------------------+-------+--------------------------------------------------------|
|             | [ S → .E, $ ]        |     0 | [ S → .E, $ ], [ E → .T E', $ ], [ T → .1, + $ ]       |
| goto(0, E)  | [ S → E., $ ]        |     1 | [ S → E., $ ]                                          |
| goto(0, T)  | [ E → T.E', $ ]      |     2 | [ E → T.E', $ ], [ E' → .+ T E', $ ], [ E' → ., $ ]    |
| goto(0, 1)  | [ T → 1., + $ ]      |     3 | [ T → 1., + $ ]                                        |
| goto(2, E') | [ E → T E' ., $ ]    |     4 | [ E → T E'., $ ]                                       |
| goto(2, +)  | [ E' → +.T E', $ ]   |     5 | [ E' → +.T E', $ ], [ T → .1, + $ ]                    |
| goto(5, T)  | [ E' → + T.E', $ ]   |     6 | [ E' → + T.E', $ ], [ E' → .+ T E', $ ], [ E' → ., $ ] |
| goto(5, 1)  | [ T → 1., + $ ]      |     3 |                                                        |
| goto(6, E') | [ E' → + T E' ., $ ] |     7 | [ E' → + T E' ., $ ]                                   |
| goto(6, +)  | [ E' → +.T E', $ ]   |     5 |                                                        |

*** Action and Goto Table

| state | +  | 1  | $      | S | E | E' | T |
|-------+----+----+--------+---+---+----+---|
|     0 |    | s3 |        |   | 1 |    | 2 |
|     1 |    |    | accept |   |   |    |   |
|     2 | s5 |    | r3     |   |   |  4 |   |
|     3 | r4 |    | r4     |   |   |    |   |
|     4 |    |    | r1     |   |   |    |   |
|     5 |    | s3 |        |   |   |    | 6 |
|     6 | s5 |    | r3     |   |   |  7 |   |
|     7 |    |    | r2     |   |   |    |   |

*** Stack Trace: ~1 + 1~

*Side Note*: ~symbol~ and ~state~ are often combined into a single stack of symbol-state pairs.

| symbol          | state             | input   | action |
|-----------------+-------------------+---------+--------|
|                 | [ 0 ]             | 1 + 1 $ | s3     |
| [ 1 ]           | [ 0, 3 ]          | + 1 $   | r4     |
| [ T ]           | [ 0 ]             | + 1 $   | 2      |
| [ T ]           | [ 0, 2 ]          | + 1 $   | s5     |
| [ T, + ]        | [ 0, 2, 5 ]       | 1 $     | s3     |
| [ T, +, 1 ]     | [ 0, 2, 5, 3 ]    | $       | r4     |
| [ T, +, T ]     | [ 0, 2, 5 ]       | $       | 6      |
| [ T, +, T ]     | [ 0, 2, 5, 6 ]    | $       | r3     |
| [ T, +, T, E' ] | [ 0, 2, 5, 6]     | $       | 7      |
| [ T, +, T, E' ] | [ 0, 2, 5, 6, 7 ] | $       | r2     |
| [ T, E' ]       | [ 0, 2 ]          | $       | 4      |
| [ T, E' ]       | [ 0, 2, 4 ]       | $       | r1     |
| [ E ]           | [ 0 ]             | $       | 1      |
| [ E ]           | [ 0, 1 ]          | $       | accept |

** LALR Parsing

The main downside to *LR(1)* parsing is that the *LR(1)* automaton can be many times larger
than an *LR(0)* automaton. *Lookahead LR* parsing is the practical answer to this problem.
To construct an *LALR* parser, the states of an *LR(1)* automaton with the same *core* must
be merged. The *core* of a state is simply the body of an *item*, ignoring lookahead.
The resulting *LALR* automaton has the same number of states as the *LR(0)* automaton, but
has more precise lookahead information available for each item.

*** LR(1) States

| state 1    | LA       | state 2    | LA       |
|------------+----------+------------+----------|
| E → .E + T | { $, + } | E → .E + T | { ), + } |
| E → .T     | { $, + } | E → .T     | { ), + } |

*** LALR State

| state      | LA          |
|------------+-------------|
| E → .E + T | { $, ), + } |
| E → .T     | { $, ), + } |

** Table Construction

*** Finding the Reachable Item Sets

1. Take the subset, *S*, of all items in the current item set where there is a dot in front of the symbol
   of interest, *x*.

2. For each item in *S*, move the dot to the right of *x*.

3. Close the resulting set of items.

*** Constructing Action and Goto

1. The columns for non-terminals are copied to the goto table.
   
2. The columns for the terminals are copied to the action table as shift actions.
   
3. An extra column for *$* (eof) is added to the action table. An *accept* action is added to the *$*
   column for each item set that contains an item of the form *S → w.$*.
   
4. If an item set *i* contains an item of the form *A → w.* and *A → w* is rule *m* with *m > 0* then
   the row for state *i* in the action table is completely filled with the reduce action *r_{m}*.
