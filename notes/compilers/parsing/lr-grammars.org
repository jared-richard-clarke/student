* LR Grammars and Parsing

*Introduction to Compilers and Language Design*, Douglas Thain

*LR Parsing*, Wikipedia

** Actions

- L :: left-to-right parse

- R :: Right-most derivation. Expands the right-most nonterminal. Reductions in reverse order,
  from the leaves to the root.

- (k) :: *k* symbols of lookahead.

** Algorithm

- *Input*: A LR-Parser for an unambiguous context-free grammar *G* over an alphabet *Σ* and a
  word *w ∈ Σ\star{}*.

- *Output*: An error if *w ∉ L(G)* or a rightmost derivation for *w* otherwise.

  - Set the cursor to the rightmost symbol of *w$*.
  - Push the initial state *s_{0}* on top of the empty stack.
  - Repeat
    - Let *s* be the state on top of the stack.
    - Let *a* be the current symbol in *w$*.
    - If *action[s, a]* = *shift s_{n}* then
      - Push *a* on top of the stack.
      - Push *s_{n}* on top of the stack.
      - Advance the cursor to the next symbol on the right in *w$*.
    - if *action[s, a]* = *reduce A → β* then
      - pop | *β* | symbols off the stack. ( For *X → A B C*, pop *C*, *B*, and *A* )
      - let *s_{n}* be the state on top of the stack.
      - push *A* on top of the stack.
      - push *goto[s, a]* on top of the stack.
    - if *action[s, a]* = *accept* then
      - return success
    - else
      - return error

#+begin_example
# === parser-driving psuedo code ===

stack.push($, 0) # <----- always push a symbol/state pair
lookahead = scan()
loop:
    s = stack.top() # <-- always a state
    switch(action[s][lookahead])
    case shift sn:
        stack.push(lookahead, sn)
        lookahead = scan()
    case reduce A → β:
        stack.pop(β)
        sn = stack.top()
        stack.push(A, goto[sn][A])
    case accept:
        return success
    default:
        return error
#+end_example

The difference between *SLR*, *LALR*, and *LR* parsers is in the tables that they use. Different
tables use different techniques to determine when to *reduce*, and, if there is more than one grammar
rule with the same right-hand side, which left-hand-side nonterminal to push.

Two types of conflict can appear in an *LR* grammar:

| shift-reduce | reduce-reduce |
|--------------+---------------|
| T → id.( E ) | S → id( E ).  |
| T → id.      | E → id( E ).  |

** Parse Tree

#+begin_example
           ^
           |             9
           |      +------+------+
           |      4      |      8
reductions | +----+----+ | +----+----+
           | |    3    | | |    7    |
           | | 1--+--2 | | | 5--+--6 |
           | | |  |  | | | | |  |  | |
           | ( 3  +  4 ) + ( 5  +  6 )
           <---------------------------
                       shifts
#+end_example

** LR(0) Automaton

- LR(0) Automaton :: All the possible rules that are currently under consideration by a shift-reduce
  parser. Each set of rules, or box, represents a state in the machine, connected by transitions from
  both terminals to non-terminals in a grammar. Also known as the *canonical collection* or
  *compact finite state machine* of a grammar.

- Item :: The contents of each state, which are rules augmented by a *marker*.  In general, item
  *X → γ . δ* means *γ* is at the top of the stack. At the head of the input there is a string
  derivable from *δ*.

- Marker(.) :: Marks the parser's current position in a rule.

- Kernel :: *State 0* created by taking the production for the start symbol *S → E* and adding a marker
  at the beginning of the right-hand side.

- Closure ::  Any set of items can be extended by recursively adding all the appropriate items until
  all non-terminals preceded by markers are accounted for. The minimal extension is called the closure
  of an item set.
** SLR Parser Example

An *SLR* grammar is one that has no *shift-reduce* or *reduce-reduce* conflicts when examining its
*FOLLOW* sets.

*** Grammar

| rule | production  |
|------+-------------|
|    0 | S → E $     |
|    1 | E → T E'    |
|    2 | E' → + T E' |
|    3 | E' → ε      |
|    4 | T → 1       |

*** Configurating Sets

Find the item set that each symbol *x ∈ {1, E, T}* closes over.

1. Take the subset, *S*, of all items in the current item set where there is a dot in front of the symbol
   of interest, *x*.

2. For each item in *S*, move the dot to the right of *x*.

3. Close the resulting set of items.

| state | set              | successor |
|-------+------------------+-----------|
| s0    | S → .E $         | s1        |
|       | *+* E → .T E'    | s2        |
|       | *+* T → .1       | s3        |
|-------+------------------+-----------|
| s1    | S → E.$          | accept    |
|-------+------------------+-----------|
| s2    | E → T.E'         | s4        |
|       | *+* E' → .+ T E' | s5        |
|       | *+* E' → .       | r3        |
|-------+------------------+-----------|
| s3    | T → 1.           | r4        |
|-------+------------------+-----------|
| s4    | E → T E'.        | r1        |
|-------+------------------+-----------|
| s5    | E' → +.T E'      | s6        |
|       | *+* T → .1       | s3        |
|-------+------------------+-----------|
| s6    | E' → + T.E'      | s7        |
|       | *+* E' → .+ T E' | s5        |
|       | *+* E' → .       | r3        |
|-------+------------------+-----------|
| s7    | E' → + T E'.     | r2        |

*** Goto Graph / Transition Diagram

1. If state contains item *X → γ.$* then *accept*.
2. If state contains item *X → γ.* then *reduce* *X → γ*.
3. If state *i* has edge to *j* with terminal, then *shift*.

#+begin_example
                                    1
           +-------------------------------------------------+
           |                                                 |
 --------------         ---------                            |
| state 0      |   E   | state 1 |                           |
|--------------|------>|---------|                           |
| S → .E $     |       | S → E.$ |                           |
| + E → .T E'  |   T    ---------                            |
| + T → .1     |---+    ----------------                     |
 --------------    |   | state 2        |                    |
                   +-->|----------------|                    |
                       | E → T.E'       |       -----------  |
  --------------       | + E' → .+ T E' |  E'  | state 4   | |
 | state 7      |      | + E' → .       |----->|-----------| |
 |--------------|       ----------------       | E → T E'. | |
 | E' → + T E'. |             |                 -----------  |
  --------------              | +                            |
       ^                      |                              |
       | E'                   |                              |
       |                      V                              |
  ----------------         -------------         ---------   |
 | state 6        |   T   | state 5     |   1   | state 3 |  |
 |----------------|<------|-------------|------>|---------|<-+
 | E' → + T.E'    |   +   | E' → +.T E' |       | T → 1.  |
 | + E' → .+ T E' |------>| + T → .1    |        ---------
 | + E' → .       |        -------------
  ----------------
#+end_example

*** First-Follow Table

| non-terminal | first    | follow   |
|--------------+----------+----------|
| S            | { 1 }    | { $ }    |
| E            | { 1 }    | { $ }    |
| E'           | { +, ε } | { $ }    |
| T            | { 1 }    | { +, $ } |

*** Goto-Action Table

Each parser state has its own row. Each possible symbol has its own column. Some state-symbol
combinations are impossible for valid input streams. These blank cells trigger syntax errors.

| state | E | E' | T | +  | 1  | $      |
|-------+---+----+---+----+----+--------|
|     0 | 1 |    | 2 |    | s3 |        |
|     1 |   |    |   |    |    | accept |
|     2 |   |  4 |   | s5 |    | r3     |
|     3 |   |    |   | r4 |    | r4     |
|     4 |   |    |   |    |    | r1     |
|     5 |   |    | 6 |    | s3 |        |
|     6 |   |  7 |   | s5 |    | r3     |
|     7 |   |    |   |    |    | r2     |

*** Stack Trace: ~1 + 1~

| state           | symbol        | input   | action |
|-----------------+---------------+---------+--------|
| [0]             | []            | 1 + 1 $ | s3     |
| [0, 3]          | [1]           | + 1 $   | r4     |
| [0]             | [T]           | + 1 $   | 2      |
| [0, 2]          | [T]           | + 1 $   | s5     |
| [0, 2, 5]       | [T, +]        | 1 $     | s3     |
| [0, 2, 5, 3]    | [T, +, 1]     | $       | r4     |
| [0, 2, 5]       | [T, +, T]     | $       | 6      |
| [0, 2, 5, 6]    | [T, +, T]     | $       | r3     |
| [0, 2, 5, 6]    | [T, +, T, E'] | $       | 7      |
| [0, 2, 5, 6, 7] | [T, +, T, E'] | $       | r2     |
| [0, 2]          | [T, E']       | $       | 4      |
| [0, 2, 4]       | [T, E']       | $       | r1     |
| [0]             | [E]           | $       | 1      |
| [0, 1]          | [E]           | $       | accept |

** LR(1) Parsing

The complete of canonical form of *LR(1)* parsing depends on the *LR(1)* automaton.
The *LR(1)* automaton is like the *LR(0)* automaton, except that each item is annotated with
the set of tokens that could potentially follow it, given the current state. This set is known
as the *lookahead* of the item. The lookahead is always a subset of the *FOLLOW* of the
relevant non-terminal.

- For an item like *A → α.B* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead of *{L}*.

- For an item like *A → α.Bβ* with a lookahead of *{L}*, add new rules like *B → .γ* with a
  lookahead as follows:

  - If *β* cannot produce *ε*, the lookahead is *FIRST(β)*.
  - If *β* can produce *ε*, the lookahead is *FIRST(β) ∪ {L}*

** LR(1) Parser Example

*** Grammar

| rule | production |
|------+------------|
|    0 | S → E $    |
|    1 | E → E * B  |
|    2 | E → E + B  |
|    3 | E → B      |
|    4 | B → 0      |
|    5 | B → 1      |

*** Configurating Sets

Find the item set that each symbol *x ∈ {0, 1, E, B}* closes over.

1. Take the subset, *S*, of all items in the current item set where there is a dot in front of the symbol
   of interest, *x*.

2. For each item in *S*, move the dot to the right of *x*.

3. Close the resulting set of items.

| state | set            | follow set |
|-------+----------------+------------|
| s0    | S → .E $       | $          |
|       | *+* E → .E * B | $, *, +    |
|       | *+* E → .E + B | $, *, +    |
|       | *+* E → .B     | $, *, +    |
|       | *+* B → 0      | $, *, +    |
|       | *+* B → 1      | $, *, +    |
|-------+----------------+------------|
| s1    | B → 0.         | $, *, +    |
|-------+----------------+------------|
| s2    | B → 1.         | $, *, +    |
|-------+----------------+------------|
| s3    | S → E.$        | $          |
|       | *+* E → E.* B  | $, *, +    |
|       | *+* E → E.+ B  | $, *, +    |
|-------+----------------+------------|
| s4    | E → B.         | $, *, +    |
|-------+----------------+------------|
| s5    | E → E *.B      | $, *, +    |
|       | *+* B → .0     | $, *, +    |
|       | *+* B → .1     | $, *, +    |
|-------+----------------+------------|
| s6    | E → E +.B      | $, *, +    |
|       | *+* B → .0     | $, *, +    |
|       | *+* B → .1     | $, *, +    |
|-------+----------------+------------|
| s7    | E → E * B.     | $, *, +    |

*** Goto-Action Table

| state | *  | +  | 0  | 1  | $      | E | B |
|-------+----+----+----+----+--------+---+---|
|     0 |    |    | s3 | s4 |        | 1 | 2 |
|     1 | s5 | s6 |    |    | accept |   |   |
|     2 | r3 | r3 |    |    | r3     |   |   |
|     3 | r4 | r4 |    |    | r4     |   |   |
|     4 | r5 | r5 |    |    | r5     |   |   |
|     5 |    |    | s3 | s4 |        |   | 7 |
|     6 |    |    | s3 | s4 |        |   | 8 |
|     7 | r1 | r1 |    |    | r1     |   |   |
|     8 | r2 | r2 |    |    | r2     |   |   |

*** Stack Trace: ~1 + 1~

| state        | symbol    | input   | action |
|--------------+-----------+---------+--------|
| [0]          | []        | 1 + 1 $ | s4     |
| [0, 4]       | [1]       | + 1 $   | r5     |
| [0]          | [B]       | + 1 $   | 2      |
| [0, 2]       | [B]       | + 1 $   | r3     |
| [0]          | [E]       | + 1 $   | 1      |
| [0, 1]       | [E]       | + 1 $   | s6     |
| [0, 1, 6]    | [E, +]    | 1 $     | s4     |
| [0, 1, 6, 4] | [E, +, 1] | $       | r5     |
| [0, 1, 6]    | [E, +, B] | $       | 8      |
| [0, 1, 6, 8] | [E, +, B] | $       | r2     |
| [0]          | [E]       | $       | 1      |
| [0, 1]       | [E]       | $       | accept |

** LALR Parsing

The main downside to *LR(1)* parsing is that the *LR(1)* automaton can be many times larger
than an *LR(0)* automaton. *Lookahead LR* parsing is the practical answer to this problem.
To construct an *LALR* parser, the states of an *LR(1)* automaton with the same *core* must
be merged. The *core* of a state is simply the body of an *item*, ignoring lookahead.
The resulting *LALR* automaton has the same number of states as the *LR(0)* automaton, but
has more precise lookahead information available for each item.

*** LR(1) States

| state 1    | LA       | state 2    | LA       |
|------------+----------+------------+----------|
| E → .E + T | { $, + } | E → .E + T | { ), + } |
| E → .T     | { $, + } | E → .T     | { ), + } |

*** LALR State

| state      | LA          |
|------------+-------------|
| E → .E + T | { $, ), + } |
| E → .T     | { $, ), + } |
