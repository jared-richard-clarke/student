* The Bison Parser Generator

*Introduction to Compilers and Language Design*, Douglas Thain

*Understanding C parsers generated by GNU Bison*, Satya Kiran Popuri

** ~expression.h~ and ~expression.c~

#+begin_src c
  // === data nodes ===
  typedef enum {
    EXPR_ADD,
    EXPR_SUBTRACT,
    EXPR_DIVIDE,
    EXPR_MULTIPLY,
    EXPR_VALUE
  } expr_t;

  struct expr {
    expr_t kind;
    struct expr *left;
    struct expr *right;
    int value;
  };

  struct expr * expr_create( expr_t kind, struct expr *left, struct expr *right ) {
    struct expr *e = malloc(sizeof(*e));
    e->kind = kind;
    e->value = 0;
    e->left = left;
    e->right = right;
    return e;
  }

  struct expr * expr_create_value( int value ) {
    struct expr *e = expr_create(EXPR_VALUE, 0, 0);
    e->value = value;
    return e;
  }

  // === evaluate: post-order traversal ===
  int expr_evaluate( struct expr *e ) {
    if (!e) {
      return 0;
    }
    int l = expr_evaluate(e->left);
    int r = expr_evaluate(e->right);

    switch(e->kind) {
    case EXPR_VALUE:
      return e->value;
    case EXPR_ADD:
      return l + r;
    case EXPR_SUBTRACT:
      return l - r;
    case EXPR_MULTIPLY:
      return l * r;
    case EXPR_DIVIDE:
      if (r == 0) {
        printf("error: divide by zero\n");
        exit(1);
      }
      return l / r;
    }
    return 0;
  }

  // === printing ===
  void expr_print( struct expr *e) {
    if (!e) {
      return;
    }
    printf("(");
    expr_print(e->left);

    switch(e->kind) {
    case EXPR_VALUE:
      printf("%d", e->value);
      break;
    case EXPR_ADD:
      printf("+");
      break;
    case EXPR_SUBTRACT:
      printf("-");
      break;
    case EXPR_MULTIPLY:
      printf("*");
      break;
    case EXPR_DIVIDE:
      printf("/");
      break;
    }

    expr_print(e->right);
    printf(")");
  }
#+end_src

** ~parser.bison~

#+begin_src c
  %{
  // C preamble
  #include "expression.h"
  #define YYSTYPE struct expr *
  struct expr * parser_result = 0;
  %}

  // declarations
  %token TOKEN_INT
  %token TOKEN_PLUS
  %token TOKEN_MINUS
  %token TOKEN_DIV
  %token TOKEN_LPAREN
  %token TOKEN_RPAREN
  %token TOKEN_SEMI
  %token TOKEN_ERROR

  %%
  // grammar rules
  program : expr TOKEN_SEMI
               { parser_result = $1; }
          ;

  expr : expr TOKEN_PLUS term
            { $$ = expr_create(EXPR_ADD, $1, $3); }
       | expr TOKEN_MINUS term
            { $$ = expr_create(EXPR_SUBTRACT, $1, $3); }
       | term
            { $$ = $1; }
       ;

  term : term TOKEN_MUL factor
            { $$ = expr_create(EXPR_MULTIPLY, $1, $3); }
       | term TOKEN_DIV factor
            { $$ = expr_create(EXPR_DIVIDE, $1, $3); }
       | factor
            { $$ = $1; }
       ;

  factor : TOKEN_MINUS factor
             { $$ = expr_create(EXPR_SUBTRACT, expr_create_value(0), $2); }
         | TOKEN_LPAREN expr TOKEN_RPAREN
             { $$ = $2; }
         | TOKEN_INT
             { $$ = expr_create_value(atoi(yytext)); }
         ;
  %%

  // C postamble
  int yyerror(char *s) {
      printf("parse error: %s\n", s);
      return 1;
  }
#+end_src

*** Compilation

Invoke Bison: ~bison --defines=token.h --output=parser.c parser.bison~.

~--output=parser.c~ directs Bison to write its code into file ~parser.c~ instead of ~yy.tab.c~.

#+begin_example
                 -------                  ----------
parser.bison -> | Bison | -> parser.c -> | compiler | -> parser.o
                 -------   /              ----------              \
                    V     /               ----------               \--------
                 token.h -> main.c ----> | compiler | -> main.o -> | linker | -> compiler.exe
                          \               ----------               /--------
                 ------    \              ----------              /
scanner.flex -> | flex | -> scanner.c -> | compiler | -> scanner.o
                 ------                   ----------
#+end_example

** Bison Internals

*** yytranslate

Maps token numbers returned by ~yylex()~ to Bison's internal number symbols.

#+begin_src c
  // YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.
  static const yytype_uint8 yytranslate[] =
  {
         0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
         2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
         2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
         2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
         6,     7,     2,     2,     4,     2,     2,     2,     2,     2,
         2,     2,     2,     2,     2,  // ... truncated
         2,     2,     2,     2,     2,     2,     1,     2
  };
#+end_src

*** yydefact

Lists default reduction rules for each state. ~0~ represents an error.

#+begin_src c
  // YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
  // STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
  // means the default is an error.
  static const yytype_uint8 yydefact[] =
  {
         0,     6,     8,     0,     3,     5,     9,     0,     1,     0,
         0,     7,     2,     4
  };
#+end_src

*** yydefgoto

Lists default *GOTOs* for each non-terminal symbol. It is only used after checking
with *yypgoto*.

#+begin_src c
  static const yytype_int8 yydefgoto[] =
  {
        -1,     3,     4,     5,     7
  };
#+end_src

*** yyr1

Symbol number of the left-hand side of each rule. Used at the time of a reduction to
find the next state.

#+begin_src c
  // YYR1[YYN] -- Symbol number of symbol that rule YYN derives.
  static const yytype_uint8 yyr1[] =
  {
         0,     8,     9,     9,    10,    10,    11,    11,    12,    12
  };
#+end_src

*** yyr2

Length of the right-hand side of each rule. Used at the time of reduction to pop the stack.

#+begin_src c
  // YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.
  static const yytype_uint8 yyr2[] =
  {
         0,     2,     3,     1,     3,     1,     1,     3,     0,     1
  };
#+end_src

*** yytable

A highly-compressed representation of the actions in each state. Negative entries represent
reductions. Negative infinity is for detecting errors.

#+begin_src c
  // YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
  // positive, shift that token.  If negative, reduce the rule which
  // number is the opposite.  If zero, do what YYDEFACT says.
  //  If YYTABLE_NINF, syntax error.

  #define YYTABLE_NINF -1

  static const yytype_uint8 yytable[] =
  {
         8,     1,     2,     9,    11,    10,     9,     6,    12,     0,
         0,     0,    13
  };
#+end_src

*** yypgoto

Accounts for non-default *GOTOs* for all non-terminal symbols.

#+begin_src c
  // YYPGOTO[NTERM-NUM].
  static const yytype_int8 yypgoto[] =
  {
        -5,     5,    -1,     2,    -5
  };
#+end_src

*** yypact

Directory into *yytable* indexed by state number. The displacements in *yytable* are indexed
by symbol number.

#+begin_src c
  #define YYPACT_NINF -5

  static const yytype_int8 yypact[] =
  {
        -4,    -5,    -4,     0,     1,    -5,     3,    -3,    -5,    -4,
        -4,    -5,     1,    -5
  };
#+end_src

*** yycheck

Guard table used to check the legal bounds within portions of *yytable*.

#+begin_src c
  // YYCHECK = a vector indexed in parallel with YYTABLE.  It indicates,
  // in a roundabout way, the bounds of the portion you are trying to
  // examine.
  static const yytype_int8 yycheck[] =
  {
         0,     5,     6,     3,     7,     4,     3,     2,     9,    -1,
        -1,    -1,    10
  };
#+end_src
