* Lexical Analysis

** Sources

| source                                          | author                  |
|-------------------------------------------------+-------------------------|
| *Introduction to Compilers and Language Design* | Douglas Thain           |
| *Basics of Compiler Design*                     | Torben Ægidius Mogensen |

** Regular Expressions

- alphabet :: A finite, non-empty set.

- symbols :: The elements of a set.

- string :: A finite sequence of symbols from an alphabet. Called a *string over an alphabet*.

  - If *Σ = {0, 1}* is an alphabet, then *001*, *1*, and *11* are all strings over *Σ*.

The collection of regular languages over an alphabet *Σ* is defined recursively as follows:

1. The empty language *Ø* is a regular language.

2. For each *a ∈ Σ*, the singleton language *{a}* is a regular language.

3. If *A* is a regular language, *A\star{}* is a regular language. Due to this, the empty string
   language *{ε}* is also regular.

4. If *A* and *B* are regular languages, then *A ∪ B* and *A • B* are regular languages.

5. No other languages over *Σ* are regular.

| precedence | name          | operator  |
|------------+---------------+-----------|
|          3 | alternation   | *\vert{}* |
|          2 | concatenation | *•*       |
|          1 | Kleene star   | *\star{}* |

*** Examples

| Regular Expression  | Language L(s)               |
|---------------------+-----------------------------|
| hello               | { hello }                   |
| d(o\vert{}i)g       | { dog, dig }                |
| moo*                | { mo, moo, mooo, ... }      |
| (moo)*              | { ε, moo, moomoo, ... }     |
| a(b\vert{}a)*a      | { aa, aaa, aba, aaaa, ... } |

*** Derived Syntax

| derivation | semantics   | base syntax                   |
|------------+-------------+-------------------------------|
| s?         | optional    | (s\vert{}ε)                   |
| s+         | one or more | ss*                           |
| [a-z]      | one of      | (a\vert{}b\vert{}...\vert{}z) |
| [^x]       | any except  | Σ - x                         |

*** Algebraic Properties

| property     | value                                     |
|--------------+-------------------------------------------|
| Associative  | a\vert{}(b\vert{}c) = (a\vert{}b)\vert{}c |
| Commutative  | a\vert{}b = b\vert{}a                     |
| Distributive | a(b\vert{}c) = ab\vert{}ac                |
| Idempotent   | a** = a*                                  |
|              | a*a* = a*                                 |
|              | a\vert{}a = a                             |

** Finite-State Automata

- finite-state automaton (FSA) :: A machine that takes as input a finite string of symbols from
  alphabet *Σ*. There is a finite set of *states* in which the machine can find itself. The state
  it is in before consuming input is called the *start state*. Some of the states are *accepting*
  or *final*. If the machine ends in such a state after completely consuming an input string, the
  string is said to be *accepted* by the machine.

- transition function :: Determines the next state according to the current state and symbol.

*** Non-deterministic Finite-State Automaton

*M* is specified by five components: *M = (Q, Σ, δ, q₀, F)* where

- Q :: A finite set of states.

- Σ :: Input alphabet, a finite set.

- δ : Q × (Σ ∪ {ε}) → P(Q) :: The transition function.

- q₀ ∈ Q :: The start state.

- F ⊆ Q :: A subset of *Q*. The states designated as *final* or *accepting* states.

*δ* is a transition function that takes *(state, input symbol)* pairs and maps each one to a set
of states. To say *δ(q, a) = { q₁, q₂, ..., qn }* means that if the machine is in state *q* and
the input symbol *a* is consumed, then the machine may move directly into any one of states
*q₁, q₂, ..., qn*. The function *δ* must also be defined for every *(state, ε)* pair, where state
may change but no input is consumed. The formal description of *δ* is *δ: Q × (Σ ∪ {ε}) → P(Q)*.

The language accepted by *M*, denoted *L(M)*, is the set of all strings *w ∈ Σ\star{}* that are
accepted by *M: L(M) = { w ∈ Σ\star{} | δ\star{}(q₀, w) ∩ F ≠ Ø }*.

*** Deterministic Finite-State Automaton

*M* is specified by five components: *M = (Q, Σ, δ, q₀, F)* where

- Q :: A finite set of states.

- Σ :: Input alphabet, a finite set.

- δ : Q × Σ → Q :: The transition function.

- q₀ ∈ Q :: The start state.

- F ⊆ Q :: A subset of *Q*. The states designated as *final* or *accepting* states.

*δ* is a transition function that takes *(state, symbol)* pairs and maps each one to a state:
*δ : Q × Σ → Q*. The declaration *δ(q, a) = qp* means that if a machine is in state *q* and
the input symbol *a* is consumed, then the machine will move to state *qp*. The function *δ*
must be a total function, meaning that *δ(q, a)* must be defined for every state *q* and every
input symbol *a*. Given the current input symbol, there is only one possible move the machine
can make.

The language accepted by *M*, denoted *L(M)*, is the set of all strings *w ∈ Σ\star{}* that are
accepted by *M: L(M) = { w ∈ Σ\star{} | δ\star{}(q₀, w) ∈ F }*.

*δ\star{}(q, w)* denotes the state that a DFA will be in if it starts in state *q* and consumes
input string *w*.

*** NFA to DFA Conversion

- epsilon closure :: *E(q)* of a state *q* in *Q* is the union of the set *{q}* with the
  set of all states that can be reached from *q* via one or more *ε* transitions.

If *R* is a set of states from *Q*, the epsilon closure *E(R)* is defined as the union of the epsilon
closures of all the states in *R*.

1. The set of states of the DFA is *P(Q)*, the power set of states *Q* in the original NFA.

2. The start state of the DFA is *E({q₀})*, where *q₀* is the original start state of the NFA.

3. For sets *R* in *P(Q)* and input characters *c ∈ Σ*, the transition function *δ_{n}* of the DFA is defined
   in terms of the transition function *δ* of the NFA by *δ_{n}(R,c) = U_{r ∈ R} E(δ(r,c))*.

The set of accepting states *F* of the DFA is defined to be the set of all states containing at least one
final state of the NFA.

#+begin_example
   === RE ===

   abab|abbb

   === NFA ===

    +->[2]-a->[4]-b->[6]-a->[8]-b-+
    |                             |
  >[1]                          [10]
    |                             |
    +->[3]-a->[5]-b->[7]-b->[9]-b-+

   === DFA ===
                              +-a->[8]-b-+
                              |          |
   >[1, 2, 3]-a->[4, 5]-b->[6, 7]       [10]
                              |          |
                              +-b->[9]-b-+
#+end_example

** REs to NFAs

#+begin_example
  === characters and epsilon ===

     a        ε
  >○-a->◎  >○-ε->◎

  === concatenation ===

  AB or A•B

  >○-A->○-ε->○-B->◎

  === alternation ===

  A|B

     ○-A->○
    /-ε    \-ε
  >○        ◎
    \-ε    /-ε
     ○-B->○

  === Kleene closure ===

  A*
        +-ε--+
        V    |
  >○-ε->○-A->○-ε->◎
   |              ^
   +------ε-------+
#+end_example
