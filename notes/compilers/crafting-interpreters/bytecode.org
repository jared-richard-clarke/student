* A Bytecode Virtual Machine

** Sources

| source                  | author      |
|-------------------------+-------------|
| *Crafting Interpreters* | Bob Nystrom |

** Main

#+begin_src c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  #include "common.h"
  #include "chunk.h"
  #include "debug.h"
  #include "vm.h"

  static void repl() {
    char line[1024];
    for (;;) {
      printf("> ");

      if (!fgets(line, sizeof(line), stdin)) {
        printf("\n");
        break;
      }

      interpret(line);
    }
  }

  static char* readFile(const char* path) {
    FILE* file = fopen(path, "rb");

    if (file == NULL) {
      fprintf(stderr, "Could not open file \"%s\".\n", path);
      exit(74);
    }

    fseek(file, 0L, SEEK_END);
    size_t fileSize = ftell(file);
    rewind(file);

    char* buffer = (char*)malloc(fileSize + 1);

    if (buffer == NULL) {
      fprintf(stderr, "Not enough memory to read \"%s\".\n", path);
      exit(74);
    }

    size_t bytesRead = fread(buffer, sizeof(char), fileSize, file);

    if (bytesRead < fileSize) {
      fprintf(stderr, "Could not read file \"%s\".\n", path);
      exit(74);
    }

    buffer[bytesRead] = '\0';

    fclose(file);
    return buffer;
  }

  static void runFile(const char* path) {
    char* source = readFile(path);
    InterpretResult result = interpret(source);
    free(source);

    if (result == INTERPRET_COMPILE_ERROR) {
      exit(65);
    }
    if (result == INTERPRET_RUNTIME_ERROR) {
      exit(70);
    }
  }

  int main(int argc, const char* argv[]) {
    initVM();

    if (argc == 1) {
      repl();
    } else if (argc == 2) {
      runFile(argv[1]);
    } else {
      fprintf(stderr, "Usage: clox [path]\n");
      exit(64);
    }

    freeVM();

    return 0;
  }
#+end_src

** Common

#+begin_src c
  #ifndef clox_common_h
  #define clox_common_h

  // Inclusion of "NULL", "size_t", "bool", and
  // explicitly-sized integers like "uint8_t".
  #include <stdbool.h>
  #include <stddef.h>
  #include <stdint.h>

  #endif
#+end_src

** Scanner

*** ~Scanner.h~

#+begin_src c
  #ifndef clox_scanner_h
  #define clox_scanner_h

  // Token Types
  typedef enum {
    // Single-character tokens.
    TOKEN_LEFT_PAREN, TOKEN_RIGHT_PAREN,
    TOKEN_LEFT_BRACE, TOKEN_RIGHT_BRACE,
    TOKEN_COMMA, TOKEN_DOT, TOKEN_MINUS, TOKEN_PLUS,
    TOKEN_SEMICOLON, TOKEN_SLASH, TOKEN_STAR,
    // One or two character tokens.
    TOKEN_BANG, TOKEN_BANG_EQUAL,
    TOKEN_EQUAL, TOKEN_EQUAL_EQUAL,
    TOKEN_GREATER, TOKEN_GREATER_EQUAL,
    TOKEN_LESS, TOKEN_LESS_EQUAL,
    // Literals.
    TOKEN_IDENTIFIER, TOKEN_STRING, TOKEN_NUMBER,
    // Keywords.
    TOKEN_AND, TOKEN_CLASS, TOKEN_ELSE, TOKEN_FALSE,
    TOKEN_FOR, TOKEN_FUN, TOKEN_IF, TOKEN_NIL, TOKEN_OR,
    TOKEN_PRINT, TOKEN_RETURN, TOKEN_SUPER, TOKEN_THIS,
    TOKEN_TRUE, TOKEN_VAR, TOKEN_WHILE,

    TOKEN_ERROR, TOKEN_EOF
  } TokenType;

  typedef struct {
    TokenType type;
    const char* start;
    int length;
    int line;
  } Token;

  void initScanner(const char* source);
  Token scanToken();

  #endif
#+end_src

*** ~Scanner.c~

#+begin_src c
  #include <stdio.h>
  #include <string.h>

  #include "common.h"
  #include "scanner.h"

  typedef struct {
    const char* start;
    const char* current;
    int line;
  } Scanner;

  Scanner scanner;

  void initScanner(const char* source) {
    scanner.start = source;
    scanner.current = source;
    scanner.line = 1;
  }

  static bool isAlpha(char c) {
    return (c >= 'a' && c <= 'z') ||
           (c >= 'A' && c <= 'Z') ||
            c == '_';
  }

  static bool isDigit(char c) {
    return c >= '0' && c <= '9';
  }

  static bool isAtEnd() {
    return *scanner.current == '\0';
  }

  static char advance() {
    scanner.current++;
    return scanner.current[-1];
  }

  static char peek() {
    return *scanner.current;
  }

  static char peekNext() {
    if (isAtEnd()) return '\0';
    return scanner.current[1];
  }

  static bool match(char expected) {
    if (isAtEnd()) return false;
    if (*scanner.current != expected) return false;
    scanner.current++;
    return true;
  }

  static Token makeToken(TokenType type) {
    Token token;
    token.type = type;
    token.start = scanner.start;
    token.length = (int)(scanner.current - scanner.start);
    token.line = scanner.line;
    return token;
  }

  static Token errorToken(const char* message) {
    Token token;
    token.type = TOKEN_ERROR;
    token.start = message;
    token.length = (int)strlen(message);
    token.line = scanner.line;
    return token;
  }

  static void skipWhitespace() {
    for (;;) {
      char c = peek();
      switch (c) {
      case ' ':
      case '\r':
      case '\t':
        advance();
        break;
      case '\n':
        scanner.line++;
        advance();
        break;
      case '/':
        if (peekNext() == '/') {
          // A comment goes until the end of the line.
          while (peek() != '\n' && !isAtEnd()) advance();
        } else {
          return;
        }
        break;
      default:
        return;
      }
    }
  }

  static TokenType checkKeyword(int start, int length,
                                const char* rest, TokenType type) {
    if (scanner.current - scanner.start == start + length &&
        memcmp(scanner.start + start, rest, length) == 0) {
      return type;
    }

    return TOKEN_IDENTIFIER;
  }

  static TokenType identifierType() {
    switch (scanner.start[0]) {
    case 'a': return checkKeyword(1, 2, "nd", TOKEN_AND);
    case 'c': return checkKeyword(1, 4, "lass", TOKEN_CLASS);
    case 'e': return checkKeyword(1, 3, "lse", TOKEN_ELSE);
    case 'f':
      if (scanner.current - scanner.start > 1) {
        switch (scanner.start[1]) {
        case 'a': return checkKeyword(2, 3, "lse", TOKEN_FALSE);
        case 'o': return checkKeyword(2, 1, "r", TOKEN_FOR);
        case 'u': return checkKeyword(2, 1, "n", TOKEN_FUN);
        }
      }
      break;
    case 'i': return checkKeyword(1, 1, "f", TOKEN_IF);
    case 'n': return checkKeyword(1, 2, "il", TOKEN_NIL);
    case 'o': return checkKeyword(1, 1, "r", TOKEN_OR);
    case 'p': return checkKeyword(1, 4, "rint", TOKEN_PRINT);
    case 'r': return checkKeyword(1, 5, "eturn", TOKEN_RETURN);
    case 's': return checkKeyword(1, 4, "uper", TOKEN_SUPER);
    case 't':
      if (scanner.current - scanner.start > 1) {
        switch (scanner.start[1]) {
        case 'h': return checkKeyword(2, 2, "is", TOKEN_THIS);
        case 'r': return checkKeyword(2, 2, "ue", TOKEN_TRUE);
        }
      }
      break;
    case 'v': return checkKeyword(1, 2, "ar", TOKEN_VAR);
    case 'w': return checkKeyword(1, 4, "hile", TOKEN_WHILE);
    }

    return TOKEN_IDENTIFIER;
  }

  static Token identifier() {
    while (isAlpha(peek()) || isDigit(peek())) advance();
    return makeToken(identifierType());
  }

  static Token number() {
    while (isDigit(peek())) advance();

    // Look for a fractional part.
    if (peek() == '.' && isDigit(peekNext())) {
      // Consume the ".".
      advance();

      while (isDigit(peek())) advance();
    }

    return makeToken(TOKEN_NUMBER);
  }

  static Token string() {
    while (peek() != '"' && !isAtEnd()) {
      if (peek() == '\n') scanner.line++;
      advance();
    }

    if (isAtEnd()) { return errorToken("Unterminated string."); }

    // The closing quote.
    advance();
    return makeToken(TOKEN_STRING);
  }

  Token scanToken() {
    skipWhitespace();
    scanner.start = scanner.current;

    if (isAtEnd()) { return makeToken(TOKEN_EOF); }
    char c = advance();
    if (isAlpha(c)) { return identifier(); }
    if (isDigit(c)) { return number(); }

    switch (c) {
    case '(': return makeToken(TOKEN_LEFT_PAREN);
    case ')': return makeToken(TOKEN_RIGHT_PAREN);
    case '{': return makeToken(TOKEN_LEFT_BRACE);
    case '}': return makeToken(TOKEN_RIGHT_BRACE);
    case ';': return makeToken(TOKEN_SEMICOLON);
    case ',': return makeToken(TOKEN_COMMA);
    case '.': return makeToken(TOKEN_DOT);
    case '-': return makeToken(TOKEN_MINUS);
    case '+': return makeToken(TOKEN_PLUS);
    case '/': return makeToken(TOKEN_SLASH);
    case '*': return makeToken(TOKEN_STAR);
    case '!':
      return makeToken(
                       match('=') ? TOKEN_BANG_EQUAL : TOKEN_BANG);
    case '=':
      return makeToken(
                       match('=') ? TOKEN_EQUAL_EQUAL : TOKEN_EQUAL);
    case '<':
      return makeToken(
                       match('=') ? TOKEN_LESS_EQUAL : TOKEN_LESS);
    case '>':
      return makeToken(
                       match('=') ? TOKEN_GREATER_EQUAL : TOKEN_GREATER);
    case '"': return string();
    }

    return errorToken("Unexpected character.");
  }
#+end_src

** Compiler

*** ~compiler.h~

#+begin_src c
  #ifndef clox_compiler_h
  #define clox_compiler_h

  #include "object.h"
  #include "vm.h"

  ObjFunction* compile(const char* source);
  void markCompilerRoots();

  #endif
#+end_src

*** ~compiler.c~

#+begin_src c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  #include "common.h"
  #include "compiler.h"
  #include "memory.h"
  #include "scanner.h"

  #ifdef DEBUG_PRINT_CODE
  #include "debug.h"
  #endif

  typedef struct {
    Token current;
    Token previous;
    bool hadError;
    bool panicMode;
  } Parser;

  typedef enum {
    PREC_NONE,
    PREC_ASSIGNMENT,  // =
    PREC_OR,          // or
    PREC_AND,         // and
    PREC_EQUALITY,    // == !=
    PREC_COMPARISON,  // < > <= >=
    PREC_TERM,        // + -
    PREC_FACTOR,      // * /
    PREC_UNARY,       // ! -
    PREC_CALL,        // . ()
    PREC_PRIMARY
  } Precedence;

  typedef void (*ParseFn)(bool canAssign);

  typedef struct {
    ParseFn prefix;
    ParseFn infix;
    Precedence precedence;
  } ParseRule;

  typedef struct {
    Token name;
    int depth;
    bool isCaptured;
  } Local;

  typedef struct {
    uint8_t index;
    bool isLocal;
  } Upvalue;

  typedef enum {
    TYPE_FUNCTION,
    TYPE_INITIALIZER,
    TYPE_METHOD,
    TYPE_SCRIPT
  } FunctionType;

  typedef struct Compiler {
    struct Compiler* enclosing;
    ObjFunction* function;
    FunctionType type;

    Local locals[UINT8_COUNT];
    int localCount;
    Upvalue upvalues[UINT8_COUNT];
    int scopeDepth;
  } Compiler;
  //< Local Variables compiler-struct
  //> Methods and Initializers class-compiler-struct

  typedef struct ClassCompiler {
    struct ClassCompiler* enclosing;
    bool hasSuperclass;
  } ClassCompiler;

  Parser parser;
  Compiler* current = NULL;
  ClassCompiler* currentClass = NULL;

  Chunk* compilingChunk;

  static Chunk* currentChunk() {
    return compilingChunk;
  }
  ,*/
  //> Calls and Functions current-chunk

  static Chunk* currentChunk() {
    return &current->function->chunk;
  }

  static void errorAt(Token* token, const char* message) {
    if (parser.panicMode) return;
    parser.panicMode = true;

    fprintf(stderr, "[line %d] Error", token->line);

    if (token->type == TOKEN_EOF) {
      fprintf(stderr, " at end");
    } else if (token->type == TOKEN_ERROR) {
      // Nothing.
    } else {
      fprintf(stderr, " at '%.*s'", token->length, token->start);
    }

    fprintf(stderr, ": %s\n", message);
    parser.hadError = true;
  }

  static void error(const char* message) {
    errorAt(&parser.previous, message);
  }

  static void errorAtCurrent(const char* message) {
    errorAt(&parser.current, message);
  }

  static void advance() {
    parser.previous = parser.current;

    for (;;) {
      parser.current = scanToken();
      if (parser.current.type != TOKEN_ERROR) break;

      errorAtCurrent(parser.current.start);
    }
  }

  static void consume(TokenType type, const char* message) {
    if (parser.current.type == type) {
      advance();
      return;
    }

    errorAtCurrent(message);
  }

  static bool check(TokenType type) {
    return parser.current.type == type;
  }

  static bool match(TokenType type) {
    if (!check(type)) return false;
    advance();
    return true;
  }

  static void emitByte(uint8_t byte) {
    writeChunk(currentChunk(), byte, parser.previous.line);
  }

  static void emitBytes(uint8_t byte1, uint8_t byte2) {
    emitByte(byte1);
    emitByte(byte2);
  }

  static void emitLoop(int loopStart) {
    emitByte(OP_LOOP);

    int offset = currentChunk()->count - loopStart + 2;
    if (offset > UINT16_MAX) error("Loop body too large.");

    emitByte((offset >> 8) & 0xff);
    emitByte(offset & 0xff);
  }

  static int emitJump(uint8_t instruction) {
    emitByte(instruction);
    emitByte(0xff);
    emitByte(0xff);
    return currentChunk()->count - 2;
  }

  static void emitReturn() {
    if (current->type == TYPE_INITIALIZER) {
      emitBytes(OP_GET_LOCAL, 0);
    } else {
      emitByte(OP_NIL);
    }

    emitByte(OP_RETURN);
  }

  static uint8_t makeConstant(Value value) {
    int constant = addConstant(currentChunk(), value);
    if (constant > UINT8_MAX) {
      error("Too many constants in one chunk.");
      return 0;
    }

    return (uint8_t)constant;
  }

  static void emitConstant(Value value) {
    emitBytes(OP_CONSTANT, makeConstant(value));
  }

  static void patchJump(int offset) {
    // -2 to adjust for the bytecode for the jump offset itself.
    int jump = currentChunk()->count - offset - 2;

    if (jump > UINT16_MAX) {
      error("Too much code to jump over.");
    }

    currentChunk()->code[offset] = (jump >> 8) & 0xff;
    currentChunk()->code[offset + 1] = jump & 0xff;
  }

  static void initCompiler(Compiler* compiler, FunctionType type) {
    compiler->enclosing = current;
    compiler->function = NULL;
    compiler->type = type;
    compiler->localCount = 0;
    compiler->scopeDepth = 0;
    compiler->function = newFunction();
    current = compiler;
    if (type != TYPE_SCRIPT) {
      current->function->name = copyString(parser.previous.start,
                                           parser.previous.length);
    }

    Local* local = &current->locals[current->localCount++];
    local->depth = 0;
    local->isCaptured = false;

    if (type != TYPE_FUNCTION) {
      local->name.start = "this";
      local->name.length = 4;
    } else {
      local->name.start = "";
      local->name.length = 0;
    }
  }

  static ObjFunction* endCompiler() {
    emitReturn();
    ObjFunction* function = current->function;

  #ifdef DEBUG_PRINT_CODE
    if (!parser.hadError) {
      disassembleChunk(currentChunk(), function->name != NULL
                       ? function->name->chars : "<script>");
    }
  #endif

    current = current->enclosing;
    return function;
  }

  static void beginScope() {
    current->scopeDepth++;
  }

  static void endScope() {
    current->scopeDepth--;

    while (current->localCount > 0 &&
           current->locals[current->localCount - 1].depth >
           current->scopeDepth) {
      if (current->locals[current->localCount - 1].isCaptured) {
        emitByte(OP_CLOSE_UPVALUE);
      } else {
        emitByte(OP_POP);
      }
      current->localCount--;
    }
  }

  static void expression();
  static void statement();
  static void declaration();
  static ParseRule* getRule(TokenType type);
  static void parsePrecedence(Precedence precedence);

  static uint8_t identifierConstant(Token* name) {
    return makeConstant(OBJ_VAL(copyString(name->start,
                                           name->length)));
  }

  static bool identifiersEqual(Token* a, Token* b) {
    if (a->length != b->length) return false;
    return memcmp(a->start, b->start, a->length) == 0;
  }

  static int resolveLocal(Compiler* compiler, Token* name) {
    for (int i = compiler->localCount - 1; i >= 0; i--) {
      Local* local = &compiler->locals[i];
      if (identifiersEqual(name, &local->name)) {
        if (local->depth == -1) {
          error("Can't read local variable in its own initializer.");
        }
        return i;
      }
    }

    return -1;
  }

  static int addUpvalue(Compiler* compiler, uint8_t index, bool isLocal) {
    int upvalueCount = compiler->function->upvalueCount;

    for (int i = 0; i < upvalueCount; i++) {
      Upvalue* upvalue = &compiler->upvalues[i];
      if (upvalue->index == index && upvalue->isLocal == isLocal) {
        return i;
      }
    }

    if (upvalueCount == UINT8_COUNT) {
      error("Too many closure variables in function.");
      return 0;
    }

    compiler->upvalues[upvalueCount].isLocal = isLocal;
    compiler->upvalues[upvalueCount].index = index;
    return compiler->function->upvalueCount++;
  }

  static int resolveUpvalue(Compiler* compiler, Token* name) {
    if (compiler->enclosing == NULL) return -1;

    int local = resolveLocal(compiler->enclosing, name);
    if (local != -1) {
      compiler->enclosing->locals[local].isCaptured = true;
      return addUpvalue(compiler, (uint8_t)local, true);
    }

    int upvalue = resolveUpvalue(compiler->enclosing, name);
    if (upvalue != -1) {
      return addUpvalue(compiler, (uint8_t)upvalue, false);
    }

    return -1;
  }

  static void addLocal(Token name) {
    if (current->localCount == UINT8_COUNT) {
      error("Too many local variables in function.");
      return;
    }

    Local* local = &current->locals[current->localCount++];
    local->name = name;
    local->depth = -1;
    local->isCaptured = false;
  }

  static void declareVariable() {
    if (current->scopeDepth == 0) return;

    Token* name = &parser.previous;
    for (int i = current->localCount - 1; i >= 0; i--) {
      Local* local = &current->locals[i];
      if (local->depth != -1 && local->depth < current->scopeDepth) {
        break;
      }

      if (identifiersEqual(name, &local->name)) {
        error("Already a variable with this name in this scope.");
      }
    }

    addLocal(*name);
  }

  static uint8_t parseVariable(const char* errorMessage) {
    consume(TOKEN_IDENTIFIER, errorMessage);

    declareVariable();
    if (current->scopeDepth > 0) return 0;

    return identifierConstant(&parser.previous);
  }

  static void markInitialized() {
    if (current->scopeDepth == 0) return;
    current->locals[current->localCount - 1].depth =
      current->scopeDepth;
  }

  static void defineVariable(uint8_t global) {
    if (current->scopeDepth > 0) {
      markInitialized();
      return;
    }

    emitBytes(OP_DEFINE_GLOBAL, global);
  }

  static uint8_t argumentList() {
    uint8_t argCount = 0;
    if (!check(TOKEN_RIGHT_PAREN)) {
      do {
        expression();
        if (argCount == 255) {
          error("Can't have more than 255 arguments.");
        }
        argCount++;
      } while (match(TOKEN_COMMA));
    }
    consume(TOKEN_RIGHT_PAREN, "Expect ')' after arguments.");
    return argCount;
  }

  static void and_(bool canAssign) {
    int endJump = emitJump(OP_JUMP_IF_FALSE);

    emitByte(OP_POP);
    parsePrecedence(PREC_AND);

    patchJump(endJump);
  }

  static void binary(bool canAssign) {
    TokenType operatorType = parser.previous.type;
    ParseRule* rule = getRule(operatorType);
    parsePrecedence((Precedence)(rule->precedence + 1));

    switch (operatorType) {
    case TOKEN_BANG_EQUAL:    emitBytes(OP_EQUAL, OP_NOT); break;
    case TOKEN_EQUAL_EQUAL:   emitByte(OP_EQUAL); break;
    case TOKEN_GREATER:       emitByte(OP_GREATER); break;
    case TOKEN_GREATER_EQUAL: emitBytes(OP_LESS, OP_NOT); break;
    case TOKEN_LESS:          emitByte(OP_LESS); break;
    case TOKEN_LESS_EQUAL:    emitBytes(OP_GREATER, OP_NOT); break;
    case TOKEN_PLUS:          emitByte(OP_ADD); break;
    case TOKEN_MINUS:         emitByte(OP_SUBTRACT); break;
    case TOKEN_STAR:          emitByte(OP_MULTIPLY); break;
    case TOKEN_SLASH:         emitByte(OP_DIVIDE); break;
    default: return; // Unreachable.
    }
  }

  static void call(bool canAssign) {
    uint8_t argCount = argumentList();
    emitBytes(OP_CALL, argCount);
  }

  static void dot(bool canAssign) {
    consume(TOKEN_IDENTIFIER, "Expect property name after '.'.");
    uint8_t name = identifierConstant(&parser.previous);

    if (canAssign && match(TOKEN_EQUAL)) {
      expression();
      emitBytes(OP_SET_PROPERTY, name);
    } else if (match(TOKEN_LEFT_PAREN)) {
      uint8_t argCount = argumentList();
      emitBytes(OP_INVOKE, name);
      emitByte(argCount);
    } else {
      emitBytes(OP_GET_PROPERTY, name);
    }
  }

  static void literal(bool canAssign) {
    switch (parser.previous.type) {
    case TOKEN_FALSE: emitByte(OP_FALSE); break;
    case TOKEN_NIL: emitByte(OP_NIL); break;
    case TOKEN_TRUE: emitByte(OP_TRUE); break;
    default: return; // Unreachable.
    }
  }

  static void grouping(bool canAssign) {
    expression();
    consume(TOKEN_RIGHT_PAREN, "Expect ')' after expression.");
  }

  static void number(bool canAssign) {
    double value = strtod(parser.previous.start, NULL);
    emitConstant(NUMBER_VAL(value));
  }

  static void or_(bool canAssign) {
    int elseJump = emitJump(OP_JUMP_IF_FALSE);
    int endJump = emitJump(OP_JUMP);

    patchJump(elseJump);
    emitByte(OP_POP);

    parsePrecedence(PREC_OR);
    patchJump(endJump);
  }

  static void string(bool canAssign) {
    emitConstant(OBJ_VAL(copyString(parser.previous.start + 1,
                                    parser.previous.length - 2)));
  }

  static void namedVariable(Token name, bool canAssign) {
    uint8_t getOp, setOp;
    int arg = resolveLocal(current, &name);
    if (arg != -1) {
      getOp = OP_GET_LOCAL;
      setOp = OP_SET_LOCAL;
    } else if ((arg = resolveUpvalue(current, &name)) != -1) {
      getOp = OP_GET_UPVALUE;
      setOp = OP_SET_UPVALUE;
    } else {
      arg = identifierConstant(&name);
      getOp = OP_GET_GLOBAL;
      setOp = OP_SET_GLOBAL;
    }
    if (canAssign && match(TOKEN_EQUAL)) {
      expression();
      emitBytes(setOp, (uint8_t)arg);
    } else {
      emitBytes(getOp, (uint8_t)arg);
    }
  }

  static void variable(bool canAssign) {
    namedVariable(parser.previous, canAssign);
  }

  static Token syntheticToken(const char* text) {
    Token token;
    token.start = text;
    token.length = (int)strlen(text);
    return token;
  }

  static void super_(bool canAssign) {
    if (currentClass == NULL) {
      error("Can't use 'super' outside of a class.");
    } else if (!currentClass->hasSuperclass) {
      error("Can't use 'super' in a class with no superclass.");
    }

    consume(TOKEN_DOT, "Expect '.' after 'super'.");
    consume(TOKEN_IDENTIFIER, "Expect superclass method name.");
    uint8_t name = identifierConstant(&parser.previous);

    namedVariable(syntheticToken("this"), false);
    if (match(TOKEN_LEFT_PAREN)) {
      uint8_t argCount = argumentList();
      namedVariable(syntheticToken("super"), false);
      emitBytes(OP_SUPER_INVOKE, name);
      emitByte(argCount);
    } else {
      namedVariable(syntheticToken("super"), false);
      emitBytes(OP_GET_SUPER, name);
    }
  }

  static void this_(bool canAssign) {
    if (currentClass == NULL) {
      error("Can't use 'this' outside of a class.");
      return;
    }

    variable(false);
  }

  static void unary(bool canAssign) {
    TokenType operatorType = parser.previous.type;

    parsePrecedence(PREC_UNARY);

    switch (operatorType) {
    case TOKEN_BANG: emitByte(OP_NOT); break;
    case TOKEN_MINUS: emitByte(OP_NEGATE); break;
    default: return; // Unreachable.
    }
  }

  ParseRule rules[] = {
    [TOKEN_LEFT_PAREN]    = {grouping, call,   PREC_CALL},
    [TOKEN_RIGHT_PAREN]   = {NULL,     NULL,   PREC_NONE},
    [TOKEN_LEFT_BRACE]    = {NULL,     NULL,   PREC_NONE}, // [big]
    [TOKEN_RIGHT_BRACE]   = {NULL,     NULL,   PREC_NONE},
    [TOKEN_COMMA]         = {NULL,     NULL,   PREC_NONE},
    [TOKEN_DOT]           = {NULL,     dot,    PREC_CALL},
    [TOKEN_MINUS]         = {unary,    binary, PREC_TERM},
    [TOKEN_PLUS]          = {NULL,     binary, PREC_TERM},
    [TOKEN_SEMICOLON]     = {NULL,     NULL,   PREC_NONE},
    [TOKEN_SLASH]         = {NULL,     binary, PREC_FACTOR},
    [TOKEN_STAR]          = {NULL,     binary, PREC_FACTOR},
    [TOKEN_BANG]          = {unary,    NULL,   PREC_NONE},
    [TOKEN_BANG_EQUAL]    = {NULL,     binary, PREC_EQUALITY},
    [TOKEN_EQUAL]         = {NULL,     NULL,   PREC_NONE},
    [TOKEN_EQUAL_EQUAL]   = {NULL,     binary, PREC_EQUALITY},
    [TOKEN_GREATER]       = {NULL,     binary, PREC_COMPARISON},
    [TOKEN_GREATER_EQUAL] = {NULL,     binary, PREC_COMPARISON},
    [TOKEN_LESS]          = {NULL,     binary, PREC_COMPARISON},
    [TOKEN_LESS_EQUAL]    = {NULL,     binary, PREC_COMPARISON},
    [TOKEN_IDENTIFIER]    = {variable, NULL,   PREC_NONE},
    [TOKEN_STRING]        = {string,   NULL,   PREC_NONE},
    [TOKEN_NUMBER]        = {number,   NULL,   PREC_NONE},
    [TOKEN_AND]           = {NULL,     and_,   PREC_AND},
    [TOKEN_CLASS]         = {NULL,     NULL,   PREC_NONE},
    [TOKEN_ELSE]          = {NULL,     NULL,   PREC_NONE},
    [TOKEN_FALSE]         = {literal,  NULL,   PREC_NONE},
    [TOKEN_FOR]           = {NULL,     NULL,   PREC_NONE},
    [TOKEN_FUN]           = {NULL,     NULL,   PREC_NONE},
    [TOKEN_IF]            = {NULL,     NULL,   PREC_NONE},
    [TOKEN_NIL]           = {literal,  NULL,   PREC_NONE},
    [TOKEN_OR]            = {NULL,     or_,    PREC_OR},
    [TOKEN_PRINT]         = {NULL,     NULL,   PREC_NONE},
    [TOKEN_RETURN]        = {NULL,     NULL,   PREC_NONE},
    [TOKEN_SUPER]         = {super_,   NULL,   PREC_NONE},
    [TOKEN_THIS]          = {this_,    NULL,   PREC_NONE},
    [TOKEN_TRUE]          = {literal,  NULL,   PREC_NONE},
    [TOKEN_VAR]           = {NULL,     NULL,   PREC_NONE},
    [TOKEN_WHILE]         = {NULL,     NULL,   PREC_NONE},
    [TOKEN_ERROR]         = {NULL,     NULL,   PREC_NONE},
    [TOKEN_EOF]           = {NULL,     NULL,   PREC_NONE},
  };

  static void parsePrecedence(Precedence precedence) {
    advance();
    ParseFn prefixRule = getRule(parser.previous.type)->prefix;
    if (prefixRule == NULL) {
      error("Expect expression.");
      return;
    }

    bool canAssign = precedence <= PREC_ASSIGNMENT;
    prefixRule(canAssign);

    while (precedence <= getRule(parser.current.type)->precedence) {
      advance();
      ParseFn infixRule = getRule(parser.previous.type)->infix;
      infixRule(canAssign);
    }

    if (canAssign && match(TOKEN_EQUAL)) {
      error("Invalid assignment target.");
    }
  }

  static ParseRule* getRule(TokenType type) {
    return &rules[type];
  }

  static void expression() {
    parsePrecedence(PREC_ASSIGNMENT);
  }

  static void block() {
    while (!check(TOKEN_RIGHT_BRACE) && !check(TOKEN_EOF)) {
      declaration();
    }

    consume(TOKEN_RIGHT_BRACE, "Expect '}' after block.");
  }

  static void function(FunctionType type) {
    Compiler compiler;
    initCompiler(&compiler, type);
    beginScope(); // [no-end-scope]

    consume(TOKEN_LEFT_PAREN, "Expect '(' after function name.");
    if (!check(TOKEN_RIGHT_PAREN)) {
      do {
        current->function->arity++;
        if (current->function->arity > 255) {
          errorAtCurrent("Can't have more than 255 parameters.");
        }
        uint8_t constant = parseVariable("Expect parameter name.");
        defineVariable(constant);
      } while (match(TOKEN_COMMA));
    }
    consume(TOKEN_RIGHT_PAREN, "Expect ')' after parameters.");
    consume(TOKEN_LEFT_BRACE, "Expect '{' before function body.");
    block();

    ObjFunction* function = endCompiler();

    for (int i = 0; i < function->upvalueCount; i++) {
      emitByte(compiler.upvalues[i].isLocal ? 1 : 0);
      emitByte(compiler.upvalues[i].index);
    }
  }

  static void method() {
    consume(TOKEN_IDENTIFIER, "Expect method name.");
    uint8_t constant = identifierConstant(&parser.previous);

    FunctionType type = TYPE_METHOD;

    if (parser.previous.length == 4 &&
        memcmp(parser.previous.start, "init", 4) == 0) {
      type = TYPE_INITIALIZER;
    }

    function(type);
    emitBytes(OP_METHOD, constant);
  }

  static void classDeclaration() {
    consume(TOKEN_IDENTIFIER, "Expect class name.");
    Token className = parser.previous;
    uint8_t nameConstant = identifierConstant(&parser.previous);
    declareVariable();

    emitBytes(OP_CLASS, nameConstant);
    defineVariable(nameConstant);

    ClassCompiler classCompiler;

    classCompiler.hasSuperclass = false;

    classCompiler.enclosing = currentClass;
    currentClass = &classCompiler;

    if (match(TOKEN_LESS)) {
      consume(TOKEN_IDENTIFIER, "Expect superclass name.");
      variable(false);

      if (identifiersEqual(&className, &parser.previous)) {
        error("A class can't inherit from itself.");
      }

      beginScope();
      addLocal(syntheticToken("super"));
      defineVariable(0);

      namedVariable(className, false);
      emitByte(OP_INHERIT);
      classCompiler.hasSuperclass = true;
    }

    namedVariable(className, false);

    consume(TOKEN_LEFT_BRACE, "Expect '{' before class body.");

    while (!check(TOKEN_RIGHT_BRACE) && !check(TOKEN_EOF)) {
      method();
    }

    consume(TOKEN_RIGHT_BRACE, "Expect '}' after class body.");

    emitByte(OP_POP);

    if (classCompiler.hasSuperclass) {
      endScope();
    }

    currentClass = currentClass->enclosing;
  }

  static void funDeclaration() {
    uint8_t global = parseVariable("Expect function name.");
    markInitialized();
    function(TYPE_FUNCTION);
    defineVariable(global);
  }

  static void varDeclaration() {
    uint8_t global = parseVariable("Expect variable name.");

    if (match(TOKEN_EQUAL)) {
      expression();
    } else {
      emitByte(OP_NIL);
    }
    consume(TOKEN_SEMICOLON, "Expect ';' after variable declaration.");

    defineVariable(global);
  }

  static void expressionStatement() {
    expression();
    consume(TOKEN_SEMICOLON, "Expect ';' after expression.");
    emitByte(OP_POP);
  }

  static void forStatement() {
    beginScope();

    consume(TOKEN_LEFT_PAREN, "Expect '(' after 'for'.");

    if (match(TOKEN_SEMICOLON)) {
      // No initializer.
    } else if (match(TOKEN_VAR)) {
      varDeclaration();
    } else {
      expressionStatement();
    }

    int loopStart = currentChunk()->count;

    int exitJump = -1;
    if (!match(TOKEN_SEMICOLON)) {
      expression();
      consume(TOKEN_SEMICOLON, "Expect ';' after loop condition.");

      // Jump out of the loop if the condition is false.
      exitJump = emitJump(OP_JUMP_IF_FALSE);
      emitByte(OP_POP); // Condition.
    }

    if (!match(TOKEN_RIGHT_PAREN)) {
      int bodyJump = emitJump(OP_JUMP);
      int incrementStart = currentChunk()->count;
      expression();
      emitByte(OP_POP);
      consume(TOKEN_RIGHT_PAREN, "Expect ')' after for clauses.");

      emitLoop(loopStart);
      loopStart = incrementStart;
      patchJump(bodyJump);
    }

    statement();
    emitLoop(loopStart);

    if (exitJump != -1) {
      patchJump(exitJump);
      emitByte(OP_POP); // Condition.
    }

    endScope();
  }

  static void ifStatement() {
    consume(TOKEN_LEFT_PAREN, "Expect '(' after 'if'.");
    expression();
    consume(TOKEN_RIGHT_PAREN, "Expect ')' after condition."); // [paren]

    int thenJump = emitJump(OP_JUMP_IF_FALSE);

    emitByte(OP_POP);

    statement();

    int elseJump = emitJump(OP_JUMP);

    patchJump(thenJump);

    emitByte(OP_POP);

    if (match(TOKEN_ELSE)) statement();
    patchJump(elseJump);
  }

  static void printStatement() {
    expression();
    consume(TOKEN_SEMICOLON, "Expect ';' after value.");
    emitByte(OP_PRINT);
  }

  static void returnStatement() {
    if (current->type == TYPE_SCRIPT) {
      error("Can't return from top-level code.");
    }

    if (match(TOKEN_SEMICOLON)) {
      emitReturn();
    } else {
      if (current->type == TYPE_INITIALIZER) {
        error("Can't return a value from an initializer.");
      }

      expression();
      consume(TOKEN_SEMICOLON, "Expect ';' after return value.");
      emitByte(OP_RETURN);
    }
  }

  static void whileStatement() {
    int loopStart = currentChunk()->count;

    consume(TOKEN_LEFT_PAREN, "Expect '(' after 'while'.");
    expression();
    consume(TOKEN_RIGHT_PAREN, "Expect ')' after condition.");

    int exitJump = emitJump(OP_JUMP_IF_FALSE);
    emitByte(OP_POP);
    statement();

    emitLoop(loopStart);

    patchJump(exitJump);
    emitByte(OP_POP);
  }
  static void synchronize() {
    parser.panicMode = false;

    while (parser.current.type != TOKEN_EOF) {
      if (parser.previous.type == TOKEN_SEMICOLON) return;
      switch (parser.current.type) {
      case TOKEN_CLASS:
      case TOKEN_FUN:
      case TOKEN_VAR:
      case TOKEN_FOR:
      case TOKEN_IF:
      case TOKEN_WHILE:
      case TOKEN_PRINT:
      case TOKEN_RETURN:
        return;

      default:
        ; // Do nothing.
      }

      advance();
    }
  }

  static void declaration() {
    if (match(TOKEN_CLASS)) {
      classDeclaration();
    } else if (match(TOKEN_FUN)) {
      funDeclaration();
    } else if (match(TOKEN_VAR)) {
      varDeclaration();
    } else {
      statement();
    }
    if (parser.panicMode) synchronize();
  }

  static void statement() {
    if (match(TOKEN_PRINT)) {
      printStatement();
    } else if (match(TOKEN_FOR)) {
      forStatement();
    } else if (match(TOKEN_IF)) {
      ifStatement();
    } else if (match(TOKEN_RETURN)) {
      returnStatement();
    } else if (match(TOKEN_WHILE)) {
      whileStatement();
    } else if (match(TOKEN_LEFT_BRACE)) {
      beginScope();
      block();
      endScope();
    } else {
      expressionStatement();
    }
  }

  ObjFunction* compile(const char* source) {
    initScanner(source);

    Compiler compiler;
    initCompiler(&compiler, TYPE_SCRIPT);

    parser.hadError = false;
    parser.panicMode = false;

    advance();

    while (!match(TOKEN_EOF)) {
      declaration();
    }

    //  Compiling Expressions finish-compile < Calls and Functions call-end-compiler
    //  endCompiler();
    //
    // Compiling Expressions return-had-error < Calls and Functions call-end-compiler
    // return !parser.hadError;

    ObjFunction* function = endCompiler();
    return parser.hadError ? NULL : function;
  }

  void markCompilerRoots() {
    Compiler* compiler = current;
    while (compiler != NULL) {
      markObject((Obj*)compiler->function);
      compiler = compiler->enclosing;
    }
  }
#+end_src

** Table

*** ~table.h~

#+begin_src c
  #ifndef clox_table_h
  #define clox_table_h

  #include "common.h"
  #include "value.h"

  // Table Entry
  typedef struct {
    ObjString* key;
    Value value;
  } Entry;

  // Table
  typedef struct {
    int count;
    int capacity;
    Entry* entries;
  } Table;

  void initTable(Table* table);
  void freeTable(Table* table);
  bool tableGet(Table* table, ObjString* key, Value* value);
  bool tableSet(Table* table, ObjString* key, Value value);
  bool tableDelete(Table* table, ObjString* key);
  void tableAddAll(Table* from, Table* to);
  ObjString* tableFindString(Table* table, const char* chars, int length, uint32_t hash);
  void tableRemoveWhite(Table* table);
  void markTable(Table* table);

  #endif
#+end_src

*** ~table.c~

#+begin_src c
  #include <stdlib.h>
  #include <string.h>

  #include "memory.h"
  #include "object.h"
  #include "table.h"
  #include "value.h"

  #define TABLE_MAX_LOAD 0.75

  void initTable(Table* table) {
    table->count = 0;
    table->capacity = 0;
    table->entries = NULL;
  }

  void freeTable(Table* table) {
    FREE_ARRAY(Entry, table->entries, table->capacity);
    initTable(table);
  }

  static Entry* findEntry(Entry* entries, int capacity, ObjString* key) {
    // Hash Tables find-entry < Optimization initial-index
    // uint32_t index = key->hash % capacity;
    uint32_t index = key->hash & (capacity - 1);

    Entry* tombstone = NULL;

    for (;;) {
      Entry* entry = &entries[index];
      // Hash Tables find-entry < Hash Tables find-tombstone
      // if (entry->key == key || entry->key == NULL) {
      //    return entry;
      // }
      if (entry->key == NULL) {
        if (IS_NIL(entry->value)) {
          // Empty entry.
          return tombstone != NULL ? tombstone : entry;
        } else {
          // We found a tombstone.
          if (tombstone == NULL) tombstone = entry;
        }
      } else if (entry->key == key) {
        // We found the key.
        return entry;
      }

      // Hash Tables find-entry < Optimization next-index
      // index = (index + 1) % capacity;
      index = (index + 1) & (capacity - 1);
    }
  }

  bool tableGet(Table* table, ObjString* key, Value* value) {
    if (table->count == 0) return false;

    Entry* entry = findEntry(table->entries, table->capacity, key);
    if (entry->key == NULL) return false;

    *value = entry->value;
    return true;
  }

  static void adjustCapacity(Table* table, int capacity) {
    Entry* entries = ALLOCATE(Entry, capacity);
    for (int i = 0; i < capacity; i++) {
      entries[i].key = NULL;
      entries[i].value = NIL_VAL;
    }

    table->count = 0;
    for (int i = 0; i < table->capacity; i++) {
      Entry* entry = &table->entries[i];
      if (entry->key == NULL) continue;

      Entry* dest = findEntry(entries, capacity, entry->key);
      dest->key = entry->key;
      dest->value = entry->value;
      table->count++;
    }

    FREE_ARRAY(Entry, table->entries, table->capacity);
    table->entries = entries;
    table->capacity = capacity;
  }

  bool tableSet(Table* table, ObjString* key, Value value) {
    if (table->count + 1 > table->capacity * TABLE_MAX_LOAD) {
      int capacity = GROW_CAPACITY(table->capacity);
      adjustCapacity(table, capacity);
    }

    Entry* entry = findEntry(table->entries, table->capacity, key);
    bool isNewKey = entry->key == NULL;
    // Hash Tables table-set < Hash Tables set-increment-count
    // if (isNewKey) table->count++;
    if (isNewKey && IS_NIL(entry->value)) table->count++;

    entry->key = key;
    entry->value = value;
    return isNewKey;
  }

  bool tableDelete(Table* table, ObjString* key) {
    if (table->count == 0) return false;

    // Find the entry.
    Entry* entry = findEntry(table->entries, table->capacity, key);
    if (entry->key == NULL) return false;

    // Place a tombstone in the entry.
    entry->key = NULL;
    entry->value = BOOL_VAL(true);
    return true;
  }

  void tableAddAll(Table* from, Table* to) {
    for (int i = 0; i < from->capacity; i++) {
      Entry* entry = &from->entries[i];
      if (entry->key != NULL) {
        tableSet(to, entry->key, entry->value);
      }
    }
  }

  ObjString* tableFindString(Table* table, const char* chars, int length, uint32_t hash) {
    if (table->count == 0) return NULL;

    // Hash Tables table-find-string < Optimization find-string-index
    // uint32_t index = hash % table->capacity;
    uint32_t index = hash & (table->capacity - 1);

    for (;;) {
      Entry* entry = &table->entries[index];
      if (entry->key == NULL) {
        // Stop if we find an empty non-tombstone entry.
        if (IS_NIL(entry->value)) return NULL;
      } else if (entry->key->length == length &&
                 entry->key->hash == hash &&
                 memcmp(entry->key->chars, chars, length) == 0) {
        // We found it.
        return entry->key;
      }

      // Hash Tables table-find-string < Optimization find-string-next
      // index = (index + 1) % table->capacity;
      index = (index + 1) & (table->capacity - 1);
    }
  }

  void tableRemoveWhite(Table* table) {
    for (int i = 0; i < table->capacity; i++) {
      Entry* entry = &table->entries[i];
      if (entry->key != NULL && !entry->key->obj.isMarked) {
        tableDelete(table, entry->key);
      }
    }
  }

  void markTable(Table* table) {
    for (int i = 0; i < table->capacity; i++) {
      Entry* entry = &table->entries[i];
      markObject((Obj*)entry->key);
      markValue(entry->value);
    }
  }
#+end_src

** Value

*** ~value.h~

#+begin_src c
  #ifndef clox_value_h
  #define clox_value_h

  #include <string.h>

  #include "common.h"

  typedef struct Obj Obj;
  typedef struct ObjString ObjString;

  #ifdef NAN_BOXING

  #define SIGN_BIT ((uint64_t)0x8000000000000000)
  #define QNAN     ((uint64_t)0x7ffc000000000000)

  #define TAG_NIL   1 // 01.
  #define TAG_FALSE 2 // 10.
  #define TAG_TRUE  3 // 11.

  typedef uint64_t Value;

  #define IS_BOOL(value)      (((value) | 1) == TRUE_VAL)
  #define IS_NIL(value)       ((value) == NIL_VAL)
  #define IS_NUMBER(value)    (((value) & QNAN) != QNAN)
  #define IS_OBJ(value)                                         \
    (((value) & (QNAN | SIGN_BIT)) == (QNAN | SIGN_BIT))

  #define AS_BOOL(value)      ((value) == TRUE_VAL)
  #define AS_NUMBER(value)    valueToNum(value)
  #define AS_OBJ(value)                                         \
    ((Obj*)(uintptr_t)((value) & ~(SIGN_BIT | QNAN)))
  #define BOOL_VAL(b)     ((b) ? TRUE_VAL : FALSE_VAL)
  #define FALSE_VAL       ((Value)(uint64_t)(QNAN | TAG_FALSE))
  #define TRUE_VAL        ((Value)(uint64_t)(QNAN | TAG_TRUE))
  #define NIL_VAL         ((Value)(uint64_t)(QNAN | TAG_NIL))
  #define NUMBER_VAL(num) numToValue(num)
  #define OBJ_VAL(obj)                                  \
    (Value)(SIGN_BIT | QNAN | (uint64_t)(uintptr_t)(obj))

  static inline double valueToNum(Value value) {
    double num;
    memcpy(&num, &value, sizeof(Value));
    return num;
  }

  static inline Value numToValue(double num) {
    Value value;
    memcpy(&value, &num, sizeof(double));
    return value;
  }

  #else

  typedef enum {
    VAL_BOOL,
    VAL_NIL,
    VAL_NUMBER,
    VAL_OBJ
  } ValueType;

  typedef struct {
    ValueType type;
    union {
      bool boolean;
      double number;
      Obj* obj;
    } as;
  } Value;

  #define IS_BOOL(value)    ((value).type == VAL_BOOL)
  #define IS_NIL(value)     ((value).type == VAL_NIL)
  #define IS_NUMBER(value)  ((value).type == VAL_NUMBER)
  #define IS_OBJ(value)     ((value).type == VAL_OBJ)

  #define AS_OBJ(value)     ((value).as.obj)
  #define AS_BOOL(value)    ((value).as.boolean)
  #define AS_NUMBER(value)  ((value).as.number)

  #define BOOL_VAL(value)   ((Value){VAL_BOOL, {.boolean = value}})
  #define NIL_VAL           ((Value){VAL_NIL, {.number = 0}})
  #define NUMBER_VAL(value) ((Value){VAL_NUMBER, {.number = value}})
  #define OBJ_VAL(object)   ((Value){VAL_OBJ, {.obj = (Obj*)object}})

  #endif

  typedef struct {
    int capacity;
    int count;
    Value* values;
  } ValueArray;

  bool valuesEqual(Value a, Value b);
  void initValueArray(ValueArray* array);
  void writeValueArray(ValueArray* array, Value value);
  void freeValueArray(ValueArray* array);
  void printValue(Value value);

  #endif
#+end_src

*** ~value.c~

#+begin_src c
  #include <stdio.h>
  #include <string.h>
  #include "object.h"
  #include "memory.h"
  #include "value.h"

  void initValueArray(ValueArray* array) {
    array->values = NULL;
    array->capacity = 0;
    array->count = 0;
  }

  void writeValueArray(ValueArray* array, Value value) {
    if (array->capacity < array->count + 1) {
      int oldCapacity = array->capacity;
      array->capacity = GROW_CAPACITY(oldCapacity);
      array->values = GROW_ARRAY(Value, array->values, oldCapacity, array->capacity);
    }

    array->values[array->count] = value;
    array->count++;
  }

  void freeValueArray(ValueArray* array) {
    FREE_ARRAY(Value, array->values, array->capacity);
    initValueArray(array);
  }

  void printValue(Value value) {
  #ifdef NAN_BOXING
    if (IS_BOOL(value)) {
      printf(AS_BOOL(value) ? "true" : "false");
    } else if (IS_NIL(value)) {
      printf("nil");
    } else if (IS_NUMBER(value)) {
      printf("%g", AS_NUMBER(value));
    } else if (IS_OBJ(value)) {
      printObject(value);
    }
  #else
    switch (value.type) {
    case VAL_BOOL:
      printf(AS_BOOL(value) ? "true" : "false");
      break;
    case VAL_NIL: printf("nil"); break;
    case VAL_NUMBER: printf("%g", AS_NUMBER(value)); break;
    case VAL_OBJ: printObject(value); break;
    }
  #endif
  }

  bool valuesEqual(Value a, Value b) {

  #ifdef NAN_BOXING
    if (IS_NUMBER(a) && IS_NUMBER(b)) {
      return AS_NUMBER(a) == AS_NUMBER(b);
    }
    return a == b;
  #else
    if (a.type != b.type) return false;
    switch (a.type) {
    case VAL_BOOL:   return AS_BOOL(a) == AS_BOOL(b);
    case VAL_NIL:    return true;
    case VAL_NUMBER: return AS_NUMBER(a) == AS_NUMBER(b);
    case VAL_OBJ:    return AS_OBJ(a) == AS_OBJ(b);
    default:         return false; // Unreachable.
    }
  #endif
  }
#+end_src

* Memory

** ~memory.h~

#+begin_src c
  #ifndef clox_memory_h
  #define clox_memory_h

  #include "common.h"
  #include "object.h"

  #define ALLOCATE(type, count) \
    (type*)reallocate(NULL, 0, sizeof(type) * (count))

  #define FREE(type, pointer) reallocate(pointer, sizeof(type), 0)

  #define GROW_CAPACITY(capacity) \
    ((capacity) < 8 ? 8 : (capacity) * 2)

  #define GROW_ARRAY(type, pointer, oldCount, newCount) \
    (type*)reallocate(pointer, sizeof(type) * (oldCount), sizeof(type) * (newCount))

  #define FREE_ARRAY(type, pointer, oldCount) \
    reallocate(pointer, sizeof(type) * (oldCount), 0)

  // === Reallocation Operations ===
  //
  // | old size | new size | operation           |
  // |----------+----------+---------------------|
  // | 0        | non-zero | Allocate new block. |
  // | non-zero | 0        | Free allocation.    |
  // | non-zero | smaller  | Shrink allocation.  |
  // | non-zero | larger   | Grow allocation.    |
  void* reallocate(void* pointer, size_t oldSize, size_t newSize);

  void markObject(Obj* object);
  void markValue(Value value);
  void collectGarbage();
  void freeObjects();

  #endif
#+end_src

** Chunk

*** ~chunk.h~

#+begin_src c
  #ifndef clox_chunk_h
  #define clox_chunk_h

  #include "common.h"
  #include "value.h"

  typedef enum {
    OP_CONSTANT,
    OP_NIL,
    OP_TRUE,
    OP_FALSE,
    OP_POP,
    OP_GET_LOCAL,
    OP_SET_LOCAL,
    OP_GET_GLOBAL,
    OP_DEFINE_GLOBAL,
    OP_SET_GLOBAL,
    OP_GET_UPVALUE,
    OP_SET_UPVALUE,
    OP_GET_PROPERTY,
    OP_SET_PROPERTY,
    OP_GET_SUPER,
    OP_EQUAL,
    OP_GREATER,
    OP_LESS,
    OP_ADD,
    OP_SUBTRACT,
    OP_MULTIPLY,
    OP_DIVIDE,
    OP_NOT,
    OP_NEGATE,
    OP_PRINT,
    OP_JUMP,
    OP_JUMP_IF_FALSE,
    OP_LOOP,
    OP_CALL,
    OP_INVOKE,
    OP_SUPER_INVOKE,
    OP_CLOSURE,
    OP_CLOSE_UPVALUE,
    OP_RETURN,
    OP_CLASS,
    OP_INHERIT,
    OP_METHOD
  } OpCode;

  typedef struct {
    int count;
    int capacity;
    uint8_t* code;
    int* lines;
    ValueArray constants;
  } Chunk;

  void initChunk(Chunk* chunk);
  void freeChunk(Chunk* chunk);
  void writeChunk(Chunk* chunk, uint8_t byte, int line);
  int addConstant(Chunk* chunk, Value value);

  #endif
#+end_src

*** ~chunk.c~

#+begin_src c
  #include <stdlib.h>

  #include "chunk.h"
  #include "memory.h"
  #include "vm.h"

  void initChunk(Chunk* chunk) {
    chunk->count = 0;
    chunk->capacity = 0;
    chunk->code = NULL;
    chunk->lines = NULL;
    initValueArray(&chunk->constants);
  }

  void freeChunk(Chunk* chunk) {
    FREE_ARRAY(uint8_t, chunk->code, chunk->capacity);
    FREE_ARRAY(int, chunk->lines, chunk->capacity);
    freeValueArray(&chunk->constants);
    initChunk(chunk);
  }

  void writeChunk(Chunk* chunk, uint8_t byte, int line) {
    if (chunk->capacity < chunk->count + 1) {
      int oldCapacity = chunk->capacity;
      chunk->capacity = GROW_CAPACITY(oldCapacity);
      chunk->code = GROW_ARRAY(uint8_t, chunk->code, oldCapacity, chunk->capacity);
      chunk->lines = GROW_ARRAY(int, chunk->lines, oldCapacity, chunk->capacity);
    }

    chunk->code[chunk->count] = byte;
    chunk->lines[chunk->count] = line;
    chunk->count++;
  }

  int addConstant(Chunk* chunk, Value value) {
    push(value);
    writeValueArray(&chunk->constants, value);
    pop();
    return chunk->constants.count - 1;
  }
#+end_src

** Virtual Machine

*** ~vm.h~

#+begin_src c
  #ifndef clox_vm_h
  #define clox_vm_h

  #include "object.h"
  #include "table.h"
  #include "value.h"

  #define FRAMES_MAX 64
  #define STACK_MAX (FRAMES_MAX * UINT8_COUNT)

  // Call Frame
  typedef struct {
    ObjClosure* closure;
    // Instruction Pointer
    uint8_t* ip;
    Value* slots;
  } CallFrame;

  // Static Virtual Machine
  typedef struct {
    CallFrame frames[FRAMES_MAX];
    int frameCount;
    Value stack[STACK_MAX];
    Value* stackTop;
    Table globals;
    Table strings;
    ObjString* initString;
    ObjUpvalue* openUpvalues;
    size_t bytesAllocated;
    size_t nextGC;
    Obj* objects;
    int grayCount;
    int grayCapacity;
    Obj** grayStack;
  } VM;

  typedef enum {
    INTERPRET_OK,
    INTERPRET_COMPILE_ERROR,
    INTERPRET_RUNTIME_ERROR
  } InterpretResult;

  extern VM vm;

  void initVM();
  void freeVM();
  InterpretResult interpret(const char* source);
  void push(Value value);
  Value pop();

  #endif
#+end_src

*** ~vm.c~

#+begin_src c
  #include <stdarg.h>
  #include <stdio.h>
  #include <string.h>
  #include <time.h>

  #include "common.h"
  #include "compiler.h"
  #include "debug.h"
  #include "object.h"
  #include "memory.h"
  #include "vm.h"

  VM vm;

  static Value clockNative(int argCount, Value* args) {
    return NUMBER_VAL((double)clock() / CLOCKS_PER_SEC);
  }

  static void resetStack() {
    vm.stackTop = vm.stack;
    vm.frameCount = 0;
    vm.openUpvalues = NULL;
  }

  static void runtimeError(const char* format, ...) {
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fputs("\n", stderr);

    for (int i = vm.frameCount - 1; i >= 0; i--) {
      CallFrame* frame = &vm.frames[i];
      ObjFunction* function = frame->closure->function;
      size_t instruction = frame->ip - function->chunk.code - 1;
      fprintf(stderr, "[line %d] in ",
              function->chunk.lines[instruction]);
      if (function->name == NULL) {
        fprintf(stderr, "script\n");
      } else {
        fprintf(stderr, "%s()\n", function->name->chars);
      }
    }

    resetStack();
  }

  static void defineNative(const char* name, NativeFn function) {
    push(OBJ_VAL(copyString(name, (int)strlen(name))));
    push(OBJ_VAL(newNative(function)));
    tableSet(&vm.globals, AS_STRING(vm.stack[0]), vm.stack[1]);
    pop();
    pop();
  }

  void initVM() {
    resetStack();
    vm.objects = NULL;
    vm.bytesAllocated = 0;
    vm.nextGC = 1024 * 1024;

    vm.grayCount = 0;
    vm.grayCapacity = 0;
    vm.grayStack = NULL;
    initTable(&vm.globals);
    initTable(&vm.strings);

    vm.initString = NULL;
    vm.initString = copyString("init", 4);

    defineNative("clock", clockNative);
  }

  void freeVM() {
    freeTable(&vm.globals);
    freeTable(&vm.strings);
    vm.initString = NULL;
    freeObjects();
  }

  void push(Value value) {
    *vm.stackTop = value;
    vm.stackTop++;
  }

  Value pop() {
    vm.stackTop--;
    return *vm.stackTop;
  }

  static Value peek(int distance) {
    return vm.stackTop[-1 - distance];
  }

  static bool call(ObjClosure* closure, int argCount) {
    if (argCount != closure->function->arity) {
      runtimeError("Expected %d arguments but got %d.",
                   closure->function->arity, argCount);
      return false;
    }

    if (vm.frameCount == FRAMES_MAX) {
      runtimeError("Stack overflow.");
      return false;
    }

    CallFrame* frame = &vm.frames[vm.frameCount++];
    frame->closure = closure;
    frame->ip = closure->function->chunk.code;
    frame->slots = vm.stackTop - argCount - 1;
    return true;
  }

  static bool callValue(Value callee, int argCount) {
    if (IS_OBJ(callee)) {
      switch (OBJ_TYPE(callee)) {
      case OBJ_BOUND_METHOD: {
        ObjBoundMethod* bound = AS_BOUND_METHOD(callee);
        vm.stackTop[-argCount - 1] = bound->receiver;
        return call(bound->method, argCount);
      }
      case OBJ_CLASS: {
        ObjClass* klass = AS_CLASS(callee);
        vm.stackTop[-argCount - 1] = OBJ_VAL(newInstance(klass));
        Value initializer;
        if (tableGet(&klass->methods, vm.initString,
                     &initializer)) {
          return call(AS_CLOSURE(initializer), argCount);
        } else if (argCount != 0) {
          runtimeError("Expected 0 arguments but got %d.", argCount);
          return false;
        }
        return true;
      }
      case OBJ_CLOSURE:
        return call(AS_CLOSURE(callee), argCount);
      case OBJ_NATIVE: {
        NativeFn native = AS_NATIVE(callee);
        Value result = native(argCount, vm.stackTop - argCount);
        vm.stackTop -= argCount + 1;
        push(result);
        return true;
      }
      default:
        break;
      }
    }
    runtimeError("Can only call functions and classes.");
    return false;
  }

  static bool invokeFromClass(ObjClass* klass, ObjString* name, int argCount) {
    Value method;
    if (!tableGet(&klass->methods, name, &method)) {
      runtimeError("Undefined property '%s'.", name->chars);
      return false;
    }
    return call(AS_CLOSURE(method), argCount);
  }

  static bool invoke(ObjString* name, int argCount) {
    Value receiver = peek(argCount);

    if (!IS_INSTANCE(receiver)) {
      runtimeError("Only instances have methods.");
      return false;
    }

    ObjInstance* instance = AS_INSTANCE(receiver);

    Value value;
    if (tableGet(&instance->fields, name, &value)) {
      vm.stackTop[-argCount - 1] = value;
      return callValue(value, argCount);
    }

    return invokeFromClass(instance->klass, name, argCount);
  }

  static bool bindMethod(ObjClass* klass, ObjString* name) {
    Value method;
    if (!tableGet(&klass->methods, name, &method)) {
      runtimeError("Undefined property '%s'.", name->chars);
      return false;
    }

    ObjBoundMethod* bound = newBoundMethod(peek(0), AS_CLOSURE(method));
    pop();
    push(OBJ_VAL(bound));
    return true;
  }

  static ObjUpvalue* captureUpvalue(Value* local) {
    ObjUpvalue* prevUpvalue = NULL;
    ObjUpvalue* upvalue = vm.openUpvalues;
    while (upvalue != NULL && upvalue->location > local) {
      prevUpvalue = upvalue;
      upvalue = upvalue->next;
    }

    if (upvalue != NULL && upvalue->location == local) {
      return upvalue;
    }

    ObjUpvalue* createdUpvalue = newUpvalue(local);
    createdUpvalue->next = upvalue;

    if (prevUpvalue == NULL) {
      vm.openUpvalues = createdUpvalue;
    } else {
      prevUpvalue->next = createdUpvalue;
    }

    return createdUpvalue;
  }

  static void closeUpvalues(Value* last) {
    while (vm.openUpvalues != NULL &&
           vm.openUpvalues->location >= last) {
      ObjUpvalue* upvalue = vm.openUpvalues;
      upvalue->closed = *upvalue->location;
      upvalue->location = &upvalue->closed;
      vm.openUpvalues = upvalue->next;
    }
  }

  static void defineMethod(ObjString* name) {
    Value method = peek(0);
    ObjClass* klass = AS_CLASS(peek(1));
    tableSet(&klass->methods, name, method);
    pop();
  }

  static bool isFalsey(Value value) {
    return IS_NIL(value) || (IS_BOOL(value) && !AS_BOOL(value));
  }

  static void concatenate() {
    ObjString* b = AS_STRING(peek(0));
    ObjString* a = AS_STRING(peek(1));

    int length = a->length + b->length;
    char* chars = ALLOCATE(char, length + 1);
    memcpy(chars, a->chars, a->length);
    memcpy(chars + a->length, b->chars, b->length);
    chars[length] = '\0';

    ObjString* result = takeString(chars, length);
    pop();
    pop();
    push(OBJ_VAL(result));
  }

  static InterpretResult run() {
    CallFrame* frame = &vm.frames[vm.frameCount - 1];

  #define READ_BYTE() (*frame->ip++)
  #define READ_SHORT()                                  \
    (frame->ip += 2,                                    \
     (uint16_t)((frame->ip[-2] << 8) | frame->ip[-1]))
  #define READ_CONSTANT() \
    (frame->closure->function->chunk.constants.values[READ_BYTE()])
  #define READ_STRING() AS_STRING(READ_CONSTANT())
  #define BINARY_OP(valueType, op)                      \
    do {                                                \
      if (!IS_NUMBER(peek(0)) || !IS_NUMBER(peek(1))) { \
        runtimeError("Operands must be numbers.");      \
        return INTERPRET_RUNTIME_ERROR;                 \
      }                                                 \
      double b = AS_NUMBER(pop());                      \
      double a = AS_NUMBER(pop());                      \
      push(valueType(a op b));                          \
    } while (false)

    for (;;) {

  #ifdef DEBUG_TRACE_EXECUTION
      printf("          ");
      for (Value* slot = vm.stack; slot < vm.stackTop; slot++) {
        printf("[ ");
        printValue(*slot);
        printf(" ]");
      }
      printf("\n");
      disassembleInstruction(&frame->closure->function->chunk,
                             (int)(frame->ip - frame->closure->function->chunk.code));
  #endif

      uint8_t instruction;
      switch (instruction = READ_BYTE()) {
      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
        push(constant);
        break;
      }
      case OP_NIL: push(NIL_VAL); break;
      case OP_TRUE: push(BOOL_VAL(true)); break;
      case OP_FALSE: push(BOOL_VAL(false)); break;
      case OP_POP: pop(); break;
      case OP_GET_LOCAL: {
        uint8_t slot = READ_BYTE();
        push(frame->slots[slot]);
        break;
      }
      case OP_SET_LOCAL: {
        uint8_t slot = READ_BYTE();
        frame->slots[slot] = peek(0);
        break;
      }
      case OP_GET_GLOBAL: {
        ObjString* name = READ_STRING();
        Value value;
        if (!tableGet(&vm.globals, name, &value)) {
          runtimeError("Undefined variable '%s'.", name->chars);
          return INTERPRET_RUNTIME_ERROR;
        }
        push(value);
        break;
      }
      case OP_DEFINE_GLOBAL: {
        ObjString* name = READ_STRING();
        tableSet(&vm.globals, name, peek(0));
        pop();
        break;
      }
      case OP_SET_GLOBAL: {
        ObjString* name = READ_STRING();
        if (tableSet(&vm.globals, name, peek(0))) {
          tableDelete(&vm.globals, name);
          runtimeError("Undefined variable '%s'.", name->chars);
          return INTERPRET_RUNTIME_ERROR;
        }
        break;
      }
      case OP_GET_UPVALUE: {
        uint8_t slot = READ_BYTE();
        push(*frame->closure->upvalues[slot]->location);
        break;
      }
      case OP_SET_UPVALUE: {
        uint8_t slot = READ_BYTE();
        ,*frame->closure->upvalues[slot]->location = peek(0);
        break;
      }
      case OP_GET_PROPERTY: {
        if (!IS_INSTANCE(peek(0))) {
          runtimeError("Only instances have properties.");
          return INTERPRET_RUNTIME_ERROR;
        }

        ObjInstance* instance = AS_INSTANCE(peek(0));
        ObjString* name = READ_STRING();

        Value value;
        if (tableGet(&instance->fields, name, &value)) {
          pop(); // Instance.
          push(value);
          break;
        }
        if (!bindMethod(instance->klass, name)) {
          return INTERPRET_RUNTIME_ERROR;
        }
        break;
      }
      case OP_SET_PROPERTY: {
        if (!IS_INSTANCE(peek(1))) {
          runtimeError("Only instances have fields.");
          return INTERPRET_RUNTIME_ERROR;
        }
        ObjInstance* instance = AS_INSTANCE(peek(1));
        tableSet(&instance->fields, READ_STRING(), peek(0));
        Value value = pop();
        pop();
        push(value);
        break;
      }
      case OP_GET_SUPER: {
        ObjString* name = READ_STRING();
        ObjClass* superclass = AS_CLASS(pop());

        if (!bindMethod(superclass, name)) {
          return INTERPRET_RUNTIME_ERROR;
        }
        break;
      }
      case OP_EQUAL: {
        Value b = pop();
        Value a = pop();
        push(BOOL_VAL(valuesEqual(a, b)));
        break;
      }
      case OP_GREATER:  BINARY_OP(BOOL_VAL, >); break;
      case OP_LESS:     BINARY_OP(BOOL_VAL, <); break;
      case OP_ADD: {
        if (IS_STRING(peek(0)) && IS_STRING(peek(1))) {
          concatenate();
        } else if (IS_NUMBER(peek(0)) && IS_NUMBER(peek(1))) {
          double b = AS_NUMBER(pop());
          double a = AS_NUMBER(pop());
          push(NUMBER_VAL(a + b));
        } else {
          runtimeError("Operands must be two numbers or two strings.");
          return INTERPRET_RUNTIME_ERROR;
        }
        break;
      }
      case OP_SUBTRACT: BINARY_OP(NUMBER_VAL, -); break;
      case OP_MULTIPLY: BINARY_OP(NUMBER_VAL, *); break;
      case OP_DIVIDE:   BINARY_OP(NUMBER_VAL, /); break;
      case OP_NOT:
        push(BOOL_VAL(isFalsey(pop())));
        break;
      case OP_NEGATE:
        if (!IS_NUMBER(peek(0))) {
          runtimeError("Operand must be a number.");
          return INTERPRET_RUNTIME_ERROR;
        }
        push(NUMBER_VAL(-AS_NUMBER(pop())));
        break;
      case OP_PRINT: {
        printValue(pop());
        printf("\n");
        break;
      }
      case OP_JUMP: {
        uint16_t offset = READ_SHORT();
        frame->ip += offset;
        break;
      }
      case OP_JUMP_IF_FALSE: {
        uint16_t offset = READ_SHORT();
        if (isFalsey(peek(0))) frame->ip += offset;
        break;
      }
      case OP_LOOP: {
        uint16_t offset = READ_SHORT();
        frame->ip -= offset;
        break;
      }
      case OP_CALL: {
        int argCount = READ_BYTE();
        if (!callValue(peek(argCount), argCount)) {
          return INTERPRET_RUNTIME_ERROR;
        }
        frame = &vm.frames[vm.frameCount - 1];
        break;
      }
      case OP_INVOKE: {
        ObjString* method = READ_STRING();
        int argCount = READ_BYTE();
        if (!invoke(method, argCount)) {
          return INTERPRET_RUNTIME_ERROR;
        }
        frame = &vm.frames[vm.frameCount - 1];
        break;
      }
      case OP_SUPER_INVOKE: {
        ObjString* method = READ_STRING();
        int argCount = READ_BYTE();
        ObjClass* superclass = AS_CLASS(pop());
        if (!invokeFromClass(superclass, method, argCount)) {
          return INTERPRET_RUNTIME_ERROR;
        }
        frame = &vm.frames[vm.frameCount - 1];
        break;
      }
      case OP_CLOSURE: {
        ObjFunction* function = AS_FUNCTION(READ_CONSTANT());
        ObjClosure* closure = newClosure(function);
        push(OBJ_VAL(closure));

        for (int i = 0; i < closure->upvalueCount; i++) {
          uint8_t isLocal = READ_BYTE();
          uint8_t index = READ_BYTE();
          if (isLocal) {
            closure->upvalues[i] =
              captureUpvalue(frame->slots + index);
          } else {
            closure->upvalues[i] = frame->closure->upvalues[index];
          }
        }
        break;
      }
      case OP_CLOSE_UPVALUE:
        closeUpvalues(vm.stackTop - 1);
        pop();
        break;
      case OP_RETURN: {
        Value result = pop();
        closeUpvalues(frame->slots);
        vm.frameCount--;
        if (vm.frameCount == 0) {
          pop();
          return INTERPRET_OK;
        }

        vm.stackTop = frame->slots;
        push(result);
        frame = &vm.frames[vm.frameCount - 1];
        break;
      }
      case OP_CLASS:
        push(OBJ_VAL(newClass(READ_STRING())));
        break;

      case OP_INHERIT: {
        Value superclass = peek(1);

        if (!IS_CLASS(superclass)) {
          runtimeError("Superclass must be a class.");
          return INTERPRET_RUNTIME_ERROR;
        }

        ObjClass* subclass = AS_CLASS(peek(0));
        tableAddAll(&AS_CLASS(superclass)->methods,
                    &subclass->methods);
        pop();
        break;
      }
      case OP_METHOD:
        defineMethod(READ_STRING());
        break;
      }
    }
  // Restrict scope of macros to "run".
  #undef READ_BYTE
  #undef READ_SHORT
  #undef READ_CONSTANT
  #undef READ_STRING
  #undef BINARY_OP
  }

  void hack(bool b) {
    run();
    if (b) hack(false);
  }

  InterpretResult interpret(const char* source) {
    ObjFunction* function = compile(source);
    if (function == NULL) { return INTERPRET_COMPILE_ERROR; }

    push(OBJ_VAL(function));

    ObjClosure* closure = newClosure(function);
    pop();
    push(OBJ_VAL(closure));
    call(closure, 0);

    return run();
  }
#+end_src

** Debug

*** ~debug.h~

#+begin_src c :eval no
  #ifndef clox_debug_h
  #define clox_debug_h

  #include "chunk.h"

  void disassembleChunk(Chunk* chunk, const char* name);
  int disassembleInstruction(Chunk* chunk, int offset);

  #endif
#+end_src

*** ~debug.c~

#+begin_src c :eval no
  #include <stdio.h>

  #include "debug.h"
  #include "object.h"
  #include "value.h"

  void disassembleChunk(Chunk* chunk, const char* name) {
    printf("== %s ==\n", name);

    for (int offset = 0; offset < chunk->count;) {
      offset = disassembleInstruction(chunk, offset);
    }
  }

  static int constantInstruction(const char* name, Chunk* chunk, int offset) {
    uint8_t constant = chunk->code[offset + 1];
    printf("%-16s %4d '", name, constant);
    printValue(chunk->constants.values[constant]);
    printf("'\n");
    return offset + 2;
  }

  static int invokeInstruction(const char* name, Chunk* chunk, int offset) {
    uint8_t constant = chunk->code[offset + 1];
    uint8_t argCount = chunk->code[offset + 2];
    printf("%-16s (%d args) %4d '", name, argCount, constant);
    printValue(chunk->constants.values[constant]);
    printf("'\n");
    return offset + 3;
  }

  static int simpleInstruction(const char* name, int offset) {
    printf("%s\n", name);
    return offset + 1;
  }

  static int byteInstruction(const char* name, Chunk* chunk, int offset) {
    uint8_t slot = chunk->code[offset + 1];
    printf("%-16s %4d\n", name, slot);
    return offset + 2;
  }

  static int jumpInstruction(const char* name, int sign, Chunk* chunk, int offset) {
    uint16_t jump = (uint16_t)(chunk->code[offset + 1] << 8);
    jump |= chunk->code[offset + 2];
    printf("%-16s %4d -> %d\n", name, offset,
           offset + 3 + sign * jump);
    return offset + 3;
  }

  int disassembleInstruction(Chunk* chunk, int offset) {
    printf("%04d ", offset);
    if (offset > 0 && chunk->lines[offset] == chunk->lines[offset - 1]) {
      printf("   | ");
    } else {
      printf("%4d ", chunk->lines[offset]);
    }

    uint8_t instruction = chunk->code[offset];
    switch (instruction) {
    case OP_CONSTANT:
      return constantInstruction("OP_CONSTANT", chunk, offset);
    case OP_NIL:
      return simpleInstruction("OP_NIL", offset);
    case OP_TRUE:
      return simpleInstruction("OP_TRUE", offset);
    case OP_FALSE:
      return simpleInstruction("OP_FALSE", offset);
    case OP_POP:
      return simpleInstruction("OP_POP", offset);
    case OP_GET_LOCAL:
      return byteInstruction("OP_GET_LOCAL", chunk, offset);
    case OP_SET_LOCAL:
      return byteInstruction("OP_SET_LOCAL", chunk, offset);
    case OP_GET_GLOBAL:
      return constantInstruction("OP_GET_GLOBAL", chunk, offset);
    case OP_DEFINE_GLOBAL:
      return constantInstruction("OP_DEFINE_GLOBAL", chunk, offset);
    case OP_SET_GLOBAL:
      return constantInstruction("OP_SET_GLOBAL", chunk, offset);
    case OP_GET_UPVALUE:
      return byteInstruction("OP_GET_UPVALUE", chunk, offset);
    case OP_SET_UPVALUE:
      return byteInstruction("OP_SET_UPVALUE", chunk, offset);
    case OP_GET_PROPERTY:
      return constantInstruction("OP_GET_PROPERTY", chunk, offset);
    case OP_SET_PROPERTY:
      return constantInstruction("OP_SET_PROPERTY", chunk, offset);
    case OP_GET_SUPER:
      return constantInstruction("OP_GET_SUPER", chunk, offset);
    case OP_EQUAL:
      return simpleInstruction("OP_EQUAL", offset);
    case OP_GREATER:
      return simpleInstruction("OP_GREATER", offset);
    case OP_LESS:
      return simpleInstruction("OP_LESS", offset);
    case OP_ADD:
      return simpleInstruction("OP_ADD", offset);
    case OP_SUBTRACT:
      return simpleInstruction("OP_SUBTRACT", offset);
    case OP_MULTIPLY:
      return simpleInstruction("OP_MULTIPLY", offset);
    case OP_DIVIDE:
      return simpleInstruction("OP_DIVIDE", offset);
    case OP_NOT:
      return simpleInstruction("OP_NOT", offset);
    case OP_NEGATE:
      return simpleInstruction("OP_NEGATE", offset);
    case OP_PRINT:
      return simpleInstruction("OP_PRINT", offset);
    case OP_JUMP:
      return jumpInstruction("OP_JUMP", 1, chunk, offset);
    case OP_JUMP_IF_FALSE:
      return jumpInstruction("OP_JUMP_IF_FALSE", 1, chunk, offset);
    case OP_LOOP:
      return jumpInstruction("OP_LOOP", -1, chunk, offset);
    case OP_CALL:
      return byteInstruction("OP_CALL", chunk, offset);
    case OP_INVOKE:
      return invokeInstruction("OP_INVOKE", chunk, offset);
    case OP_SUPER_INVOKE:
      return invokeInstruction("OP_SUPER_INVOKE", chunk, offset);
    case OP_CLOSURE: {
      offset++;
      uint8_t constant = chunk->code[offset++];
      printf("%-16s %4d ", "OP_CLOSURE", constant);
      printValue(chunk->constants.values[constant]);
      printf("\n");

      ObjFunction* function = AS_FUNCTION(chunk->constants.values[constant]);
      for (int j = 0; j < function->upvalueCount; j++) {
        int isLocal = chunk->code[offset++];
        int index = chunk->code[offset++];
        printf("%04d      |                     %s %d\n",
               offset - 2, isLocal ? "local" : "upvalue", index);
      }

      return offset;
    }
    case OP_CLOSE_UPVALUE:
      return simpleInstruction("OP_CLOSE_UPVALUE", offset);
    case OP_RETURN:
      return simpleInstruction("OP_RETURN", offset);
    case OP_CLASS:
      return constantInstruction("OP_CLASS", chunk, offset);
    case OP_INHERIT:
      return simpleInstruction("OP_INHERIT", offset);
    case OP_METHOD:
      return constantInstruction("OP_METHOD", chunk, offset);
    default:
      printf("Unknown opcode %d\n", instruction);
      return offset + 1;
    }
  }
#+end_src
