* Value

** ~value.h~

#+begin_src c
  #ifndef clox_value_h
  #define clox_value_h

  #include <string.h>

  #include "common.h"

  typedef struct Obj Obj;
  typedef struct ObjString ObjString;

  #ifdef NAN_BOXING

  #define SIGN_BIT ((uint64_t)0x8000000000000000)
  #define QNAN     ((uint64_t)0x7ffc000000000000)

  #define TAG_NIL   1 // 01.
  #define TAG_FALSE 2 // 10.
  #define TAG_TRUE  3 // 11.

  typedef uint64_t Value;

  #define IS_BOOL(value)      (((value) | 1) == TRUE_VAL)
  #define IS_NIL(value)       ((value) == NIL_VAL)
  #define IS_NUMBER(value)    (((value) & QNAN) != QNAN)
  #define IS_OBJ(value)                                         \
    (((value) & (QNAN | SIGN_BIT)) == (QNAN | SIGN_BIT))

  #define AS_BOOL(value)      ((value) == TRUE_VAL)
  #define AS_NUMBER(value)    valueToNum(value)
  #define AS_OBJ(value)                                         \
    ((Obj*)(uintptr_t)((value) & ~(SIGN_BIT | QNAN)))
  #define BOOL_VAL(b)     ((b) ? TRUE_VAL : FALSE_VAL)
  #define FALSE_VAL       ((Value)(uint64_t)(QNAN | TAG_FALSE))
  #define TRUE_VAL        ((Value)(uint64_t)(QNAN | TAG_TRUE))
  #define NIL_VAL         ((Value)(uint64_t)(QNAN | TAG_NIL))
  #define NUMBER_VAL(num) numToValue(num)
  #define OBJ_VAL(obj)                                  \
    (Value)(SIGN_BIT | QNAN | (uint64_t)(uintptr_t)(obj))

  static inline double valueToNum(Value value) {
    double num;
    memcpy(&num, &value, sizeof(Value));
    return num;
  }

  static inline Value numToValue(double num) {
    Value value;
    memcpy(&value, &num, sizeof(double));
    return value;
  }

  #else

  typedef enum {
    VAL_BOOL,
    VAL_NIL,
    VAL_NUMBER,
    VAL_OBJ
  } ValueType;

  typedef struct {
    ValueType type;
    union {
      bool boolean;
      double number;
      Obj* obj;
    } as;
  } Value;

  #define IS_BOOL(value)    ((value).type == VAL_BOOL)
  #define IS_NIL(value)     ((value).type == VAL_NIL)
  #define IS_NUMBER(value)  ((value).type == VAL_NUMBER)
  #define IS_OBJ(value)     ((value).type == VAL_OBJ)

  #define AS_OBJ(value)     ((value).as.obj)
  #define AS_BOOL(value)    ((value).as.boolean)
  #define AS_NUMBER(value)  ((value).as.number)

  #define BOOL_VAL(value)   ((Value){VAL_BOOL, {.boolean = value}})
  #define NIL_VAL           ((Value){VAL_NIL, {.number = 0}})
  #define NUMBER_VAL(value) ((Value){VAL_NUMBER, {.number = value}})
  #define OBJ_VAL(object)   ((Value){VAL_OBJ, {.obj = (Obj*)object}})

  #endif

  typedef struct {
    int capacity;
    int count;
    Value* values;
  } ValueArray;

  bool valuesEqual(Value a, Value b);
  void initValueArray(ValueArray* array);
  void writeValueArray(ValueArray* array, Value value);
  void freeValueArray(ValueArray* array);
  void printValue(Value value);

  #endif
#+end_src

** ~value.c~

#+begin_src c
  #include <stdio.h>
  #include <string.h>
  #include "object.h"
  #include "memory.h"
  #include "value.h"

  void initValueArray(ValueArray* array) {
    array->values = NULL;
    array->capacity = 0;
    array->count = 0;
  }

  void writeValueArray(ValueArray* array, Value value) {
    if (array->capacity < array->count + 1) {
      int oldCapacity = array->capacity;
      array->capacity = GROW_CAPACITY(oldCapacity);
      array->values = GROW_ARRAY(Value, array->values, oldCapacity, array->capacity);
    }

    array->values[array->count] = value;
    array->count++;
  }

  void freeValueArray(ValueArray* array) {
    FREE_ARRAY(Value, array->values, array->capacity);
    initValueArray(array);
  }

  void printValue(Value value) {
  #ifdef NAN_BOXING
    if (IS_BOOL(value)) {
      printf(AS_BOOL(value) ? "true" : "false");
    } else if (IS_NIL(value)) {
      printf("nil");
    } else if (IS_NUMBER(value)) {
      printf("%g", AS_NUMBER(value));
    } else if (IS_OBJ(value)) {
      printObject(value);
    }
  #else
    switch (value.type) {
    case VAL_BOOL:
      printf(AS_BOOL(value) ? "true" : "false");
      break;
    case VAL_NIL: printf("nil"); break;
    case VAL_NUMBER: printf("%g", AS_NUMBER(value)); break;
    case VAL_OBJ: printObject(value); break;
    }
  #endif
  }

  bool valuesEqual(Value a, Value b) {

  #ifdef NAN_BOXING
    if (IS_NUMBER(a) && IS_NUMBER(b)) {
      return AS_NUMBER(a) == AS_NUMBER(b);
    }
    return a == b;
  #else
    if (a.type != b.type) return false;
    switch (a.type) {
    case VAL_BOOL:   return AS_BOOL(a) == AS_BOOL(b);
    case VAL_NIL:    return true;
    case VAL_NUMBER: return AS_NUMBER(a) == AS_NUMBER(b);
    case VAL_OBJ:    return AS_OBJ(a) == AS_OBJ(b);
    default:         return false; // Unreachable.
    }
  #endif
  }
#+end_src
