* LR Grammars and Parsing

*Introduction to Compilers and Language Design*, Douglas Thain

*Formal Languages* and *Set Theory*, Wikipedia

** Actions

- L :: left-to-right parse
  
- R :: Right-most derivation. Expands the right-most nonterminal. Reductions in reverse order,
  from the leaves to the root.
  
- (k) :: k-symbol lookahead.

An *LR(k)* parser has a stack and input. Given the contents of a stack and *k* tokens
of lookahead, the parser does one of the following operations:

1. *shift (SHIFT)*: Push the current input symbol onto the stack. Scan the next symbol.
  
2. *reduce (REDUCE)*: A grammar rule's right-hand side is on top of the stack. Pop the symbols
   and replace them with the grammar rule's left-hand-side nonterminal.

3. *accept (STOP)*: The parser has reached the end of the input without error, where the state
   at the top of the stack and the lookahead terminal symbol is within the subject grammar and
   represents the end of a program.

4. *reject (ERROR)*: The input is syntactically incorrect, where the state at the top of the
   stack and the lookahead symbol is not within the subject grammar.

The difference between *SLR*, *LALR*, and *LR* parsers is in the tables that they use. Different
tables use different techniques to determine when to *reduce*, and, if there is more than one grammar
rule with the same right-hand side, which left-hand-side nonterminal to push.

** Choices

*LR(k)* parsers use *deterministic finite automata (DFAs)* to choose when to shift or reduce. The symbols
pushed onto the parser's stack are not actually terminals and nonterminals. They are *states* within
a finite state machine.

- At each step, the parser runs a *DFA* using symbols on the stack as input. The input
  is a sequence of terminals and nonterminals from the bottom up.

- The current state of the *DFA* plus the next *k* tokens of the input indicate whether to shift or reduce.

- The states of a *DFA* are sets of *items*.
  - An item is a production with a *marker(.)* indicating the current position of the parser.
  - In general, item *X → γ . δ* means *γ* is at the top of the stack. At the head of the input
    there is a string derivable from *δ*

*LR* parsers use two tables: the *action* table and the *goto* table.

- action table :: Indexed by the top-of-the-stack symbol and the current token. Tells which of the four
  actions — shift, reduce, accept, reject — to perform.

- goto table :: If a rule contains *n* symbols, we pop *n* states off the stack. The *goto table* is indexed
  by state symbol *t* and nonterminal *A*, where *t* is the state symbol on the top of the stack after
  popping *n* times

** Algorithm

All *LR* parsers use this same basic algorithm. The states that are pushed onto the stack represent the states
in the underlying finite state machine. Each place we might be in the input is represented within the state as
an *item*.

The differences between *LR* parsers:

- The definition of an item.
- The number of states within the underlying finite state machine.
- The amount of information within the state.

#+begin_example
# === main loop: pseudo code ===

push initial state s0
a = scan()
loop
    t = top-of-stack (state) symbol
    switch action[t, a] {
       case shift s:
           push(s)
           a = scan()
       case reduce by A → alpha:
           for i = 1 to length(alpha) do pop() end
           t = top-of-stack symbol
           push(goto[t, A])
       case accept:
           return( SUCCESS )
       case error:
           call the error handler
           return( FAILURE )
    }
end
#+end_example

** LR(0) Automaton

*** Grammar

| rule | production |
|------+------------|
| S'   | S $        |
| S    | ( L )      |
| S    | x          |
| L    | S          |
| L    | L, S       |

*** Automaton

#+begin_example
1.
 -------------        2.             8.                   9.
| S' → .S $   |  x    --------   x   ------------    S   ----------
| S  → .(L)   |----->| S → x. |<----| L → L,.S   |----->| L → L,S. |
| S  → .x     |-+     --------      | S → .( L ) |       ----------
 -------------  |    3.             | S → .x     |
     S |      ( |     ------------   ------------
4.     V        +--->| S → (.L )  | ( |     ^
 ------------        | L → .S     |<--+     | ,
| S' → S.$   |       | L → .L, S  |         |       5.
 ------------        | S → .( L ) |  L    -----------
                     | S → .x     |----->| S → ( L.) |
                      ------------       | L → L.,S  |
                          |               -----------
                        S |                 |
                          V   7.            | )
                       --------             V        6.
                      | L → S. |          ------------
                       --------          | S → ( L ). |
                                          ------------
#+end_example

*** Action Table

1. Build action table.
2. If state contains item *X → γ.$* then *accept*.
3. If state contains item *X → γ.* then *reduce* *X → γ*.
4. If state *i* has edge to *j* with terminal, then *shift*.

| state | action           |
|-------+------------------|
|     1 | shift            |
|     2 | reduce S → x     |
|     3 | shift            |
|     4 | accept           |
|     5 | shift            |
|     6 | reduce S → ( L ) |
|     7 | reduce L → S     |
|     8 | shift            |
|     9 | reduce L → L, S  |

** LR(1) Parsing

In practice, *LR(1)* is used for *LR* parsing.

- Item is now pair *(X → γ.δ, x)*
  - *γ* is at the top of the stack, and at the head of the input there is a string derivable
    from *δx* (where *x* is the terminal).
  - Algorithm for constructing state transition table and action table adapted.
    - Closure operation when constructing states uses *FIRST()*, incorporating lookahead token.
    - Action table columns now terminals.
    - State transition relation and action table typically combined into a single table,
      *GOTO and ACTION*.

** Shift-Reduce Parsing Example

*** LR(1) Grammar

| rule | production  |
|------+-------------|
|    0 | P → E $     |
|    1 | E → T E'    |
|    2 | E' → + T E' |
|    3 | E' → ε      |
|    4 | T → 1       |

*** FIRST Table

| non-terminal | first  |
|--------------+--------|
| P            | {1}    |
| E            | {1}    |
| E'           | {+, ε} |
| T            | {1}    |

*** LR(1) Closure Table

| goto        | kernel                 | state | closure                                                  |
|-------------+------------------------+-------+----------------------------------------------------------|
|             | [ P → .E, $ ]          |     0 | [ P → .E, $ ], [ E → .T E', $ ], [ T → .1, +/$ ]         |
| goto(0, E)  | [ P → E., $ ]          |     1 | [ P → E., $ ]                                            |
| goto(0, T)  | [ E → T.E', $ ]        |     2 | [ E → T.E', $ ], [ E' → .+ T E', $ ], [ E' → ., $ ]      |
| goto(0, 1)  | [ T → 1., +/$ ]        |     3 | [ T → 1., +/$ ]                                          |
| goto(2, E') | [ E → T E' ., $ ]      |     4 | [ E → T E'., $ ]                                         |
| goto(2, +)  | [ E' → +.T E', $ ]     |     5 | [ E' → +.T E', $ ], [ T → .1, +/$ ]                      |
| goto(5, T)  | [ E' → + T.E', $ ]     |     6 | [ E' → + T.E', $ ], [ E' → .+ T E', $ ], [ E' → ., $ ]   |
| goto(5, 1)  | [ T → 1., +/$ ]        |     3 |                                                          |
| goto(6, E') | [ E' → + T E' ., $ ]   |     7 | [ E' → + T E' ., $ ]                                     |
| goto(6, +)  | [ E' → +.T E', $ ]     |     5 |                                                          |

*** LR Table: Action and Goto

| state | +  | 1  | $      | P | E | E' | T |
|-------+----+----+--------+---+---+----+---|
|     0 |    | s3 |        |   | 1 |    | 2 |
|     1 |    |    | accept |   |   |    |   |
|     2 | s5 |    | r3     |   |   |  4 |   |
|     3 | r4 |    | r4     |   |   |    |   |
|     4 |    |    | r1     |   |   |    |   |
|     5 |    | s3 |        |   |   |    | 6 |
|     6 | s5 |    | r3     |   |   |  7 |   |
|     7 |    |    | r2     |   |   |    |   |

*** Trace: ~1 + 1~

| step | stack                      | input   | action |
|------+----------------------------+---------+--------|
|    1 | 0,                         | 1 + 1 $ | s3     |
|    2 | 0, 1, 3                    | + 1 $   | r4     |
|    3 | 0, T                       | + 1 $   | 2      |
|    4 | 0, T, 2                    | + 1 $   | s5     |
|    5 | 0, T, 2, +, 5              | 1 $     | s3     |
|    6 | 0, T, 2, +, 5, 1, 3        | $       | r4     |
|    7 | 0, T, 2, +, 5, T           | $       | 6      |
|    8 | 0, T, 2, +, 5, T, 6        | $       | r3     |
|    9 | 0, T, 2, +, 5, T, 6, E'    | $       | 7      |
|   10 | 0, T, 2, +, 5, T, 6, E', 7 | $       | r2     |
|   11 | 0, T, 2, E'                | $       | 4      |
|   12 | 0, T, 2, E', 4             | $       | r1     |
|   13 | 0, E                       | $       | 1      |
|   14 | 0, E, 1                    | $       | accept |
