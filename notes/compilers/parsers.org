* Parsing for Compilers

*Introduction to Compilers and Language Design* by Douglas Thain

*Formal Languages* by Wikipedia

** Formal Languages

In logic, mathematics, computer science, and linguistics, a formal language consists of words
whose letters are taken from an alphabet and are /well-formed/ according to a specific set of rules
called a /formal grammar/.

Terminals and non-terminals are the lexical elements used in specifying the production rules
constituting a formal grammar. The terminals and non-terminals of a particular grammar are in
two completely separate sets.

*** A Classic Formalization of Generative Grammars

- A finite set *N* of non-terminal symbols.
  
- A finite set *Σ* of terminal synbols that is disjoint from *N*.
  
- A finite set of *P* of production rules, each rule of the form *(Σ ∪ N)\star{}N(Σ ∪ N)\star{} → (Σ ∪ N)\star{}*
  where *\star{}* is the Kleene star operator and *∪* denotes set union.

- In the case that the body consists solely of an empty string, the body may be denoted with
  a special notation, usually *Λ*, *e*, or *ε*.

- A distinguished symbol *S ∈ N* that is the start symbol.

** Context Free Grammars

Grammars in which the left-hand side of each production rule is always a single non-terminal.
The right-hand side of a rule is a sentential form that describes the allowable forms of the
corresponding non-terminal.

- terminal :: the elementary symbols of the language.
  
- non-terminal :: a language structure that can be replaced by sequences of terminal symbols.
  Also called syntactic variables. Includes declarations, statements, and expressions.

- sentence :: a valid sequence of terminals.
  
- sentential form :: a valid sequence of terminals and non-terminals.
  
- language :: the potentially infinite set of sentences described by a particular grammar.
  
- derivation :: a sequence of rule applications that prove a sentence is a member of a
  particular language.
  
- top-down derivation :: begin with the start symbol, applying rules to expand non-terminals
  until the desired sentenc is reached.
  
- bottom-up derivation :: begin at the desired sentence, applying rules backward until reaching
  the start symbol.

- weak equivalence :: two separate grammars that generate the same language. 

*** Top-Down Derivation

| sentential form   | apply rule |
|-------------------+------------|
| P                 | P -> E     |
| E                 | E -> E + E |
| E + E             | E -> ident |
| ident + E         | E -> E + E |
| ident + E + E     | E -> int   |
| ident + int + E   | E -> int   |
| ident + int + int |            |

*** Bottom-Up Derivation

| sential form      | apply rule |
|-------------------+------------|
| ident + int + int | E -> int   |
| ident + int + E   | E -> int   |
| ident + E + E     | E -> E + E |
| ident + E         | E -> ident |
| E + E             | E -> E + E |
| E                 | P -> E     |
| p                 |            |

*** Ambiguous Grammars

Allow for more than one possible derivation of the same sentence.

**** Left-Most Derivation

#+begin_example
        P
        |
        E
	|
      E + E
      /   \
   E + E  int
   /   \
ident  int
#+end_example

**** Right-Most Derivation

#+begin_example
      P
      |
      E
      |
    E + E
    /   \
ident  E + E
       /   \
     int   int       
#+end_example

*** LL Grammars

LL(1) grammars are a subset of CFGs that can be parsed by considering only one non-terminal and
the next token in the input stream. To make a grammar LL(1) we must do the following:

1. Remove ambiguous derivations.
2. Eliminate left recursion.
3. Eliminate any common left prefixes through left factoring.
4. Formally prove the grammar is LL(1) by generating FIRST and FOLLOW sets for the grammar.
   
