* Regular Expressions and Finite-State Automata

** Sources

| source                       | author                        |
|------------------------------+-------------------------------|
| *Foundations of Computation* | Carol Critchlow and David Eck |
| *Regular Language*           | Wikipedia                     |

** Languages

- alphabet :: A finite, non-empty set.

- symbols :: The elements of a set.

- string :: A finite sequence of symbols from an alphabet. Called a *string over an alphabet*.

  - For example, *Σ = {0, 1}* is an alphabet, and *001*, *1*, and *11* are all strings over *Σ*.

*** Operations on Strings

- length :: The number of symbols in a string. Denoted by *|x|* where *x* is a string.

- concatenation :: The combination of two strings, where *x* and *y* become *x • y* or *xy*.

  - Associative: *(xy)z = x(yz)* for all strings *x*, *y*, and *z*.

  - Non-commutative: *xy ≠ yx* for all strings *x* and *y*.

- reversal :: If *x = a_{1} a_{2} ... a_{n}* then *x^{R} = a_{n} ... a_{2} a_{1}*.

*Side Note*: By convention, *(a, b, c, ...)* are symbols and *(u, v, w, ...)* are strings.

- empty string :: The symbol *ε*, which represents a string with no symbols in it.

- Σ\star{} :: The set of strings made up of zero or more symbols from alphabet *Σ*.

A language over an alphabet *Σ* is a subset of *Σ\star{}*. Thus, a language over *Σ* is an element
of *P(Σ\star{})*, the power set of *Σ\star{}*.

For any alphabet *Σ*, the number of languages over *Σ* is uncountable. The power set of a countably
infinite set is uncountable.

- Kleene Closure :: *S\star{}*, where the union of *S⁰ ∪ S¹ ∪ S² ∪ ...* results in the set of
  all strings that is concatenated zero or more times from *S*.

** Regular Expressions

A language is *regular* if it is generated by a regular expression. The union of two regular languages
is regular. The concatenation of regular languages is regular. The Kleene closure of a regular language
is regular.

*** Formal Definition

The collection of regular languages over an alphabet *Σ* is defined recursively as follows:

1. The empty language *Ø* is a regular language.

2. For each *a ∈ Σ*, the singleton language *{a}* is a regular language.

3. If *A* is a regular language, *A\star{}* is a regular language. Due to this, the empty string
   language *{ε}* is also regular.

4. If *A* and *B* are regular languages, then *A ∪ B* and *A • B* are regular languages.

5. No other languages over *Σ* are regular.

*** Language Generated by *L(r)*

- L(Φ) = Ø :: No strings match *Φ*.

- L(ε) = {ε} :: Only *ε* matches the empty string.

- L(a) = {a} :: *a* only matches string *a*.

- L(r₁ | r₂) = L(r₁) ∪ L(r₂) :: *r₁ | r₂* matches strings *r₁* or *r₂* or both.

- L(r₁r₂) = L(r₁)L(r₂) :: *r₁r₂* matches strings where something matches *r₁* followed by *r₂*.

- L(r\star{}) = (L(r))\star{} :: *r\star{}* matches sequences of zero or more strings, each of
  which matches *r*.

- L((r)) = L(r) :: *(r)* matches exactly those strings matched by *r*.

*** Operators

| precedence | name          | operator  |
|------------+---------------+-----------|
|          1 | alternation   | *\vert{}* |
|          2 | concatenation | *•*       |
|          3 | Kleene star   | *\star{}* |

** Finite-State Automata

- finite-state automaton (FSA) :: A machine that takes as input a finite string of symbols from
  alphabet *Σ*. There is a finite set of *states* in which the machine can find itself. The state
  it is in before consuming input is called the *start state*. Some of the states are *accepting*
  or *final*. If the machine ends in such a state after completely consuming an input string, the
  string is said to be *accepted* by the machine.

- transition function :: Determines the next state according to the current state.

*** Deterministic Finite-State Automaton

*M* is specified by five components: *M = (Q, Σ, δ, q₀, F)* where

- Q :: A finite set of states.

- Σ :: Input alphabet, a finite set.

- δ : Q × Σ → Q :: The transition function.

- q₀ ∈ Q :: The start state.

- F ⊆ Q :: A subset of *Q*. The states designated as *final* or *accepting* states.

*δ* is a transition function that takes *(state, symbol)* pairs and maps each one to a state:
*δ : Q × Σ → Q*. The declaration *δ(q, a) = qp* means that if a machine is in state *q* and
the input symbol *a* is consumed, then the machine will move to state *qp*. The function *δ*
must be a total function, meaning that *δ(q, a)* must be defined for every state *q* and every
input symbol *a*. Given the current input symbol, there is only one possible move the machine
can make.

The language accepted by *M*, denoted *L(M)*, is the set of all strings *w ∈ Σ\star{}* that are
accepted by *M: L(M) = { w ∈ Σ\star{} | δ\star{}(q₀, w) ∈ F }*.

*** Non-deterministic Finite-State Automaton

*M* is specified by five components: *M = (Q, Σ, δ, q₀, F)* where

- Q :: A finite set of states.

- Σ :: Input alphabet, a finite set.

- δ : Q × (Σ ∪ {ε}) → P(Q) :: The transition function.

- q₀ ∈ Q :: The start state.

- F ⊆ Q :: A subset of *Q*. The states designated as *final* or *accepting* states.

*δ* is a transition function that takes *(state, input symbol)* pairs and maps each one to a set
of states. To say *δ(q, a) = { q₁, q₂, ..., qn }* means that if the machine is in state *q* and
the input symbol *a* is consumed, then the machine may move directly into any one of states
*q₁, q₂, ..., qn*. The function *δ* must also be defined for every *(state, ε)* pair. The formal
description of *δ* is *δ: Q × (Σ ∪ {ε}) → P(Q)*.

The language accepted by *M*, denoted *L(M)*, is the set of all strings *w ∈ Σ\star{}* that are
accepted by *M: L(M) = { w ∈ Σ\star{} | δ\star{}(q₀, w) ∩ F ≠ Ø }*.

*** NFA to DFA Conversion

The epsilon closure *E(q)* of a state *q* in *Q* is the union of the set *{q}* with the set of all states
that can be reached from *q* via one or more *ε* transitions.

If *R* is a set of states from *Q*, the epsilon closure *E(R)* is defined as the union of the epsilon
closures of all the states in *R*.

1. The set of states of the DFA is *P(Q)*, the power set of states *Q* in the original NFA.

2. The start state of the DFA is *E({q₀})*, where *q₀* is the original start state of the NFA.

3. For sets *R* in *P(Q)* and input characters *c ∈ Σ*, the transition function *δ_{n}* of the DFA is defined
   in terms of the transition function *δ* of the NFA by *δ_{n}(R,c) = U_{r ∈ R} E(δ(r,c))*.

The set of accepting states *F* of the DFA is defined to be the set of all states containing at least one
final state of the NFA.

**** Subset Construction Algorithm

#+begin_example
  while there is an unmarked state T in D-states {
      mark T
      for each input symbol a {
          U := ε-closure(move(T, a))
          if U is not in D-states {
              add U as unmarked state to D-states
          }
          D-transitions[T, a] := U
      }
  }
#+end_example
