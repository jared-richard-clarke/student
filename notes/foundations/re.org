* Regular Expressions and Finite-State Automata

** Sources

| source                       | author                        |
|------------------------------+-------------------------------|
| *Foundations of Computation* | Carol Critchlow and David Eck |
| *Regular Language*           | Wikipedia                     |

** Languages

- alphabet :: A finite, non-empty set.

- symbols :: The elements of a set.

- string :: A finite sequence of symbols from an alphabet. Called a *string over an alphabet*.

For example, *Σ = {0, 1}* is an alphabet, and *001*, *1*, and *11* are all strings over *Σ*.

*** Operations on Strings

- length :: The number of symbols in a string. Denoted by *|x|* where *x* is a string.

- concatenation :: The combination of two strings, where *x* and *y* become *x • y* or *xy*.

  - Associative: *(xy)z = x(yz)* for all strings *x*, *y*, and *z*.

  - Non-commutative: *xy ≠ yx* for all strings *x* and *y*.

- reversal :: If *x = a_{1} a_{2} ... a_{n}* then *x^R = a_{n} ... a_{2} a_{1}*.

*Side Note*: *(a, b, c, ...)* for symbols. *(u, v, w, ...)* for strings.

- empty string :: The symbol *ε*, which represents a string with no symbols in it.

- Σ\star{} :: The set of all strings over an alphabet *Σ*.

A language over an alphabet *Σ* is a subset of *Σ\star{}*. Thus, a language over *Σ* is an element
of *P(Σ\star{})*, the power set of *Σ\star{}*.

For any alphabet *Σ*, the number of languages over *Σ* is uncountable. The power set of a countably
infinite set is uncountable.

- Kleene Closure :: *S\star{}*, where the union of *S⁰ ∪ S¹ ∪ S² ∪ ...* results in the set of
  all strings that is concatenated zero or more times from *S*.

** Regular Expressions

A language is *regular* if it is generated by a regular expression. The union of two regular languages
is regular. The concatenation of regular languages is regular. The Kleene closure of a regular language
is regular.

*** Formal Definition

The collection of regular languages over an alphabet *Σ* is defined recursively as follows:

1. The empty language *Ø* is a regular language.

2. For each *a ∈ Σ*, the singleton language *{a}* is a regular language.

3. If *A* is a regular language, *A\star{}* is a regular language. Due to this, the empty string
   language *{ε}* is also regular.

4. If *A* and *B* are regular languages, then *A ∪ B* and *A • B* are regular languages.

5. No other languages over *Σ* are regular.

*** Language Generated by *L(r)*

- L(Φ) = Ø :: No strings match *Φ*.

- L(ε) = {ε} :: Only *ε* matches the empty string.

- L(a) = {a} :: *a* only matches string *a*.

- L(r₁ | r₂) = L(r₁) ∪ L(r₂) :: *r₁ | r₂* matches strings *r₁* or *r₂* or both.

- L(r₁r₂) = L(r₁)L(r₂) :: *r₁r₂* matches strings where something matches *r₁* followed by *r₂*.

- L(r\star{}) = (L(r))\star{} :: *r\star{}* matches sequences of zero or more strings, each of
  which matches *r*.

- L((r)) = L(r) :: *(r)* matches exactly those strings matched by *r*.

*** Operators

| precedence | name          | operator  |
|------------+---------------+-----------|
|          1 | alternation   | *\vert{}* |
|          2 | concatenation | *•*       |
|          3 | Kleene star   | *\star{}* |

** Finite-State Automata

- finite-state automaton (FSA) :: A machine that takes as input a finite string of symbols from
  alphabet *Σ*. There is a finite set of *states* in which the machine can find itself. The state
  it is in before consuming input is called the *start state*. Some of the states are *accepting*
  or *final*. If the machine ends in such a state after completely consuming an input string, the
  string is said to be *accepted* by the machine.

- transition function :: Determines the next state according to the current state.

*** Deterministic Finite-State Automaton

*M* is specified by five components: *M = (Q, Σ, q₀, δ, F)* where

- Q :: A finite set of states.

- Σ :: The input alphabet.

- q₀ ∈ Q :: The start state.

- F :: A subset of *Q*. The states designated as *final* or *accepting* states.

- δ :: Transition function that takes *(state, symbol)* pairs and maps each one to a state:
  *δ : Q × Σ → Q*. The declaration *δ(q, a) = qp* means that if a machine is in state *q* and
  the input symbol *a* is consumed, then the machine will move to state *qp*. The function *δ*
  must be a total function, meaning that *δ(q, a)* must be defined for every state *q* and every
  input symbol *a*. Given the current input symbol, there is only one possible move the machine
  can make.

The language accepted by *M*, denoted *L(M)*, is the set of all strings *w ∈ Σ\star{}* that are
accepted by *M: L(M) = {w ∈ Σ\star{} | δ\star{}(q₀, w) ∈ F}*.

*** Non-deterministic Finite-State Automaton

*M* is specified by five components: *M = (Q, Σ, q₀, ∂, F)* where

- *Q*, *Σ*, *q₀* and *F* are as in the definition of DFAs.

- *∂* is a transition function that takes *(state, input symbol)* pairs and maps each one to a set
  of states. To say *∂(q, a) = {q₁, q₂, ..., qn}* means that if the machine is in state *q* and
  the input symbol *a* is consumed, then the machine may move directly into any one of states
  *q₁, q₂, ..., qn*. The function *∂* must also be defined for every *(state, ε)* pair. The formal
  description of *∂* is *∂: Q × (Σ ∪ {ε}) → P(Q)*.

The language accepted by *M*, denoted *L(M)*, is the set of all strings *w ∈ Σ\star{}* that are
accepted by *M: L(M) = {w ∈ Σ\star{} | ∂\star{}(q₀, w) ∩ F ≠ Ø}*.
