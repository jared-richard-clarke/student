* Grammars

** Sources

| source                       | author                        |
|------------------------------+-------------------------------|
| *Foundations of Computation* | Carol Critchlow and David Eck |

** Context-Free Grammars

A *context-free grammar (CFG)* is a 4-tuple *(V, Σ, P, S)* where

- *V* is a finite set of symbols. The elements of *V* are the non-terminal symbols of the grammar.

- *Σ* is a finite set of symbols such that *V ∩ Σ = ∅*. The elements of *Σ* are the terminal symbols
  of the grammar.

- *P* is a set of production rules. Each rule is of the form *A → w* where *A* is one of the symbols
  in *V* and *w* is a string in the language *(V ∪ Σ)\star{}*.

- *S ∈ V*, where *S* is the start symbol of the grammar.

#+begin_example
  Grammar G = (V, Σ, P, S)

  where V = {S, E, B}
        Σ = {0, 1, +}
        P = S → E $
            E → E + B
            E → B
            B → 0
            B → 1
        S = start symbol
#+end_example

- ⇒ :: A relation on set *(V ∪ Σ)\star{}*. Reads "yields" or "produces".

- ⇒\star{} :: The reflexive and transitive closure of the relation on set *(V ∪ Σ)\star{}*.
  Reads "yields in zero or more steps" or "produces in zero or more steps".

If *G = (V, Σ, P, S)* is a context-free grammar, the language generated by *G* is the language *L(G)*
over the alphabet *Σ* defined by *L(G) = { w ∈ Σ\star{} | S ⇒\star{} w }*.

- derivation :: A sequence of one or more applications of production rules. A derivation of string *w*
  from start symbol *S* would be of the form *S ⇒ x₁ ⇒ x₂ ⇒ ... ⇒ w*.

- right-regular grammar :: A context-free grammar in which the right-hand side of every production rule
  is either the empty string *A → ε*, a string consisting of a single non-terminal symbol *B → C*, or a
  string consisting of a single terminal symbol followed by a single non-terminal symbol *D → aE*.
  Such grammars produce regular languages.

A language *L* is regular if and only if there is a right-regular grammar *G* such that *L = L(G)*.
In particular, every regular language is context-free.

** Backus-Naur Form to Context-Free Grammar

*** Backus-Naur Form

#+begin_example
  E ::= T [ "+" T ] ...
  T ::= F [ "*" F ] ...
  F ::= "(" E ")" | "x" | "y" | "z"
#+end_example

*** Context-Free Grammar

**** LL(1)

- Left-to-right scan.

- Left-most derivation.

- One symbol of lookahead.

- Top-down parse.

#+begin_example
  === grammar ===

  E → T A
  A → + T A
  A → ε
  T → F B
  B → * F B
  B → ε
  F → ( E )
  F → x
  F → y
  F → z

  === derivation ===

  E ⇒ T A           |
    ⇒ F B A         |
    ⇒ x B A         |
    ⇒ x A           |
    ⇒ x + T A       |
    ⇒ x + F B A     | parse
    ⇒ x + y B A     |
    ⇒ x + y * F B A |
    ⇒ x + y * z B A |
    ⇒ x + y * z A   |
    ⇒ x + y * z     V
#+end_example

**** LR(1)

- Left-to-right scan.

- Right-most derivation.

- One symbol of lookahead.

- Bottom-up parse.

#+begin_example
  === grammar ===

  E → E + T
  E → T
  T → T * F
  T → F
  F → ( E )
  F → x
  F → y
  F → z

  === derivation ===

  E ⇒ T             ^
    ⇒ T * F         |
    ⇒ T * z         |
    ⇒ F * z         |
    ⇒ ( E ) * z     |
    ⇒ ( E + T ) * z | parse
    ⇒ ( E + F ) * z |
    ⇒ ( E + y ) * z |
    ⇒ ( T + y ) * z |
    ⇒ ( F + y ) * z |
    ⇒ ( x + y ) * z |
#+end_example

** Pushdown Automaton

Whereas a context-free grammar *generates* a context-free language, a pushdown automaton
*recognizes* a context-free language. In fact, a language is context-free if and only if
there exists a pushdown automaton that accepts that language.

A pushdown automaton *M* is specified by six components *M = (Q, Σ, Λ, q_{0}, ∂, F)* where

- *Q* is a finite set of states.

- *Σ* is the input alphabet for *M*.

- *Λ* is the stack alphabet for *M*.

- *q_{0} ∈ Q* is the start state of *M*.

- *F ⊆ Q* is the set of final or accepting states in *M*.

- *∂* is the set of transitions in *M*. *∂* can be taken to be a finite subset of the set
  *(Q × (Σ ∪ {ε}) × Λ\star{}) × (Q × Λ\star{})*. An element *((q_{1}, σ, x), (q_{2}, y))*
  represents a transition from state *q_{1}* to state *q_{2}* in which *M* reads *σ* from its
  *∂* input string, pops *x* from the stack, and pushes *y* onto the stack.
