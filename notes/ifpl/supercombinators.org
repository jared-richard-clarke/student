* Supercombinators and Lambda Lifting

** Sources

| source                                                   | author                |
|----------------------------------------------------------+-----------------------|
| *The Implementation of Functional Programming Languages* | Simon L. Peyton Jones |

** Definitions

- combinator :: A lambda expression that contains no free variables.

- supercombinator :: Either a constant or a combinator that contains
  only supercombinators as sub-expressions.

- constant applicative forms (CAF) :: Supercombinators of arity zero.
  A constant expression that need never be instantiated.

#+begin_example
  Supercombinator, $S, of arity x:

      λx₁.x₂...λxₓ.E

  where E is not a lambda abstraction such that

  1. $S has no free variables.
  2. Any lambda abstraction in E is a supercombinator.
  3. x ≥ 0

  A supercombinator redex consists of the application of a
  supercombinator to x arguments, where x is its arity.
  A supercombinator reduction replaces a supercombinator
  redex by an instance of the supercombinator body with
  the arguments substituted for free occurrences of the
  corresponding formal parameter.

  A supercombinator reduction only takes place when all
  arguments are present. In this way, supercombinators
  are similar to multi-argument functions in other
  languages.

  || === Representation ===

    $ADD x y = + x y
  ≡ λx.λy.+ x y

  +------------------+ <
  | supercombinators | |
  | ...              | |
  |------------------| +- compilation unit
  | expression       | |
  +------------------+ <

  || --- for example -->

  +------------------+
  | $ADD x y = + x y |
  |------------------|
  | $ADD 3 4         |
  +------------------+
#+end_example

** Lambda Lifting

Unlike lambda abstractions with free variables, supercombinators are amenable
to static compilation.

#+begin_quote
  "Consider, for example, the lambda abstraction

       *λx.(λy.- y x)*

   When we apply the *λx* abstraction to an argument, *3* say,
   we instantiate its body, thus creating a brand new lambda
   abstraction *(λy.- y 3)*. Furthermore, each application of
   the *λx* abstraction to a different argument will create a
   new and different *λy* abstraction, thus making nonsense of
   our hope to compile a single fixed code sequence for each
   lambda abstraction.

   ...

   One way around this problem would be to allow the code
   sequence to access the values of free variables in some way,
   thus parameterizing the code sequence on the values of the
   free variables. This approach leads us to the SECD machine,
   in which the code sequence for a lambda abstraction has
   access to an environment which contains values for each of
   the free variables, thus allowing a single code sequence
   for each lambda abstraction. It is also the route followed
   by all block-structured languages, in which the values of
   free variables are found by looking in the appropriate stack frame.

   In this book, however, we will study a totally different approach,
   called *supercombinator graph reduction*, which does not require
   the addition of an environment to our model of graph reduction."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones
#+end_quote

*** Algorithm

Until there are no more lambda abstractions:

1. Choose any lambda abstraction that has no lambda abstractions
   in its body.

2. Convert all its free variables to extra parameters.

3. Give an arbitrary name to the lambda abstraction.

4. Replace the occurrence of the lambda abstraction by
   the name applied to the free variables.

5. Compile the lambda abstraction and associated the name
   with the compiled code.

*Side Note*: Free variables should be ordered according to scope,
with those bound at the inner scopes coming last in the parameter
list of the supercombinator.

#+begin_example
  || === Lambda Abstraction ===

  (λx.(λy.+ y x) x) 4

  || === Beta Abstraction ===

  (λy.+ y x) -> (λx.λy.+ y x) x

  || === Alpha Conversion ===

  (λx.λy.+ y x) x -> (λw.λy.+ y w) x

  || === Translation ===

  (λx.(λy.+ y x) x) 4

  (λx.(λw.λy.+ y w) x x) 4

  +----------------+
  | $Y w y = + y w |
  |----------------|
  | (λx.$Y x x) 4  |
  +----------------+

  +-----------------+
  | $Y w y = + y w  |
  | $X x   = $Y x x |
  |-----------------|
  | $X 4            |
  +-----------------+

  || === Example Program ===

  f = g 4
  g x y = y + (sqrt x)

  (f 1) + (f 2)

  || --- equivalent -->

  letrec f = g 4
         g = λx.λy.+ y (sqrt x)
  in + (f 1) (f 2)

  || --- equivalent -->

  +--------------------------+
  | $G x y = + y (sqrt x)    |
  | $F     = $G 4            |
  | $MAIN  = + ($F 1) ($F 2) |
  |--------------------------|
  | $MAIN                    |
  +--------------------------+
#+end_example

** SK Combinators

The following is a graph reduction technique based on a fixed
set of supercombinators. The most important members of this set
are *S*, *K*, and *I*. This method provides an extremely simple
reduction machine, a machine that only has to support built-in
operators and requires no template-instantiation mechanism.

#+begin_example
  || === SKI Rules ===

  +-------------------------------+
  | Reduction                     |
  |-------------------------------|
  | S f g x → f x (g x)           |
  | K c x   → c                   |
  | I x     → x                   |
  |-------------------------------|
  | Transformation                |
  |-------------------------------|
  | λx.x     ⟹ I                 |
  | λx.c     ⟹ K c, where c ≠ x  |
  | λx.e₁ e₂ ⟹ S (λx.e₁) (λx.e₂) |
  +-------------------------------+

  (S K K) - extensionally equal -> (I x)

  I x → x

  (S K K) x → K x (K x) → x


  || === SK Compilation Algorithm ===
  ||
  || For every S-transformation, a lambda abstraction
  || is compiled into two smaller lambda abstractions
  || until each lambda body is composed entirely of
  || atomic objects — identity and constant functions.

  +---------------------------------------------+
  | name      = syntactic object                |
  | e, e₁, e₂ = expressions                     |
  | f, f₁, f₂ = expressions with no inner λ     |
  | x         = variable                        |
  | cv        = constant or variable            |
  |---------------------------------------------|
  | C[ e ] = compiles e to SK combinators       |
  |                                             |
  | C[ e₁ e₂ ] = C[ e₁ ] C[ e₂ ]                |
  | C[ λx.e ]  = A x [ C[ e ] ]                 |
  | C[ cv ]    = cv                             |
  |---------------------------------------------|
  | A x [ f ] = abstracts x from f              |
  |                                             |
  | A x [ f₁ f₂ ] = S (A x [ f₁ ]) (A x [ f₂ ]) |
  | A x [ x ]     = I                           |
  | A x [ cv ]    = K cv                        |
  +---------------------------------------------+

  || === Example Transformations and Reductions ===

  || --- Transformation ---

       λx.OR x TRUE
  S ⟹ S (λx.OR x) (λx.TRUE)
  S ⟹ S (S (λx.OR) (λx.x)) (λx.TRUE)
  I ⟹ S (S (λx.OR) I) (λx.TRUE)
  K ⟹ S (S (K OR) I) (K TRUE)

  || --- Reduction ---

      S (S (K OR) I) (K TRUE) x
  S → S (K OR) I x (K TRUE x)
  S → K OR x (I x) (K TRUE x)
  K → OR (I x) (K TRUE x)
  I → OR x (K TRUE x)
  K → OR x TRUE

  || --- Transformation ---

       (λx.+ x x)
  S ⟹ S (λx.+ x) (λx.x)
  S ⟹ S (S (λx.+) (λx.x)) (λx.x)
  I ⟹ S (S (λx.+) I) (λx.x)
  I ⟹ S (S (λx.+) I) I
  K ⟹ S (S (K +) I) I

  || --- Reduction ---

    S (S (K +) I) I 5
  → S (K +) I 5 (I 5)
  → K + 5 (I 5) (I 5)
  → + (I 5) (I 5)
  → + 5 5
  → 10

  || === Extended SK  Rules ===

  +----------------------------+
  | Base                       |
  |----------------------------|
  | S f g x → f x (g x)        |
  | K c x   → c                |
  | I x     → x                |
  |----------------------------|
  | Extensions                 |
  |----------------------------|
  | B f g x    → f (g x)       |
  | C F g x    → f x g         |
  | S' c f g x → c (f x) (g x) |
  | B* c f g x → c (f (g x))   |
  | C' c f g x → c (f x) g     |
  +----------------------------+

  || === Optimized SK Compilation Algorithm ===

  +----------------------------------------------------+
  | name      = syntactic object                       |
  | e, e₁, e₂ = expressions                            |
  | f, f₁, f₂ = expressions with no inner λ            |
  | x         = variable                               |
  | cv        = constant or variable                   |
  |----------------------------------------------------|
  | C[ e ] = compiles e to SK combinators              |
  |                                                    |
  | C[ e₁ e₂ ] = C[ e₁ ] C[ e₂ ]                       |
  | C[ λx.e ]  = A x [ C[ e ] ]                        |
  | C[ cv ]    = cv                                    |
  |----------------------------------------------------|
  | A x [ f ] = abstracts x from f                     |
  |                                                    |
  | A x [ f₁ f₂ ] = Opt[ S (A x [ f₁ ]) (A x [ f₂ ]) ] |
  | A x [ x ]     = I                                  |
  | A x [ cv ]    = K cv                               |
  |----------------------------------------------------|
  | Opt[ e ] = optimizes e                             |
  |                                                    |
  | Opt[ S (K p) (K q) ]   = K (p q)                   |
  | Opt[ S (K p) I ]       = p                         |
  | Opt[ S (K p) q ]       = B* p q r                  |
  | Opt[ S (K p) q ]       = B p q                     |
  | Opt[ S (B p q) (K r) ] = C' p q r                  |
  | Opt[ S p (K q) ]       = C p q                     |
  | Opt[ S (B p q) r ]     = S' p q r                  |
  +----------------------------------------------------+
#+end_example
