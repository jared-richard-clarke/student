* Supercombinators and Lambda Lifting

** Sources

| source                                                   | author                |
|----------------------------------------------------------+-----------------------|
| *The Implementation of Functional Programming Languages* | Simon L. Peyton Jones |

** Definitions

- combinator :: A lambda expression that contains no free variables.

- supercombinator :: Either a constant or a combinator that contains
  only supercombinators as sub-expressions.

- constant applicative forms (CAF) :: Supercombinators of arity zero.
  A constant expression that need never be instantiated.

#+begin_example
  Supercombinator, $S, of arity x:

      λx₁.x₂...λxₓ.E

  where E is not a lambda abstraction such that

  1. $S has no free variables.
  2. Any lambda abstraction in E is a supercombinator.
  3. x ≥ 0

  A supercombinator redex consists of the application of a
  supercombinator to x arguments, where x is its arity.
  A supercombinator reduction replaces a supercombinator
  redex by an instance of the supercombinator body with
  the arguments substituted for free occurrences of the
  corresponding formal parameter.

  A supercombinator reduction only takes place when all
  arguments are present. In this way, supercombinators
  are similar to multi-argument functions in other
  languages.

  || === Representation ===

    $ADD x y = + x y
  ≡ λx.λy.+ x y

  +------------------+ <
  | supercombinators | |
  | ...              | |
  |------------------| +- compilation unit
  | expression       | |
  +------------------+ <

  || --- for example -->

  +------------------+
  | $ADD x y = + x y |
  |------------------|
  | $ADD 3 4         |
  +------------------+
#+end_example

** Lambda Lifting

Unlike lambda abstractions with free variableas, supercombinators are amenable
to static compilation.

#+begin_quote
  "Consider, for example, the lambda abstraction

       *λx.(λy.- y x)*

   When we apply the *λx* abstraction to an argument, *3* say,
   we instantiate its body, thus creating a brand new lambda
   abstraction *(λy.- y 3)*. Furthermore, each application of
   the *λx* abstraction to a different argument will create a
   new and different *λy* abstraction, thus making nonsense of
   our hope to compile a single fixed code sequence for each
   lambda abstraction.

   ...

   One way around this problem would be to allow the code
   sequence to access the values of free variables in some way,
   thus parameterizing the code sequence on the values of the
   free variables. This approach leads us to the SECD machine,
   in which the code sequence for a lambda abstraction has
   access to an environment which contains values for each of
   the free variables, thus allowing a single code sequence
   for each lambda abstraction. It is also the route followed
   by all block-structured languages, in which the values of
   free variables are found by looking in the appropriate stack frame.

   In this book, however, we will study a totally different approach,
   called *supercombinator graph reduction*, which does not require
   the addition of an environment to our model of graph reduction."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones
#+end_quote

*** Algorithm

Until there are no more lambda abstractions:

1. Choose any lambda abstraction that has no lambda abstractions
   in its body.

2. Convert all its free variables to extra parameters.

3. Give an arbitrary name to the lambda abstraction.

4. Replace the occurrence of the lambda abstraction by
   the name applied to the free variables.

5. Compile the lambda abstraction and associated the name
   with the compiled code.

*Side Note*: Free variables should be ordered according to scope,
with those bound at the inner scopes coming last in the parameter
list of the supercombinator.

#+begin_example
  || === Lambda Abstraction ===

  (λx.(λy.+ y x) x) 4

  || === Beta Abstraction ===

  (λy.+ y x) -> (λx.λy.+ y x) x

  || === Alpha Conversion ===

  (λx.λy.+ y x) x -> (λw.λy.+ y w) x

  || === Translation ===

  (λx.(λy.+ y x) x) 4

  (λx.(λw.λy.+ y w) x x) 4

  +----------------+
  | $Y w y = + y w |
  |----------------|
  | (λx.$Y x x) 4  |
  +----------------+

  +-----------------+
  | $Y w y = + y w  |
  | $X x   = $Y x x |
  |-----------------|
  | $X 4            |
  +-----------------+

  || === Example Program ===

  f = g 4
  g x y = y + (sqrt x)

  (f 1) + (f 2)

  || --- equivalent -->

  letrec f = g 4
         g = λx.λy.+ y (sqrt x)
  in + (f 1) (f 2)

  || --- equivalent -->

  +--------------------------+
  | $G x y = + y (sqrt x)    |
  | $F     = $G 4            |
  | $MAIN  = + ($F 1) ($F 2) |
  |--------------------------|
  | $MAIN                    |
  +--------------------------+
#+end_example

** SK Combinators

#+begin_example
  || === SKI Rules ===

  +-------------------------------+
  | Reduction                     |
  |-------------------------------|
  | S f g x → f x (g x)           |
  | K c x   → c                   |
  | I x     → x                   |
  |-------------------------------|
  | Transformation                |
  |-------------------------------|
  | λx.x     ⟹ I                 |
  | λx.c     ⟹ K c, where c ≠ x  |
  | λx.e₁ e₂ ⟹ S (λx.e₁) (λx.e₂) |
  +-------------------------------+

  || === SK Compilation Algorithm ===

  +---------------------------------------------+
  | name      = syntactic object                |
  | e, e₁, e₂ = expressions                     |
  | f, f₁, f₂ = expressions with no inner λ     |
  | x         = variable                        |
  | cv        = constant or variable            |
  |---------------------------------------------|
  | C[ e ] = compiles e to SK combinators       |
  |                                             |
  | C[ e₁ e₂ ] = C[ e₁ ] C[ e₂ ]                |
  | C[ λx.e ]  = A x [ C[ e ] ]                 |
  | C[ cv ]    = cv                             |
  |---------------------------------------------|
  | A x [ f ] = abstracts x from f              |
  |                                             |
  | A x [ f₁ f₂ ] = S (A x [ f₁ ]) (A x [ f₂ ]) |
  | A x [ x ]     = I                           |
  | A x [ cv ]    = K cv                        |
  +---------------------------------------------+
#+end_example
