* Polymorphic Type Checking

** Sources

| source                                                   | author                |
|----------------------------------------------------------+-----------------------|
| *The Implementation of Functional Programming Lanugages* | Simon L. Peyton Jones |
| *Hindley-Milner Type System*                             | Wikipedia             |
| *Write You a Haskell*                                    | Stephen Diehl         |
| *Type Systems: Lambda Calculus to Hindley Milner*        | Adam Jones            |
| *Implementing a Hindley-Milner Type System*              | 05st                  |

** Notation

#+begin_example
  === value :: TYPE ===

  a :: A

  === tuple ===

  - Coordinates need not be the same type.
  - Tuple type determines dimension and internal types.

  (A₁ ... Aₓ) <- type

  (a₁ ... aₓ) <- value

  === list ===

  - []
  - a:as, where a:A and as::[A]

  [A]         <- type

  [a₁ ... aₓ] <- value, if all successive entries
                 of a finite list are known.

  === structured type ===

  name v₁ ... vₓ ::= c₁ t₁₁ ... t₁ₓ
                   | ...
                   | cₓ tₓ₁ ... tₓₓ

  where name = type-forming operator
        vₓ   = type variable
        cₓ   = constructor
        tₓ   = type expression

  === function ===
  - Function "f" applicable to objects a::A, whose values, (f a),
    are of type B.

  A -> B

  - right associative, binary operation
  A -> B -> C = A -> (B -> C)
#+end_example

** Polymorphism

- monomorphic :: Operations accept values of one type.

- polymorphic :: Operations accept values of more than one type.

- ad hoc polymorphism :: A type discipline that permits the same expression
  to denote distinct operations for distinct types. The addition operator
  might denote the addition of both integers, rationals, reals, and complex
  numbers.

- parametric polymorphism :: A type discipline where operations work uniformly
  for arguments of different types. Polymorphic expressions are denoted by
  schematic variables. Polymorphic types become monomorphic by consistent
  substitution of their schematic variables.

#+begin_src
  || === parametric polymorphic ===
  ||
  || A = schematic variable

  length :: [A] -> num
  length []     = 0
  length (x:xs) = (length xs) +  1

  || === monomorphic ===

  length :: [num] -> num
  length [7, 11]

  length :: [(char, char)] -> num
  length [('a', 'b'), ('c', 'd')]

  || === parametric polymorphic ===
  ||
  || A, B, C = schematic variables

  (.) :: (B -> C) -> (A -> B) -> A -> C
  (f . g) x = f (g x)

  || === parametric polymorphic ===
  ||
  || A, B = schematic variables

  foldr :: (A -> B -> B) -> B -> [A] -> B
  foldr f b []     = b
  foldr f b (a:as) = f a (foldr f b as)

  || === monomorphic ===

  foldr :: (num -> num -> num) -> num -> [num] -> num
  foldr + 0 [7, 11, 15]

  foldr :: (string -> string -> string) -> string -> [string] -> string
  foldr append [] ["abc", "def", "ghi"]
#+end_src

** Type Inference

#+begin_quote
  "...[W]e have two type expressions that will usually contain variables,
   the first giving the form of the type required by the context
   (deduced from the 'outside'), and the second giving the form of the type
   which the object can take (deduced from the 'inside'). For the whole
   expression to be well typed, these two type expressions must match,
   in the sense that by substituting for the schematic variables
   of the type expressions, they can be brought to the same form."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
#+end_quote

In order to be sure that expression *(E_{1} E_{2})* is well-typed, the function *E_{1}*
must have type *(A -> B)*, where *E_{2}* is of type *A* and *(E_{1} E_{2})* is of type
*B*.

- The function *f* of an application *(f a)* has type *(A -> V)*,
  where *a* has type *A* and *(f a)* has type *V*.

- All occurrences of a λ-bound variable must have the same types.

- If two compound type expressions are equal, then they must be formed with
  the same construction and their corresponding parts must be equal.
  More specifically: if *(T1 -> T2) = (T1' -> T2')*, then *T1 = T1'* and *T2 = T2'*.

- If *T1 = ...T1...*, where type variable *T1* occurs properly within
  the right-hand side of the equation, then the system of equations
  cannot be solved, and the expression from which the system was derived
  is ill-typed.

#+begin_example
  || === expression ===

  (λx.λy.λz. x z (y z))

  || === AST ===

  x   z y   z
   \ /   \ /
    @     @
    |     |
    +--@--+
       |
    λx.λy.λz

  || === type tree ===

  x::T0 z::T1    y::T2 z::T3
  ----------- @  ----------- @
       T4             T5
       ----------------- @
              T6
              -- λx.λy.λz
              T7

  || === constraints ===

  - The types of the sub-expressions must be related
  - by the following equations:

  T0 ~ T1 -> T4
  T2 ~ T3 -> T5
  T4 ~ T5 -> T6

  - If we assume both instances of lambda-bound "z"
  - are of the same type, we add the two equations:

  T1 ~ T3
  T7 ~ (T0              -> T2         -> T1 -> T6)
       (T1 -> T5 -> T6) -> (T1 -> T5) -> T1 -> T6
       (A  -> B  -> C)  -> (A  -> B)  -> A  -> C

  || === expression ===

  odd :: Integer -> Boolean
  age :: Integer

  odd age

  || === type tree ===

  odd : T4 ∈ Γ               age : T5 ∈ Γ
  ------------------ [Var]   ------------ [Var]
  Γ ⊢ odd : T1 -> T2         Γ ⊢ age : T3
  --------------------------------------- [App]
             Γ ⊢ odd age : T0

  || === constraints ===

        T0 ~ T2
        T1 ~ T3
  T1 -> T2 ~ T4
        T4 ~ Integer -> Boolean
        T3 ~ T5
        T5 ~ Integer

  || === unification ===

  odd : Integer -> Boolean ∈ Γ         age : Integer ∈ Γ
  ---------------------------- [Var]   ----------------- [Var]
  Γ ⊢ odd : Integer -> Boolean         Γ ⊢ age : Integer
  ------------------------------------------------------ [App]
                    Γ ⊢ odd age : Boolean
#+end_example

** Intermediate Language

A transformed program should be type checked after dependency analysis
but before lambda lifting or transformation into a supercombinator.

#+begin_example
  expression ::= variable
               | λvariable.expression
               | expression expression
               | let variable-1 = expression-1
                     ...
                     variable-x = expression-x
                 in expression
               | letrec variable-1 = expression-1
                        ...
                        variable-x = expression-x
                 in <expression>
#+end_example

** Hindley-Milner Type System

#+begin_example
  || === Expressions ===

  e = x
    | e₁ e₂
    | λx.e
    | let x = e₁ in e₂

  || === Types ===

  || --- monotype ---
  ||
  || Monotypes designate a particular type. Not to be confused
  || with monomorphic types, which exclude variables and allow
  || only ground terms.

  τ = α
    | C τ ... τ

  where α = type variable
        C = type constructor

  || --- polytype ---
  ||
  || Polytypes — or type schemes — are types containing
  || variables bound by zero or more for-all quantifiers.
  || Qualifiers can only appear top level. ∀α.α -> ∀α.α
  || is not allowed.

  σ = τ
    | ∀α.σ

  where τ    = monotype
        ∀α.σ = for-all quantifier

  +----------------------------------------+
  |     +--------------------------------+ |
  |     | +----------------------------+ | |
  |     | |      +-------------------+ | | |
  |     | |      |   +---+   +---+   | | | |
  | ∀α. | | List | ( | α | → | α | ) | | | |
  |     | |      |   +var+   +var+   | | | |
  |     | |      +--- constructor ---+ | | |
  |     | +---------- constructor -----+ | |
  |     +------------ monotype ----------+ |
  +------------------ quantifier ----------+


  || === Context and Typing ===
  ||
  || Brings together syntax expressions and types.

  || --- context --
  ||
  || A context is a list of pairs (x : σ).

  Γ = ε (empty)
    | Γ, x : σ

  || --- typing ---
  ||
  || Under the assumptions Γ, the expression e has type σ.

  Γ ⊢ e : σ

  || === Free Type Variables ===
  ||
  || For type ∀α₁ ... ∀αₓ.τ, ∀ is the quantifier binding the type variables
  || αₓ in the monotype τ.

  free(α)           = {α}

                       x
  free(C τ₁ ... τₓ) =  ∪ free(τᵢ)
                     i = 1

  free(Γ)           =  ∪ free(σ)
                     x : σ ∈ Γ

  free(∀α.σ)        = free(σ) - {α}

  free(Γ ⊢ e : σ)   = free(σ) - free(Γ)

  || === Syntax of Rules ===

  Predicate  = σ₁ ⊑ σ₂
             | α ∉ free(Γ)
             | x : σ ∈ Γ

  Judgement  = Typing

  Premise    = Judgement | Predicate

  Conclusion = Judgement

               Premise ...
  Rule       = ----------- [Name]
               Conclusion

  || === Declarative Rule System ===

  || --- Variable ---

  x : σ ∈ Γ
  ---------                        [Var]
  Γ ⊢ x : σ

  || --- Application ---

  Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
  -------------------------------- [App]
           Γ ⊢ e₁ e₂ : τ₂

  || --- Abstraction ---

  Γ, x : τ₁ ⊢ e : τ₂
  -------------------              [Abs]
  Γ ⊢ λx.e : τ₁ → τ₂

  || --- Let ---

  Γ ⊢ e₁ : σ   Γ, x : σ ⊢ e₂ : τ
  -------------------------------  [Let]
     Γ ⊢ let x = e₁ in e₂ : τ

  || --- Instantiation ---
  ||
  || Replace all instances of a quantified type variable
  || with a fresh monotype variable.
  ||
  || σ₁ ⊑ σ₂ reads "σ₁ is either more general than or equally general to σ₂".
  || More formally, σ₁ is more general than σ₂ if there is a substitution S
  || that maps the for-all quantified variables in σ₁, and S(σ₁) = σ₂

  Γ ⊢ e : σ₁    σ₁ ⊑ σ₂
  ---------------------            [Inst]
       Γ ⊢ e : σ₂

  || --- Generalization ---
  ||
  || Converts monotype τ into polytype σ by closing
  || over all free type variables in τ.

  Γ ⊢ e : σ    α ∉ free(Γ)
  ------------------------         [Gen]
      Γ ⊢ e : ∀α.σ

  || === Syntactical Rule System ===

  || --- Variable and Instantiation ---

   x : σ ∈ Γ    σ ⊑ τ
   ------------------                    [Var]
       Γ ⊢ x : τ

  || --- Application ---

  Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
  --------------------------------       [App]
           Γ ⊢ e₁ e₂ : τ₂

  || --- Abstraction ---

  Γ, x : τ₁ ⊢ e : τ₂
  -------------------                    [Abs]
  Γ ⊢ λx.e : τ₁ → τ₂

  || --- Let and Generalization ---
                       -
  Γ ⊢ e₁ : τ₁   Γ, x : Γ(τ₁) ⊢ e₂ : τ₂
  -------------------------------------  [Let]
        Γ ⊢ let x = e₁ in e₂ : τ₂

  || Quantify all monotype variables not bound in Γ
  || to give the most general type for a given
  || expression.

  -
  Γ(τ) = ∀α₁...αₓ.τ

  α₁...αₓ = free(τ) - free(Γ)

  || === Recursive Extension ===
  ||
  || Merge [Abs] and [Let], where left of "in" allows monotype variables
  || and right of "in" allows polytype variables.

  Γ, Γ' ⊢ e₁ : τ₁ ... Γ, Γ' ⊢ eₓ : τₓ    Γ, Γ'' ⊢ e : τ
  ------------------------------------------------------ [Letrec]
  Γ ⊢ letrec v₁ = e₁ ... vₓ = eₓ in e : τ

  || --- monotype variables ---
  where Γ'  = v₁ : τ₁, ... , vₓ : τₓ
  || --- polytype variables ---
                   -                 -
        Γ'' = v₁ : Γ(τ₁), ... , vₓ : Γ(τₓ)
#+end_example

*** Unification

- substitution :: A mapping from a free variable in a type to its corresponding
  term in an environment.

- constraint :: A requirement that two types have a common substitution
  instance.

- unification :: A partial function that either turns a set of constraints
  into a substitution or fails when it encounters unsatisfiable constraints.
  A unification algorithm may be described in three parts:

  1. Any type variable unifies with any type expression, and is instantiated
     to that expression. A specific theory might restrict this rule with an
     occurs check.

  2. Two type constants unify only if they are the same type.

  3. Two type constructions unify only if they are applications of the same
     type constructor and all of their component types recursively unify.

#+begin_example
  || === unification ===

  || Terms "a" and "b" are unifiable by substitution "s".

  a ~ b (s) = [s]a = [s]b

  || --- same ---

  α ~ α ([])

  || --- left-hand side ---

  α ∉ free(τ)
  ---------------
  α ~ τ ([α ↦ τ])

  || --- right-hand side ---

  α ∉ free(τ)
  ---------------
  τ ~ α ([α ↦ τ])

  || --- arrow (→) ---

  τ₁ ~ τ'₂ (s₁)    [s₁]τ₂ ~ [s₁]τ'₂ (s₂)
  --------------------------------------
  τ₁ → τ₂ ~ τ'₁ → τ'₂ (s₂ ∘ s₁)
#+end_example

** Inference Algorithms

*** Algorithm J

#+begin_example
  x : σ ∈ Γ    τ = inst(σ)
  ------------------------                                        [Var]
  Γ ⊢ x : τ

  Γ ⊢ e₁ : τ₁    Γ ⊢ e₂ : τ₂    τ' = newvar    unify(τ₁, τ₂ → τ')
  --------------------------------------------------------------- [App]
  Γ ⊢ e₁ e₂ : τ'

  τ = newvar    Γ, x : τ ⊢ e : τ'
  -------------------------------                                 [Abs]
  Γ ⊢ λx.e : τ → τ'
                       -
  Γ ⊢ e₁ : τ    Γ, x : Γ(τ) ⊢ e₂ : τ'
  ------------------------------------                            [Let]
  Γ ⊢ let x = e₁ in e₂ : τ'

  || "inst(σ)" specializes the polytype "σ" by copying the term
  || and replacing bound type variables consistently by new
  || monotype variables.

  || "newvar" produces new monotype variables.

  || Quantify all monotype variables not bound in Γ
  || to give the most general type for a given
  || expression.

  -
  Γ(τ) = ∀α₁...αₓ.τ

  α₁...αₓ = free(τ) - free(Γ)
#+end_example

*** Algorithm W

Makes the side effects imposed by the procedure *unify* explicit by expressing
its serial composition by means of the substitution *Sₓ*. The judgement
*Γ ⊢ e : τ, S* denotes a function that accepts a context and expression and
returns a monotype and substitution pairing.

#+begin_example
  x : σ ∈ Γ    τ = inst(σ)
  ------------------------                         [Var]
  Γ ⊢ x : τ, ∅

  Γ ⊢ e₁ : τ₁, S₁    S₁Γ ⊢ e₂ : τ₂, S₂
  τ' = newvar        S₃ = mgu(S₂τ₁, τ₂ → τ')
  ------------------------------------------       [App]
  Γ ⊢ e₁ e₂ : S₃τ', S₃S₂S₁

  τ = newvar    Γ, x : τ ⊢ e : τ', S
  ----------------------------------               [Abs]
  Γ ⊢ λx.e : Sτ → τ', S
                               -
  Γ ⊢ e₁ : τ , S₁   S₁Γ, x : S₁Γ(τ) ⊢ e₂ : τ', S₁
  ------------------------------------------------ [Let]
  Γ ⊢ let x = e₁ in e₂ : τ', S₂S₁

  || "mgu" is a side-effect free version of "unify", producing a substitution,
  || which is the most general unifier.

  || Quantify all monotype variables not bound in Γ
  || to give the most general type for a given
  || expression.

  -
  Γ(τ) = ∀α₁...αₓ.τ

  α₁...αₓ = free(τ) - free(Γ)
#+end_example

** Miranda Example

1. *Assign type variables*: Assign fresh type variables to expressions whose
   type is unknown.

2. *Collect constraints*: Traverse the abstract syntax tree of a program,
   gathering type constraints based on how expressions are used.
   If *f* has type *T1 -> T2*, then *x* in *(f x)* must have type *T1*.

3. *Unify*: Find substitutions for type variables that satisfy all constraints.
   Determine either the concrete types or most general polymorphic types.
   Consistent substitution means an expression is well-typed.

4. *Generalize*: For a ~let~ expression, the inferred monotype for the bound
   value is generalized to a polytype by quantifying over all free type variables,
   allowing the bound variable to be different types in the body of the expression.

#+begin_quote
  "There is a partial analogy between type schemes and lambda abstractions.
   The schematic variables of a type scheme correspond to the formal parameter
   of a lambda abstraction, and the unknowns of a type scheme correspond to
   the free variables of a lambda abstraction. Applying a lambda abstraction
   to an argument involves constructing an instance of its body, substituting
   the argument for occurrences of the formal parameter
   (but copying free variables unchanged). This is very similar to the process
   of instantiating a type scheme, which involves constructing an instance
   of the type scheme template, substituting fresh type variables for
   occurrences of the schematic variables (but copying unknowns unchanged)."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
#+end_quote

#+begin_src
  || === Program Expressions ===

  vname == [char]

  vexp ::= VAR vname
         | LAMBDA vname vexp
         | AP vexp vexp
         | LET [vname] [vexp] vexp
         | LETREC [vname] [vexp] vexp

  || === Type Expressions ===

  tvname == [char]

  type_exp ::= TVAR tvname             || type variable
             | TCONS [char] [type_exp] || concrete type

  || t1 -> t2

  arrow :: type_exp -> type_exp
  arrow t1 t2 = TCONS "arrow" [t1, t2]

  int :: type_exp
  int = TCONS "int" []

  || (t1, t2)

  cross :: type_exp -> type_exp -> type_exp
  cross t1 t2 = TCONS "cross" [t1, t2]

  || [t]

  list :: type_exp type_exp
  list t = TCONS "list" [t]

  || Returns a list of the variable names that occur in a type expression.

  tvars_in :: type_exp -> [tvname]
  tvars t = f t []
            where
                f (TVAR x) xs     = x:xs
                f (TCONS y ts) xs = foldr f xs ts

  || === Success and Failure ===

  reply * ::= OK * | FAILURE

  || === Solving Equations ===
  ||
  || "An alleged solution of a system of type equations can be expressed
  ||  as a function from type variables (the unknowns) to type expressions
  ||  (their values)...[E]quations are satisfied when we replace (i.e. substitute)
  ||  the unknowns by their values under the function."
  ||
  || — Chapter 9: A Type-checker, Peter Hancock

  || substitutions

  subst == tvname -> type_exp

  || Derives a type expression by performing the phi substitution
  || on all the type variables in te.

  sub_type :: subst -> type_exp -> type_exp
  sub_type phi (TVAR tvn)     = phi tvn
  sub_type phi (TCONS tcn ts) = TCONS tcn (map (sub_type phi) ts)

  map :: (* -> **) -> [*] -> [**]
  map f []     = []
  map f (x:xs) = f x : map f xs

  || composition: sub_type (scomp phi psi) = (sub_type phi) ∘ (sub_type psi)

  scomp :: subst -> subst -> subst
  scomp sub2 sub1 tvn = sub_type sub2 (sub1 tvn)

  || identity: sub_type id_subst t = t

  id_subst :: subst
  id_subst tvn = TVAR tvn

  || delta substitution
  ||
  || (sub_type (delta tvn t)) maps a type expression to "t"
  || where before it had "(TVAR tvn)".

  delta :: tvname -> type_exp -> subst
  delta tvn t tvn' = t,           if tvn = tvn'
                   = TVAR tvn',   otherwise

  || idempotent: (sub_type phi) ∘ (sub_type phi) = sub_type phi
  ||
  || fixed point: sub_type phi t = t

  || === Unification ===
  ||
  || "The problem of unification is to find a maximally general
  ||  idempotent unifier of a set of pairs of expressions."
  ||
  || — Chapter 9: A Type-checker, Peter Hancock
  ||
  || type expression: (t1, t2) or t1 = t2
  ||
  || phi unifies (t1, t2) if sub_type phi t1 = sub_type phi t2

  || Expression (extend phi tvn t) will only be evaluated when:
  ||
  || 1. phi is an idempotent substitution (the solution we are trying to extend)
  || 2. t is a fixed point of phi
  || 3. tvn is unmoved by phi (tvn does not already have a value under phi)
  ||
  || Given a pair (t1, t2) of type expressions, and an idempotent
  || substitution phi, our algorithm should return FAILURE if there
  || is no extension of phi that unifies (t1, t2), and it should
  || return (OK psi), where psi is an idempotent unifier of (t1, t2)
  || that extends phi.

  extend :: subst -> tvname -> type_exp -> reply subst
  extend phi tvn t = OK phi,                        if t = TVAR tvn
                   = FAILURE,                       if tvn $in (tvars_in t)
                   = OK (scomp (delta tvn t) phi),  otherwise

  || --- unification algorithm ---

  unify :: subst -> (type_exp, type_exp) -> reply subst

  unify phi ((TVAR tvn), t)
      = extend phi tvn phit,       if phitvn = TVAR tvn
      = unify phi (phitvn, phit),  otherwise
        where phitvn = phi tvn
              phit   = sub_type phi t

  unify phi ((TCONS tcn ts), (TVAR tvn))
      = unify phi ((TVAR tv), (TCONS tcn ts))

  unify phi ((TCONS tcn ts), (TCONS tcn' ts'))
      = unifyl phi (zip ts ts'),    if tcn = tcn'
      = FAILURE,                    otherwise

  zip :: [*] -> [**] -> [(*, **)]
  zip [] xs     = []
  zip (x:xs) [] = []
  zip (x:xs) (y:ys) = (x, y) : zip xs ys

  || (unifyl phi pts) constructs a substitution extending phi,
  || which unifies corresponding entries in the list of pairs pts.

  unifyl :: subst -> [(type_exp, type_exp)] -> reply subst
  unifyl phi eqns = foldr f (OK phi) eqns
                    where
                        f eqn (OK phi) = unify phi eqn
                        f eqn FAILURE  = FAILURE

  || === Type Scheme ===
  ||
  || 1. The schematic type variables in a type scheme associated
  ||    with a variable are those that may be freely instantiated
  ||    to conform with the type constraints on various occurrences
  ||    of that variable. Also known as generic variables.
  ||
  || 2. All other variables in a type scheme are constrained
  ||    and must not be instantiated. They are the unknowns,
  ||    type variables whose values we seek by solving the
  ||    system of type constraints implied by the structure
  ||    of an expression. Also known as non-generic variables.

  type_scheme ::= SCHEME [tvname] type_exp

  unknowns_scheme :: type_scheme -> [tvname]
  unknowns_scheme (SCHEME scvs t) = tvars_in (bar t scvs)

  bar :: [*] -> [*] -> [*]
  bar xs ys = [ x <- xs | ~(x $in ys)]

  in :: * -> [*] -> bool
  in x' []     = False
  in x' (x:xs) = True,      if x = x'
               = x' $in xs, otherwise

  sub_scheme :: subst -> type_scheme -> type_scheme
  sub_scheme phi (SCHEME scvs t)
      = SCHEME scvs (sub_type (exclude phi scvs) t)

  exclude phi scvs tvn = TVAR tvn,    if tvn $in scvs
                       = phi tvn,     otherwise

  || type environment = [(free variable, type scheme)]

  assoc_list * ** == [(*, **)]

  dom :: assoc_list * ** -> [*]
  dom al = [ k | (k, v) <- al ]

  val :: assoc_list * ** -> * -> **
  val al k = hd [ v | (k', v) <- al; k = k' ]

  install al k v = (k, v):al

  rng :: assoc_list * ** -> [**]
  rng al = map (val al) (dom al)

  type_env == assoc_list vname type_scheme

  unknowns_te :: type_env -> [tvname]
  unknowns_te gamma = appendlist (map unknowns_scheme (rng gamma))

  appendlist :: [ [*] ] -> [*]
  appendlist lls = foldr (++) [] lls

  sub_te :: subst -> type_env -> type_env
  sub_te phi gamma
      = [ (x, sub_scheme phi st) | (x, st) <- gamma ]

  || === new variables ===

  next_name :: name_supply -> tvname
  deplete   :: name_supply -> name_supply
  split     :: name_supply -> (name_supply, name_supply)

  tvname      == [num]
  name_supply == tvname

  next_name ns   = ns
  deplete (n:ns) = (n+2:ns)
  split ns       = (0:ns, 1:ns)

  name_sequence :: name_supply -> [tvname]
  name_sequence ns = next_name ns : name_sequence (deplete ns)

  || === Type Checker ===
  ||
  || (tc gamma ns e) -> reply (phi, t)
  ||
  || where gamma = type environment
  ||       ns    = supply of type variable names
  ||       e     = expression to be checked
  ||       phi   = substitution defined on unknown type variables in gamma
  ||       t     = a type derived for the expression e
  ||               in the type environment (sub_te phi gamma).
  ||               Fixed point of the substitution of phi.

  tc :: type_env -> name_supply -> vexp -> reply (subst, type_exp)
  tc gamma ns (VAR x)          = tcvar gamma ns x
  tc gamma ns (AP e1 e2)       = tcap gamma ns e1 e2
  tc gamma ns (LAMBDA x e)     = tclambda gamma ns x e
  tc gamma ns (LET xs es e)    = tclet gamma ns xs es e
  tc gamma ns (LETREC xs es e) = tcletrec gamma ns xs es e

  || --- type checking lists of expressions ---

  tcl :: type_env -> name_supply -> [vexp] -> reply (subst, [type_exp])
  tcl gamma ns []     = OK (id_subst, [])
  tcl gamma ns (e:es) = tcl1 gamma ns0 es (tc gamma ns1 e)
                        where (ns0, ns1) =  split ns

  tcl1 gamma ns es FAILURE       = FAILURE
  tcl1 gamma ns es (OK (phi, t)) = tcl2 phi t (tcl gamma' ns es)
                                   where gamma' = sub_te phi gamma

  tcl2 phi t FAILURE        = FAILURE
  tcl2 phi t (OK (psi, ts)) = OK (scomp psi phi, (subt_type psi t) : ts)

  || --- variables ---

  tcvar :: type_env -> name_supply -> vname -> reply (subst, type_exp)
  tcvar gamma ns x = OK (id_subst, newinstance ns scheme)
                     where scheme = val gamma x

  newinstance :: name_supply -> type_scheme -> type_exp
  newinstance ns (SCHEME scvs t) =
      sub_type phi t
      where al  = zip scvs (name_sequence ns)
            phi = al_to_subst al

  al_to_subst :: assoc_list tvname tvname -> subst
  al_to_subst al tvn = TVAR (val al tvn),    if tvn $in (dom al)
                     = TVAR tvn,             otherwise

  || --- application ---

  tcap :: type_env -> name_supply -> vexp -> vexp -> reply (subst, type_exp)
  tcap gamma ns e1 e2
      = tcap1 tvn (tcl gamma ns' [e1, e2])
        where tvn = next_name ns
              ns' = deplete ns

  tcap1 tvn FAILURE = FAILURE
  tcap1 tvn (OK (phi, [t1, t2]))
      = tcap2 tvn (unify phi (t1, arrow t2 (TVAR tvn)))

  tcap2 tvn FAILURE = FAILURE
  tcap2 tvn (OK phi) = OK (phi, phi tvn)

  || --- Lambda Abstractions ---

  tclambda :: type_env -> name_supply -> vname -> vexp -> reply (subst, type_exp)
  tclambda gamma ns x e
      = tclambda1 tvn (tc gamma' ns' e)
        where ns'   = deplete ns
              gamma = new_bvar (x, tvn) : gamma
              tvn   = next_name ns

  tclambda1 tvn FAILURE       = FAILURE
  tclambda1 tvn (OK (phi, t)) = OK (phi, arrow (phi tvn) t)

  new_bvar (x, tvn) = (x, SCHEME [] (TVAR tvn))

  || --- let expressions ---

  tclet :: type_env -> name_supply
           -> [vname] -> [vexp] -> vexp
           -> reply (subst, type_exp)
  tclet gamma ns xs es e
      = tclet1 gamma ns0 xs e (tcl gamma ns1 es)
        where (ns0, ns1) = split ns

  tclet1 gamma ns xs e FAILURE = FAILURE
  tclet1 gamma ns xs e (OK (phi, ts))
      = tclet2 phi (tc gamma'' ns1 e)
        where gamma''    = add_decls gamma' ns0 xs ts
              gamma'     = sub_te phi gamma
              (ns0, ns1) = split ns

  tclet2 phi FAILURE        = FAILURE
  tclet2 phi (OK (phi', t)) = OK (scomp phi' phi, t)

  || Update a type environment "gamma" so that it associates schematic types
  || formed from the types "ts" with the variables "xs".

  add_decls :: type_env -> name_supply -> [vname] -> [type_exp] -> type_env
  add_decls gamma ns xs ts
      = (zip xs schemes) ++ gamma
        where schemes  = map (genbar unknowns ns) ts
              unknowns = unknowns_te gamma

  genbar unknowns ns t
      = SCHEME (map snd al) t'
        where al   = zip scvs (name_sequence ns)
              scvs = bar (nodups (tvars_in t)) unknowns
              t'   = sub_type (al_to_subst al) t

  fst :: (*, **) -> *
  fst (x, y) = x

  snd :: (*, **) -> **
  snd (x, y) = y

  nodups xs = f [] xs
              where
                  f acc [] = acc
                  f acc (x:xs) = f acc xs,       if x $in acc
                               = f (x:acc) xs    otherwise

  || --- letrec expressions ---

  tcletrec :: type_env -> name_supply
              -> [vname] -> [vexp] -> vexp
              -> reply (subst, type_exp)
  tcletrec gamma ns xs es e
      = tcletrec1 gamma ns0 nbvs e (tcl (nbvs ++ gamma) ns1 es)
        where (ns0, ns') = split ns
              (ns1, ns2) = split ns'
              nbvs       = new_bvars xs ns2

  new_bvars xs ns = map new_bvar (zip xs (name_sequence ns))

  tcletrec1 gamma ns nbvs e FAILURE = FAILURE
  tcletrec1 gamma ns nbvs e (OK (phi, ts))
      = tcletrec2 gamma' ns nbvs' e (unifyl phi (zip ts ts'))
        where ts'    = map old_bvar nbvs'
              nbvs'  = sub_te phi nbvs
              gamma' = sub_te phi gamma

  old_bvar (x, SCHEME [] t) = t

  tcletrec2 gamma ns nbvs e FAILURE = FAILURE
  tcletrec2 gamma ns nbvs e (OK phi)
      = tclet2 phi (tc gamma'' ns1 e)
        where ts         = map old_bvar nbvs'
              nbvs'      = sub_te phi nbvs
              gamma'     = sub_te phi gamma
              gamma''    = add_decls gamma' ns0 (map fst nbvs) ts
              (ns0, ns1) = split ns
#+end_src

** Haskell Example: Algorithm W

#+begin_quote
  "The Hindley-Milner type system ... is a family of type systems
  that admit the serendipitous property of having a tractable
  algorithm for determining types from untyped syntax. This is
  achieved by a process known as unification, whereby the types
  for a well-structured program give rise to a set of constraints
  that when solved always have a unique principal type.

  ...

  Milner’s observation was that since the typing rules map uniquely
  onto syntax, we can in effect run the typing rules 'backwards'
  and whenever we don’t have a known type for a subexpression,
  we 'guess' by putting a fresh variable in its place, collecting
  constraints about its usage induced by subsequent typing judgements.
  This is the essence of type inference in the ML family of languages,
  that by the generation and solving of a class of unification problems
  we can reconstruct the types uniquely from the syntax. The algorithm
  itself is largely just the structured use of a unification solver."

  — *Write You a Haskell*, Stephen Diehl
#+end_quote

#+begin_src haskell
  {-# Language PatternSynonyms #-}
  {-# Language LambdaCase #-}

  import qualified Data.Map as Map
  import qualified Data.Set as Set
  import Control.Monad.RWS
  import Control.Monad.Except

  type Name = String

  data Expr
    = EVar Name
    | EIf Expr Expr Expr
    | EAbs Name Expr
    | EApp Expr Expr
    | ELet Name Expr Expr
    | EInt Integer
    | EBool Bool
    | EBin Oper Expr Expr
    deriving Show

  data Oper = Add | Sub deriving Show

  newtype TVar = TV Name deriving (Eq, Show)

  data Type
    = TCon Name [Type]
    | TVar TVar
    deriving (Eq, Show)

  -- --- Pattern Synonyms ---
  pattern TInt    = TCon "Int" []
  pattern TBool   = TCon "Bool" []
  pattern a :-> b = TCon "->" [a, b]

  data Scheme = Forall [Set.Set TVar] Type
  data Constraint = Constraint Type Type

  type Context = Map.Map Name Scheme
  type Count = Int
  type Constraints = [Constraint]

  type Infer a = RWST Context Constraints Count (Except String) a

  constrain :: Type -> Type -> Infer ()
  constrain = tell . (:[]) . Constraint

  fresh :: Infer Type
  fresh = do
    count <- get
    put (count + 1)
    return . TVar . TV (show count)

  type Subst = Map.Map TVar Type

  compose :: Subst -> Subst -> Subst
  compose a b = Map.map (apply a) (Map.union b a)

  class Substitutable a where
    apply :: Subst -> a -> a
    tvs :: a -> Set.Set TVar

  instance Substitutable Type where
    tvs (TVar tv)   = Set.singleton tv
    tvs (TCon _ ts) = foldr (Set.union . tvs) Set.empty ts

    apply s t@(TVar tv) = Map.findWithDefault t tv s
    apply s (TCon c ts) = TCon c (map (apply s) ts)

  instance Substitutable Scheme where
    tvs (Forall vs t) = Set.difference (tvs t) vs
    apply s (Forall vs t) = Forall vs (apply (foldr Map.delete s vs) t)

  instance Substitutable Constraint where
    tvs (Constraint t1 t2) = Set.union (tvs t1) (tvs t2)
    apply s (Constraint t1 t2) = Constraint (apply s t1) (apply s t2)

  instance Substitutable a => Substitutable [a] where
    tvs l = foldr (Set.union . tvs) Set.empty l
    apply s = map (apply s)

  generalize :: Context -> Type -> Scheme
  generalize ctx t = Forall (Set.difference (tvs t) (tvs (Map.elems ctx))) t

  instantiate :: Scheme -> Infer Type
  instantiate (Forall vs t) = do
    let vars = Set.toList vs
    ftvs <- traverse (const fresh) vars
    let subst = Map.fromList (zip vars ftvs)
    return (apply subst t)

  infer :: Expr -> Infer Type
  infer = \case
    EInt _  -> TInt  -- Integer literal
    EBool _ -> TBool -- Boolean literal
    EVar v -> do
      ctx <- ask -- Retrieve context from Reader
      case Map.lookup v ctx of
        Just t -> instantiate t -- Instantiate type scheme for use
        Nothing -> throwError $ "Undefined variable " ++ v -- Variable not defined
    EIf c a b -> do
      ct <- infer c -- Infer type of condition expression
      at <- infer a -- Infer type of main branch
      bt <- infer b -- Infer type of else branch
      constrain ct TBool -- Condition expression should be a Bool
      constrain at bt -- Branches should be of same type
      return at -- Return type of any branch
    EAbs p e -> do
      pt <- fresh -- Generate fresh type variable for param
      let ps = Forall Set.empty pt
      et <- local (Map.insert p ps) (infer e) -- Infer function definition with param defined
      return $ pt :-> et -- Function has type pt -> et
    EApp f a -> do
      ft <- infer f -- Infer type of expression being called
      at <- infer a -- Infer type of argument
      rt <- fresh -- Fresh type variable for result type
      constrain ft (at :-> rt)
      return rt
    EBin o a b -> do
      let ot = -- Operators are functions
        case o of
          Add -> TInt :-> (TInt :-> TInt)
          Sub -> TInt :-> (TInt :-> TInt)
          -- NOTE: ADD MORE OPERATORS!!
      at <- infer a -- Infer left operand
      bt <- infer b -- Infer right operand
      t <- fresh -- Result type
      constrain ot (at :-> (bt :-> t))
      return t
    ELet v e b -> do
      et <- infer e -- Infer variable type
      ctx <- ask
      let es = generalize ctx et -- Generalize variable type
      bt <- local (Map.insert v es) (infer b) -- Infer body with variable defined
      return bt

  type Solve a = Except String a

  unify :: Type -> Type -> Solve Subst
  unify a b | a == b = return Map.empty -- Same
  unify (TVar v) t = bind v t -- Var Left
  unify t (TVar v) = bind v t -- Var Right
  unify a@(TCon n1 ts1) b@(TCon n2 ts2) -- Arrow (->) / other TCons
    | a /= b = throwError $ "Type mismatch " ++ show a ++ " and " ++ show b
    | otherwise = unifyMany ts1 ts2
    where
      unifyMany [] [] = return Map.empty
      unifyMany (t1 : ts1) (t2 : ts2) = do
        s1 <- unify t1 t2
        s2 <- unifyMany (apply s1 ts1) (apply s1 ts2)
        return (s2 `compose` s1)

  bind :: TVar -> Type -> Solve Subst
  bind v t
    | Set.member v (tvs t) = throwError $ "Infinite type " ++ show v ++ " ~ " ++ show t -- Occurs check
    | otherwise = return (Map.singleton v t)

  solve :: Subst -> [Constraint] -> Solve Subst
  solve s [] = return s
  solve s ((Constraint t1 t2) : cs) = do
    s1 <- unify t1 t2
    solve (s1 `compose` s) (apply s1 cs)

  runSolve :: [Constraint] -> Either TypeError Subst
  runSolve = runExcept . solve Map.empty
#+end_src
