* Polymorphic Type Checking

** Sources

| source                                                   | author                |
|----------------------------------------------------------+-----------------------|
| *The Implementation of Functional Programming Lanugages* | Simon L. Peyton Jones |

** Notation

#+begin_example
  === value :: TYPE ===

  a :: A

  === tuple ===

  - Coordinates need not be the same type.
  - Tuple type determines dimension and internal types.

  (A₁ ... Aₓ) <- type

  (a₁ ... aₓ) <- value

  === list ===

  - []
  - a:as, where a:A and as::[A]

  [A]         <- type

  [a₁ ... aₓ] <- value, if all successive entries
                 of a finite list are known.

  === structured type ===

  name v₁ ... vₓ ::= c₁ t₁₁ ... t₁ₓ
                   | ...
                   | cₓ tₓ₁ ... tₓₓ

  where name = type-forming operator
        vₓ   = type variable
        cₓ   = constructor
        tₓ   = type expression

  === function ===
  - Function "f" applicable to objects a::A, whose values, (f a),
    are of type B.

  A -> B

  - right associative, binary operation
  A -> B -> C = A -> (B -> C)
#+end_example

** Polymorphism

- monomorphic :: Every value has a single, concrete type:
  ~map :: (num -> num) -> [num] -> [num]~.

- polymorphic :: Every value may be one of many concrete types,
  depending on its context: ~map :: (A -> B) -> [A] -> [B]~.

- ad hoc polymorphism :: A type discipline that permits the same expression
  to denote distinct operations for distinct types. The addition operator
  might denote the addition of both integers, rationals, reals, and complex
  numbers.

- parametric polymorphism :: A type discipline where generic expressions
  are denoted by schematic variables. A polymorphic object may be one
  of many different types, depending on its context.

#+begin_example
  length :: [A] -> num, for all types A
  length []     = 0
  length (x:xs) = (length xs) +  1

  where A = schematic variable

  length :: [num] -> num
  length [7, 11]

  length :: [(char, char)] -> num
  length [('a', 'b'), ('c', 'd')]

  (.) :: (B -> C) -> (A -> B) -> A -> C
  (f . g) x = f (g x)

  where A, B, C = schematic variables

  foldr :: (A -> B -> B) -> B -> [A] -> B
  foldr f b []     = b
  foldr f b (a:as) = f a (foldr f b as)

  where A, B = schematic variables

  foldr :: (num -> num -> num) -> num -> [num] -> num
  foldr + 0 [7, 11, 15]

  foldr :: (string -> string -> string) -> string -> [string] -> string
  foldr append [] ["abc", "def", "ghi"]
#+end_example

** Type Inference

#+begin_quote
  "...[W]e have two type expressions that will usually contain variables,
   the first giving the form of the type required by the context
   (deduced from the 'outside'), and the second giving the form of the type
   which the object can take (deduced from the 'inside'). For the whole
   expression to be well typed, these two type expressions must match,
   in the sense that by substituting for the schematic variables
   of the type expressions, they can be brought to the same form."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
#+end_quote

In order to be sure that expression *(E_{1} E_{2})* is well-typed, the function *E_{1}*
must have type *(A -> B)*, where *E_{2}* is of type *A* and *(E_{1} E_{2})* is of type
*B*.

- The function *f* of an application *(f a)* has type *(A -> V)*,
  where *a* has type *A* and *(f a)* has type *V*.

- All occurrences of a λ-bound variable must have the same types.

- If two compound type expressions are equal, then they must be formed with
  the same construction and their corresponding parts must be equal.
  More specifically: if *(T1 -> T2) = (T1' -> T2')*, then *T1 = T1'* and *T2 = T2'*.

#+begin_example
  (λf.λx.λy f x y)

   f   x
    \ /
     @   y
      \ /
       @
       |
    λf.λx.λy

  f::T0 x::T1
  ----------- @
       T2         y::T3
       ---------------- @
              T4
              -- λf.λx.λy
              T5

  T0 = T1 -> T2
  T2 = T3 -> T4
  T5 = T0 -> T1 -> T2

  f::T1 -> T3 -> T4 x::T1
  ----------------------- @
       T3 -> T4              y::T3
       --------------------------- @
                    T4
       ---------------------------------- λf.λx.λy
       (T1 -> T3 -> T4) -> T1 -> T3 -> T4
       (A  -> B  -> C)  -> A  -> B  -> C

  (λx.λy.λz. x z (y z))

  x   z y   z
   \ /   \ /
    @     @
    |     |
    +--@--+
       |
    λx.λy.λz

  x::T0 z::T1    y::T2 z::T3
  ----------- @  ----------- @
       T4             T5
       ----------------- @
              T6
              -- λx.λy.λz
              T7

  - The types of the sub-expressions must be related
  - by the following equations:

  T0 = T1 -> T4
  T2 = T3 -> T5
  T4 = T5 -> T6

  x::T1 -> T5 -> T6 z::T1    y:T3 -> T5 z::T3
  ----------------------- @  ---------------- @
           T5 -> T6               T5
           ------------------------- @
                        T6
                        -- λx.λy.λz
                        T7

  - If we assume both instances of lambda-bound "z" are of the same type,
  - we add the two equations:

  T1 = T3
  T7 = (T0 -> T2 -> T1 -> T6)

  x::T1 -> T5 -> T6 z:: T1     y::T1 -> T5 z::T1
  ------------------------ @   ----------------- @
           T5 -> T6                   T5
           ----------------------------- @
                          T6
     ------------------------------------------ λx.λy.λz
     (T1 -> T5 -> T6) -> (T1 -> T5) -> T1 -> T6
     (A -> B -> C)    -> (A -> B)   -> A  -> C

  λf.λa.λb.λc. c (f a) (f b)

        f     a
        |     |
   c    +- @ -+   f     b
   |       |      |     |
   +-- @ --+      +- @ -+
       |             |
       +----- @ -----+
              |
         λf.λa.λb.λc

          f::T0 a::T1
          ----------- @
  c::T2        T3        f::T4 b::T5
  --------------- @      ----------- @
         T6                   T7
         ----------------------- @
                    T8
                    -- λf.λa.λb.λc
                    T9
  T0 = T1 -> T3
  T2 = T3 -> T6
  T4 = T5 -> T7
  T6 = T7 -> T8

  - Require all occurrences of a variable bound
  - by a lambda abstraction to have the same type.
  T0 = T4
  T1 = T5
  T3 = T7

              f::T1 -> T3 a::T1
              ----------------- @
  c::T3 -> T3 -> T8   T3           f::T1 -> T3 b::T1
  ---------------------- @         ----------------- @
         T3 -> T8                          T3
         ------------------------------------ @
                          T8
  ------------------------------------------------ λf.λa.λb.λc
  (T1 -> T3) -> T1 -> T1 -> (T3 -> T3 -> T8) -> T8
  (A  -> B)  -> A  -> A  -> (B  -> B  -> C)  -> C
#+end_example

** Intermediate Language

A transformed program should be type checked after dependency analysis
but before lambda lifting or transformation into a supercombinator.

#+begin_example
  expression ::= variable
               | λvariable.expression
               | expression expression
               | let variable-1 = expression-1
                     ...
                     variable-x = expression-x
                 in expression
               | letrec variable-1 = expression-1
                        ...
                        variable-x = expression-x
                 in <expression>
#+end_example

** The Type Checker

#+begin_quote
  "The unification algorithm has many applications other than type-checking.
   in particular it is a key algorithm in the implementation of programming
   languages such as Prolog."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
   
  "There is a partial analogy between type schemes and lambda abstractions.
   The schematic variables of a type scheme correspond to the formal parameter
   of a lambda abstraction, and the unknowns of a type scheme correspond to
   the free variables of a lambda abstraction. Applying a lambda abstraction
   to an argument involves constructing an instance of its body, substituting
   the argument for occurrences of the formal parameter
   (but copying free variables unchanged). This is very similar to the process
   of instantiating a type scheme, which involves constructing an instance
   of the type scheme template, substituting fresh type variables for
   occurrences of the schematic variables (but copying unknowns unchanged)."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
#+end_quote

#+begin_src
  || === Program Expressions ===

  vname == [char]

  vexp ::= VAR vname
         | LAMBDA vname vexp
         | AP vexp vexp
         | LET [vname] [vexp] vexp
         | LETREC [vname] [vexp] vexp

  || === Type Expressions ===

  tvname == [char]

  type_exp ::= TVAR tvname             || type variable
             | TCONS [char] [type_exp] || compound type

  || t1 -> t2

  arrow :: type_exp -> type_exp
  arrow t1 t2 = TCONS "arrow" [t1, t2]

  int :: type_exp
  int = TCONS "int" []

  || (t1, t2)

  cross :: type_exp -> type_exp -> type_exp
  cross t1 t2 = TCONS "cross" [t1, t2]

  || [t]

  list :: type_exp type_exp
  list t = TCONS "list" [t]

  || Returns a list of the variable names that occur in a type expression.

  tvars_in :: type_exp -> [tvname]
  tvars t = f t []
            where
                f (TVAR x) xs     = x:xs
                f (TCONS y ts) xs = foldr f xs ts

  || === Success and Failure ===

  reply * ::= OK * | FAILURE

  || === Solving Equations ===
  ||
  || "An alleged solution of a system of type equations can be expressed
  ||  as a function from type variables (the unknowns) to type expressions
  ||  (their values)...[E]quations are satisfied when we replace (i.e. substitute)
  ||  the unknowns by their values under the function."
  ||
  || — Chapter 9: A Type-checker, Peter Hancock

  || substitutions

  subst == tvname -> type_exp

  || The phi substitution on all the type variables in te,
  || where phi, phi', psi = variables over substitutions

  sub_type :: subst -> type_exp -> type_exp
  sub_type phi (TVAR tvn)     = phi tvn
  sub_type phi (TCONS tcn ts) = TCONS tcn (map (sub_type phi) ts)

  map :: (* -> **) -> [*] -> [**]
  map f []     = []
  map f (x:xs) = fx : map f xs

  || composition: sub_type (scomp phi psi) = (sub_type phi) . (sub_type psi)

  scomp :: subst -> subst -> subst
  scomp sub2 sub1 tvn = sub_type sub2 (sub1 tvn)

  || identity: sub_type id_subst t = t

  id_subst :: subst
  id_subst tvn = TVAR tvn

  || delta substitution

  delta :: tvname -> type_exp -> subst
  delta tvn t tvn' = t,           if tvn = tvn'
                   = TVAR tvn',   otherwise

  || idempotent: (sub_type phi) . (sub_type phi) = sub_type phi
  ||
  || fixed point substitution: sub_type phi t = t

  || === Unification ===

  || type expression: (t1, t2) or t1 = t2
  ||
  || phi unifies (t1, t2) if sub_type phi t1 = sub_type phi t2
  ||
  || psi extends phi if psi = scomp rho phi

  || Expression (extend phi tvn t) will only be evaluated when
  ||
  || 1. phi is an idempotent substitution (the solution we are trying to extend)
  || 2. t is a fixed point of phi
  || 3. tvn is unmoved by phi (tvn does not already have a value under phi)

  extend :: subst -> tvname -> type_exp -> reply subst
  extend phi tvn t = OK phi,                        if t = TVAR tvn
                   = FAILURE,                       if (in tvn (tvars_in t))
                   = OK (scomp (delta tvn t) phi),  otherwise

  --- unification algorithm ---

  unify :: subst -> (type_exp, type_exp) -> reply subst

  unify phi ((TVAR tvn), t)
      = extend phi tvn phit,       if phitvn = TVAR tvn
      = unify phi (phitvn, phit),  otherwise
        where phitvn = phi tvn
              phit   = sub_type phi t

  unify phi ((TCONS tcn ts), (TVAR tvn))
      = unify phi ((TVAR tv), (TCONS tcn ts))

  unify phi ((TCONS tcn ts), (TCONS tcn' ts'))
      = unifyl phi (zip ts ts'),    if tcn = tcn'
      = FAILURE,                    otherwise

  zip :: [*] -> [**] -> [(*, **)]
  zip [] xs     = []
  zip (x:xs) [] = []
  zip (x:xs) (y:ys) = (x, y) : zip xs ys

  || (unifyl phi pts) constructs a substitution extending phi,
  || which unifies corresponding entries in the list of pairs pts.

  unifyl :: subst -> [(type_exp, type_exp)] -> reply subst
  unifyl phi eqns = foldr f (OK phi) eqns
                    where
                        f eqn (OK phi) = unify phi eqn
                        f eqn FAILURE  = FAILURE

  || === Type Scheme ===

  type_scheme ::= SCHEME [tvname] type_exp

  unknowns_scheme :: type_scheme -> [tvname]
  unknowns_scheme (SCHEME scvs t) = tvars_in (bar t scvs)

  bar :: [*] -> [*] -> [*]
  bar xs ys = [ x <- xs | ~(x $in ys)]

  in :: * -> [*] -> bool
  in x' [] = False
  in x' (x:xs) = True,      if x = x'
               = x' $in xs, otherwise

  sub_scheme :: subst -> type_scheme -> type_scheme
  sub_scheme phi (SCHEME scvs t)
      = SCHEME scvs (sub_type (exclude phi scvs) t)

  exclude phi scvs tvn = TVAR tvn,    if tvn $in scvs
                       = phi tvn,     otherwise

  || type environment = [(free variable, type scheme)]

  assoc_list * ** == [(*, **)]

  dom :: assoc_list * ** -> [*]
  dom al = [ k | (k, v) <- al ]

  val :: assoc_list * ** -> * -> **
  val al k = hd [ v | (k', v) <- al; k = k' ]

  install al k v = (k, v):al

  rng :: assoc_list * ** -> [**]
  rng al = map (val al) (dom al)

  type_env == assoc_list vname type_scheme

  unknowns_te :: type_env -> [tvname]
  unknowns_te gamma = appendlist (map unknowns_scheme (rng gamma))

  appendlist :: [ [*] ] -> [*]
  appendlist lls = foldr (++) [] lls

  sub_te :: subst -> type_env -> type_env
  sub_te phi gamma
      = [ (x, sub_scheme phi st) | (x, st) <- gamma ]

  || === new variables ===

  next_name :: name_supply -> tvname
  deplete   :: name_supply -> name_supply
  split     :: name_supply -> (name_supply, name_supply)

  tvname      == [num]
  name_supply == tvname

  next_name ns   = ns
  deplete (n:ns) = (n+2:ns)
  split ns       = (0:ns, 1:ns)

  name_sequence :: name_supply -> [tvname]
  name_sequence ns = next_name ns : name_sequence (deplete ns)

  || === Type Checker ===
  ||
  || (tc gamma ns e) -> reply (phi, t)
  ||
  || where gamma = type environment
  ||       ns    = supply of type variable names
  ||       e     = expression to be checked
  ||       phi   = substitution defined on unknown type variables in gamma
  ||       t     = a type derived for the expression e
  ||               in the type environment (sub_te phi gamma).
  ||               Fixed point of the substitution of phi.

  tc :: type_env -> name_supply -> vexp -> reply (subst, type_exp)
  tc gamma ns (VAR x)          = tcvar gamma ns x
  tc gamma ns (AP e1 e2)       = tcap gamma ns e1 e2
  tc gamma ns (LAMBDA x e)     = tclambda gamma ns x e
  tc gamma ns (LET xs es e)    = tclet gamma ns xs es e
  tc gamma ns (LETREC xs es e) = tcletrec gamma ns xs es e
#+end_src
