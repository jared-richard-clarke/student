* Polymorphic Type Checking

** Sources

| source                                                   | author                |
|----------------------------------------------------------+-----------------------|
| *The Implementation of Functional Programming Lanugages* | Simon L. Peyton Jones |
| *Hindley-Milner Type System*                             | Wikipedia             |
| *Implementing a Hindley-Milner Type System*              | 05st                  |

** Notation

#+begin_example
  === value :: TYPE ===

  a :: A

  === tuple ===

  - Coordinates need not be the same type.
  - Tuple type determines dimension and internal types.

  (A₁ ... Aₓ) <- type

  (a₁ ... aₓ) <- value

  === list ===

  - []
  - a:as, where a:A and as::[A]

  [A]         <- type

  [a₁ ... aₓ] <- value, if all successive entries
                 of a finite list are known.

  === structured type ===

  name v₁ ... vₓ ::= c₁ t₁₁ ... t₁ₓ
                   | ...
                   | cₓ tₓ₁ ... tₓₓ

  where name = type-forming operator
        vₓ   = type variable
        cₓ   = constructor
        tₓ   = type expression

  === function ===
  - Function "f" applicable to objects a::A, whose values, (f a),
    are of type B.

  A -> B

  - right associative, binary operation
  A -> B -> C = A -> (B -> C)
#+end_example

** Polymorphism

- monomorphic :: Operations accept values of one type.

- polymorphic :: Operations accept values of more than one type.

- ad hoc polymorphism :: A type discipline that permits the same expression
  to denote distinct operations for distinct types. The addition operator
  might denote the addition of both integers, rationals, reals, and complex
  numbers.

- parametric polymorphism :: A type discipline where operations work uniformly
  for arguments of different types. Polymorphic expressions are denoted by
  schematic variables. Polymorphic types become monomorphic by consistent
  substitution of their schematic variables.

#+begin_src
  || === parametric polymorphic ===
  ||
  || A = schematic variable

  length :: [A] -> num
  length []     = 0
  length (x:xs) = (length xs) +  1

  || === monomorphic ===

  length :: [num] -> num
  length [7, 11]

  length :: [(char, char)] -> num
  length [('a', 'b'), ('c', 'd')]

  || === parametric polymorphic ===
  ||
  || A, B, C = schematic variables

  (.) :: (B -> C) -> (A -> B) -> A -> C
  (f . g) x = f (g x)

  || === parametric polymorphic ===
  ||
  || A, B = schematic variables

  foldr :: (A -> B -> B) -> B -> [A] -> B
  foldr f b []     = b
  foldr f b (a:as) = f a (foldr f b as)

  || === monomorphic ===

  foldr :: (num -> num -> num) -> num -> [num] -> num
  foldr + 0 [7, 11, 15]

  foldr :: (string -> string -> string) -> string -> [string] -> string
  foldr append [] ["abc", "def", "ghi"]
#+end_src

** Type Inference

#+begin_quote
  "...[W]e have two type expressions that will usually contain variables,
   the first giving the form of the type required by the context
   (deduced from the 'outside'), and the second giving the form of the type
   which the object can take (deduced from the 'inside'). For the whole
   expression to be well typed, these two type expressions must match,
   in the sense that by substituting for the schematic variables
   of the type expressions, they can be brought to the same form."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
#+end_quote

In order to be sure that expression *(E_{1} E_{2})* is well-typed, the function *E_{1}*
must have type *(A -> B)*, where *E_{2}* is of type *A* and *(E_{1} E_{2})* is of type
*B*.

- The function *f* of an application *(f a)* has type *(A -> V)*,
  where *a* has type *A* and *(f a)* has type *V*.

- All occurrences of a λ-bound variable must have the same types.

- If two compound type expressions are equal, then they must be formed with
  the same construction and their corresponding parts must be equal.
  More specifically: if *(T1 -> T2) = (T1' -> T2')*, then *T1 = T1'* and *T2 = T2'*.

- If *T1 = ...T1...*, where type variable *T1* occurs properly within
  the right-hand side of the equation, then the system of equations
  cannot be solved, and the expression from which the system was derived
  is ill-typed.

#+begin_example
  (λf.λx.λy f x y)

   f   x
    \ /
     @   y
      \ /
       @
       |
    λf.λx.λy

  f::T0 x::T1
  ----------- @
       T2         y::T3
       ---------------- @
              T4
              -- λf.λx.λy
              T5

  T0 = T1 -> T2
  T2 = T3 -> T4
  T5 = T0 -> T1 -> T2

  f::T1 -> T3 -> T4 x::T1
  ----------------------- @
       T3 -> T4              y::T3
       --------------------------- @
                    T4
       ---------------------------------- λf.λx.λy
       (T1 -> T3 -> T4) -> T1 -> T3 -> T4
       (A  -> B  -> C)  -> A  -> B  -> C

  (λx.λy.λz. x z (y z))

  x   z y   z
   \ /   \ /
    @     @
    |     |
    +--@--+
       |
    λx.λy.λz

  x::T0 z::T1    y::T2 z::T3
  ----------- @  ----------- @
       T4             T5
       ----------------- @
              T6
              -- λx.λy.λz
              T7

  - The types of the sub-expressions must be related
  - by the following equations:

  T0 = T1 -> T4
  T2 = T3 -> T5
  T4 = T5 -> T6

  x::T1 -> T5 -> T6 z::T1    y:T3 -> T5 z::T3
  ----------------------- @  ---------------- @
           T5 -> T6               T5
           ------------------------- @
                        T6
                        -- λx.λy.λz
                        T7

  - If we assume both instances of lambda-bound "z" are of the same type,
  - we add the two equations:

  T1 = T3
  T7 = (T0 -> T2 -> T1 -> T6)

  x::T1 -> T5 -> T6 z:: T1     y::T1 -> T5 z::T1
  ------------------------ @   ----------------- @
           T5 -> T6                   T5
           ----------------------------- @
                          T6
     ------------------------------------------ λx.λy.λz
     (T1 -> T5 -> T6) -> (T1 -> T5) -> T1 -> T6
     (A -> B -> C)    -> (A -> B)   -> A  -> C

  λf.λa.λb.λc. c (f a) (f b)

        f     a
        |     |
   c    +- @ -+   f     b
   |       |      |     |
   +-- @ --+      +- @ -+
       |             |
       +----- @ -----+
              |
         λf.λa.λb.λc

          f::T0 a::T1
          ----------- @
  c::T2        T3        f::T4 b::T5
  --------------- @      ----------- @
         T6                   T7
         ----------------------- @
                    T8
                    -- λf.λa.λb.λc
                    T9
  T0 = T1 -> T3
  T2 = T3 -> T6
  T4 = T5 -> T7
  T6 = T7 -> T8

  - Require all occurrences of a variable bound
  - by a lambda abstraction to have the same type.
  T0 = T4
  T1 = T5
  T3 = T7

              f::T1 -> T3 a::T1
              ----------------- @
  c::T3 -> T3 -> T8   T3           f::T1 -> T3 b::T1
  ---------------------- @         ----------------- @
         T3 -> T8                          T3
         ------------------------------------ @
                          T8
  ------------------------------------------------ λf.λa.λb.λc
  (T1 -> T3) -> T1 -> T1 -> (T3 -> T3 -> T8) -> T8
  (A  -> B)  -> A  -> A  -> (B  -> B  -> C)  -> C
#+end_example

** Intermediate Language

A transformed program should be type checked after dependency analysis
but before lambda lifting or transformation into a supercombinator.

#+begin_example
  expression ::= variable
               | λvariable.expression
               | expression expression
               | let variable-1 = expression-1
                     ...
                     variable-x = expression-x
                 in expression
               | letrec variable-1 = expression-1
                        ...
                        variable-x = expression-x
                 in <expression>
#+end_example

** Hindley-Milner Type System

#+begin_example
  || === Expressions ===

  e = x
    | e₁ e₂
    | λx.e
    | let x = e₁ in e₂

  || === Types ===

  || Monotypes designate a particular type. Not to be confused
  || with monomorphic types, which exclude variables and allow
  || only ground terms.

  monotype τ = α
             | C τ ... τ

  || Polytypes — or type schemes — are types containing
  || variables bound by zero or more for-all quantifiers.
  || Qualifiers can only appear top level. ∀α.α -> ∀α.α
  || is not allowed.

  polytype σ = τ
             | ∀α.σ

  || === Context and Typing ===
  ||
  || Brings together syntax expressions and types.

  || A context is a list of pairs (x : σ)

  Context Γ = ε (empty)
            | Γ, x : σ

  || Under the assumptions Γ, the expression e has type σ.

  Typing    = Γ ⊢ e : σ

  || === Free Type Variables ===
  ||
  || For type ∀α₁ ... ∀αₓ.τ, ∀ is the quantifier binding the type variables
  || αₓ in the monotype τ.

  free(α)           = {α}

                       x
  free(C τ₁ ... τₓ) =  ∪ free(τᵢ)
                     i = 1

  free(Γ)           =  ∪ free(σ)
                     x : σ ∈ Γ

  free(∀α.σ)        = free(σ) - {α}

  free(Γ ⊢ e : σ)   = free(σ) - free(Γ)

  || === Syntax of Rules ===

  Predicate  = σ₁ ⊑ σ₂
             | α ∉ free(Γ)
             | x : σ ∈ Γ

  Judgement  = Typing

  Premise    = Judgement | Predicate

  Conclusion = Judgement

               Premise ...
  Rule       = ----------- [Name]
               Conclusion

  || === Declarative Rule System ===

  || --- Variable ---

  x : σ ∈ Γ
  ---------                        [Var]
  Γ ⊢ x : σ

  || --- Application ---

  Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
  -------------------------------- [App]
           Γ ⊢ e₁ e₂ : τ₂

  || --- Abstraction ---

  Γ, x : τ₁ ⊢ e : τ₂
  -------------------              [Abs]
  Γ ⊢ λx.e : τ₁ → τ₂

  || --- Let ---

  Γ ⊢ e₁ : σ   Γ, x : σ ⊢ e₂ : τ
  -------------------------------  [Let]
     Γ ⊢ let x = e₁ in e₂ : τ

  || --- Instantiation ---
  || Replace all instances of a quantified type variable
  || with a fresh monotype variable.
  ||
  || σ₁ ⊑ σ₂ reads "σ₂ is an instantiation of σ₁",
  || where "instantiation" here informally means
  || "resemble".

  Γ ⊢ e : σ₁    σ₁ ⊑ σ₂
  ---------------------            [Inst]
       Γ ⊢ e : σ₂

  || --- Generalization ---
  || Converts monotype τ into polytype σ by closing
  || over all free type variables in τ.

  Γ ⊢ e : σ    α ∉ free(Γ)
  ------------------------         [Gen]
      Γ ⊢ e : ∀α.σ

  || === Syntactical Rule System ===

  || --- Variable and Instantiation ---

   x : σ ∈ Γ    σ ⊑ τ
   ------------------                    [Var]
       Γ ⊢ x : τ

  || --- Application ---

  Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
  --------------------------------       [App]
           Γ ⊢ e₁ e₂ : τ₂

  || --- Abstraction ---

  Γ, x : τ₁ ⊢ e : τ₂
  -------------------                    [Abs]
  Γ ⊢ λx.e : τ₁ → τ₂

  || --- Let and Generalization ---

  Γ ⊢ e₁ : τ₁   Γ, x : Γ'(τ₁) ⊢ e₂ : τ₂
  -------------------------------------  [Let]
        Γ ⊢ let x = e₁ in e₂ : τ₂

  || Quantify all monotype variables not bound in Γ.

  Γ'(τ) = ∀α'.τ

  α' = free(τ) - free(Γ)
#+end_example

*** Unification

- substitution :: A mapping from a free variable in a type to its corresponding
  term in an environment.

- constraint :: A requirement that two types have a common substitution
  instance.

- unification :: A partial function that either turns a set of constraints
  into a substitution or fails when it encounters unsatisfiable constraints.
  A unification algorithm may be described in three parts:

  1. Any type variable unifies with any type expression, and is instantiated
     to that expression. A specific theory might restrict this rule with an
     occurs check.

  2. Two type constants unify only if they are the same type.

  3. Two type constructions unify only if they are applications of the same
     type constructor and all of their component types recursively unify.

#+begin_example
  || === unification ===
  
  || Terms "a" and "b" are unifiable by substitution "s".

  a ~ b (s) = [s]a = [s]b

  || --- same ---

  α ~ α ([])

  || --- left-hand side ---

  α ∉ free(τ)
  ---------------
  α ~ τ ([α ↦ τ])

  || --- right-hand side ---

  α ∉ free(τ)
  ---------------
  τ ~ α ([α ↦ τ])

  || --- arrow (→) ---

  τ₁ ~ τ'₂ (s₁)    [s₁]τ₂ ~ [s₁]τ'₂ (s₂)
  --------------------------------------
  τ₁ → τ₂ ~ τ'₁ → τ'₂ (s₂ ∘ s₁)
#+end_example

** The Type Checker

1. *Assign type variables*: Assign fresh type variables to expressions whose
   type is unknown.

2. *Collect constraints*: Traverse the abstract syntax tree of a program,
   gathering type constraints based on how expressions are used.
   If *f* has type *T1 -> T2*, then *x* in *(f x)* must have type *T1*.

3. *Unify*: Find substitutions for type variables that satisfy all constraints.
   Determine either the concrete types or most general polymorphic types.
   Consistent substitution means an expression is well-typed.

4. *Generalize*: For a ~let~ expression, the inferred monotype for the bound
   value is generalized to a polytype by quantifying over all free type variables,
   allowing the bound variable to be different types in the body of the expression.

#+begin_quote
  "Essentially, type inference is the process of descending the abstract syntax
   tree, assigning fresh type variables to every expression, and generating a set
   of constraints based on what information is available. Afterwards, solving the
   set of constraints (much like solving a system of equations), will result in
   a substitution. This substitution will map every generated type variable to
   an inferred principal type. The process of solving the constraints is known
   as unification. (The principal type is, more or less, the most general type
   of an expression, i.e. any other possible types for the expression are
   instances of the principal type.)"

  — *Implementing a Hindley-Milner Type System*, O5st

  "There is a partial analogy between type schemes and lambda abstractions.
   The schematic variables of a type scheme correspond to the formal parameter
   of a lambda abstraction, and the unknowns of a type scheme correspond to
   the free variables of a lambda abstraction. Applying a lambda abstraction
   to an argument involves constructing an instance of its body, substituting
   the argument for occurrences of the formal parameter
   (but copying free variables unchanged). This is very similar to the process
   of instantiating a type scheme, which involves constructing an instance
   of the type scheme template, substituting fresh type variables for
   occurrences of the schematic variables (but copying unknowns unchanged)."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
#+end_quote

#+begin_src
  || === Program Expressions ===

  vname == [char]

  vexp ::= VAR vname
         | LAMBDA vname vexp
         | AP vexp vexp
         | LET [vname] [vexp] vexp
         | LETREC [vname] [vexp] vexp

  || === Type Expressions ===

  tvname == [char]

  type_exp ::= TVAR tvname             || type variable
             | TCONS [char] [type_exp] || concrete type

  || t1 -> t2

  arrow :: type_exp -> type_exp
  arrow t1 t2 = TCONS "arrow" [t1, t2]

  int :: type_exp
  int = TCONS "int" []

  || (t1, t2)

  cross :: type_exp -> type_exp -> type_exp
  cross t1 t2 = TCONS "cross" [t1, t2]

  || [t]

  list :: type_exp type_exp
  list t = TCONS "list" [t]

  || Returns a list of the variable names that occur in a type expression.

  tvars_in :: type_exp -> [tvname]
  tvars t = f t []
            where
                f (TVAR x) xs     = x:xs
                f (TCONS y ts) xs = foldr f xs ts

  || === Success and Failure ===

  reply * ::= OK * | FAILURE

  || === Solving Equations ===
  ||
  || "An alleged solution of a system of type equations can be expressed
  ||  as a function from type variables (the unknowns) to type expressions
  ||  (their values)...[E]quations are satisfied when we replace (i.e. substitute)
  ||  the unknowns by their values under the function."
  ||
  || — Chapter 9: A Type-checker, Peter Hancock

  || substitutions

  subst == tvname -> type_exp

  || The phi substitution on all the type variables in te,
  || where phi, phi', psi = variables over substitutions

  sub_type :: subst -> type_exp -> type_exp
  sub_type phi (TVAR tvn)     = phi tvn
  sub_type phi (TCONS tcn ts) = TCONS tcn (map (sub_type phi) ts)

  map :: (* -> **) -> [*] -> [**]
  map f []     = []
  map f (x:xs) = f x : map f xs

  || composition: sub_type (scomp phi psi) = (sub_type phi) . (sub_type psi)

  scomp :: subst -> subst -> subst
  scomp sub2 sub1 tvn = sub_type sub2 (sub1 tvn)

  || identity: sub_type id_subst t = t

  id_subst :: subst
  id_subst tvn = TVAR tvn

  || delta substitution

  delta :: tvname -> type_exp -> subst
  delta tvn t tvn' = t,           if tvn = tvn'
                   = TVAR tvn',   otherwise

  || idempotent: (sub_type phi) . (sub_type phi) = sub_type phi
  ||
  || fixed point substitution: sub_type phi t = t

  || === Unification ===

  || type expression: (t1, t2) or t1 = t2
  ||
  || phi unifies (t1, t2) if sub_type phi t1 = sub_type phi t2
  ||
  || psi extends phi if psi = scomp rho phi

  || Expression (extend phi tvn t) will only be evaluated when
  ||
  || 1. phi is an idempotent substitution (the solution we are trying to extend)
  || 2. t is a fixed point of phi
  || 3. tvn is unmoved by phi (tvn does not already have a value under phi)

  extend :: subst -> tvname -> type_exp -> reply subst
  extend phi tvn t = OK phi,                        if t = TVAR tvn
                   = FAILURE,                       if tvn $in (tvars_in t)
                   = OK (scomp (delta tvn t) phi),  otherwise

  || --- unification algorithm ---

  unify :: subst -> (type_exp, type_exp) -> reply subst

  unify phi ((TVAR tvn), t)
      = extend phi tvn phit,       if phitvn = TVAR tvn
      = unify phi (phitvn, phit),  otherwise
        where phitvn = phi tvn
              phit   = sub_type phi t

  unify phi ((TCONS tcn ts), (TVAR tvn))
      = unify phi ((TVAR tv), (TCONS tcn ts))

  unify phi ((TCONS tcn ts), (TCONS tcn' ts'))
      = unifyl phi (zip ts ts'),    if tcn = tcn'
      = FAILURE,                    otherwise

  zip :: [*] -> [**] -> [(*, **)]
  zip [] xs     = []
  zip (x:xs) [] = []
  zip (x:xs) (y:ys) = (x, y) : zip xs ys

  || (unifyl phi pts) constructs a substitution extending phi,
  || which unifies corresponding entries in the list of pairs pts.

  unifyl :: subst -> [(type_exp, type_exp)] -> reply subst
  unifyl phi eqns = foldr f (OK phi) eqns
                    where
                        f eqn (OK phi) = unify phi eqn
                        f eqn FAILURE  = FAILURE

  || === Type Scheme ===

  type_scheme ::= SCHEME [tvname] type_exp

  unknowns_scheme :: type_scheme -> [tvname]
  unknowns_scheme (SCHEME scvs t) = tvars_in (bar t scvs)

  bar :: [*] -> [*] -> [*]
  bar xs ys = [ x <- xs | ~(x $in ys)]

  in :: * -> [*] -> bool
  in x' []     = False
  in x' (x:xs) = True,      if x = x'
               = x' $in xs, otherwise

  sub_scheme :: subst -> type_scheme -> type_scheme
  sub_scheme phi (SCHEME scvs t)
      = SCHEME scvs (sub_type (exclude phi scvs) t)

  exclude phi scvs tvn = TVAR tvn,    if tvn $in scvs
                       = phi tvn,     otherwise

  || type environment = [(free variable, type scheme)]

  assoc_list * ** == [(*, **)]

  dom :: assoc_list * ** -> [*]
  dom al = [ k | (k, v) <- al ]

  val :: assoc_list * ** -> * -> **
  val al k = hd [ v | (k', v) <- al; k = k' ]

  install al k v = (k, v):al

  rng :: assoc_list * ** -> [**]
  rng al = map (val al) (dom al)

  type_env == assoc_list vname type_scheme

  unknowns_te :: type_env -> [tvname]
  unknowns_te gamma = appendlist (map unknowns_scheme (rng gamma))

  appendlist :: [ [*] ] -> [*]
  appendlist lls = foldr (++) [] lls

  sub_te :: subst -> type_env -> type_env
  sub_te phi gamma
      = [ (x, sub_scheme phi st) | (x, st) <- gamma ]

  || === new variables ===

  next_name :: name_supply -> tvname
  deplete   :: name_supply -> name_supply
  split     :: name_supply -> (name_supply, name_supply)

  tvname      == [num]
  name_supply == tvname

  next_name ns   = ns
  deplete (n:ns) = (n+2:ns)
  split ns       = (0:ns, 1:ns)

  name_sequence :: name_supply -> [tvname]
  name_sequence ns = next_name ns : name_sequence (deplete ns)

  || === Type Checker ===
  ||
  || (tc gamma ns e) -> reply (phi, t)
  ||
  || where gamma = type environment
  ||       ns    = supply of type variable names
  ||       e     = expression to be checked
  ||       phi   = substitution defined on unknown type variables in gamma
  ||       t     = a type derived for the expression e
  ||               in the type environment (sub_te phi gamma).
  ||               Fixed point of the substitution of phi.

  tc :: type_env -> name_supply -> vexp -> reply (subst, type_exp)
  tc gamma ns (VAR x)          = tcvar gamma ns x
  tc gamma ns (AP e1 e2)       = tcap gamma ns e1 e2
  tc gamma ns (LAMBDA x e)     = tclambda gamma ns x e
  tc gamma ns (LET xs es e)    = tclet gamma ns xs es e
  tc gamma ns (LETREC xs es e) = tcletrec gamma ns xs es e

  || --- type checking lists of expressions ---

  tcl :: type_env -> name_supply -> [vexp] -> reply (subst, [type_exp])
  tcl gamma ns []     = OK (id_subst, [])
  tcl gamma ns (e:es) = tcl1 gamma ns0 es (tc gamm ns1 e)
                        where (ns0, ns1) =  split ns

  tcl1 gamma ns es FAILURE       = FAILURE
  tcl1 gamma ns es (OK (phi, t)) = tcl2 phi t (tcl gamma' ns es)
                                   where gamma' = sub_te phi gamma

  tcl2 phi t FAILURE        = FAILURE
  tcl2 phi t (OK (psi, ts)) = OK (scomp psi phi, (subt_type psi t) : ts)

  || --- variables ---

  tcvar :: type_env -> name_supply -> vname -> reply (subst, type_exp)
  tcvar gamma ns x = OK (id_subst, newinstance ns scheme)
                     where scheme = val gamma x

  newinstance :: name_supply -> type_scheme -> type_exp
  newinstance ns (SCHEME scvs t) =
      sub_type phi t
      where al  = zip scvs (name_sequence ns)
            phi = al_to_subst al

  al_to_subst :: assoc_list tvname tvname -> subst
  al_to_subst al tvn = TVAR (val al tvn),    if tvn $in (dom al)
                     = TVAR tvn,             otherwise

  || --- application ---

  tcap :: type_env -> name_supply -> vexp -> vexp -> reply (subst, type_exp)
  tcap gamma ns e1 e2
      = tcap1 tvn (tcl gamma ns' [e1. e2])
        where tvn = next_name ns
              ns' = deplete ns

  tcap1 tvn FAILURE = FAILURE
  tcap1 tvn (OK (phi, [t1, t2]))
      = tcap2 tvn (unify phi (t1, arrow t2 (TVAR tvn)))

  tcap2 tvn FAILURE = FAILURE
  tcap2 tvn (OK phi) = OK (phi, phi tvn)

  || --- Lambda Abstractions ---

  tclambda :: type_env -> name_supply -> vname -> vexp -> reply (subst, type_exp)
  tclambda gamma ns x e
      = tclambda1 tvn (tc gamma' ns' e)
        where ns'   = deplete ns
              gamma = new_bvar (x, tvn) : gamma
              tvn   = next_name ns

  tclambda1 tvn FAILURE       = FAILURE
  tclambda1 tvn (OK (phi, t)) = OK (phi, arrow (phi tvn) t)

  new_bvar (x, tvn) = (x, SCHEME [] (TVAR tvn))

  || --- let expressions ---

  tclet :: type_env -> name_supply
           -> [vname] -> [vexp] -> vexp
           -> reply (subst, type_exp)
  tclet gamma ns xs es e
      = tclet1 gamma ns0 xs e (tcl gamma ns1 es)
        where (ns0, ns1) = split ns

  tclet1 gamma ns xs e FAILURE = FAILURE
  tclet1 gamma ns xs e (OK (phi, ts))
      = tclet2 phi (tc gamma'' ns1 e)
        where gamma''    = add_decls gamma' ns0 xs ts
              gamma'     = sub_te phi gamma
              (ns0, ns1) = split ns

  tclet2 phi FAILURE        = FAILURE
  tclet2 phi (OK (phi', t)) = OK (scomp phi' phi, t)

  || Update a type environment "gamma" so that it associates schematic types
  || formed from the types "ts" with the variables "xs".

  add_decls :: type_env -> name_supply -> [vname] -> [type_exp] -> type_env
  add_decls gamma ns xs ts
      = (zip xs schemes) ++ gamma
        where schemes  = map (genbar unknowns ns) ts
              unknowns = unknowns_te gamma

  genbar unknowns ns t
      = SCHEME (map snd al) t'
        where al   = zip scvs (name_sequence ns)
              scvs = bar (nodups (tvars_in t)) unknowns
              t'   = sub_type (al_to_subst al) t

  fst :: (*, **) -> *
  fst (x, y) = x

  snd :: (*, **) -> **
  snd (x, y) = y

  nodups xs = f [] xs
              where
                  f acc [] = acc
                  f acc (x:xs) = f acc xs,       if x $in acc
                               = f (x:acc) xs    otherwise

  || --- letrec expressions ---

  tcletrec :: type_env -> name_supply
              -> [vname] -> [vexp] -> vexp
              -> reply (subst, type_exp)
  tcletrec gamma ns xs es e
      = tcletrec1 gamma ns0 nbvs e (tcl (nbvs ++ gamma) ns1 es)
        where (ns0, ns') = split ns
              (ns1, ns2) = split ns'
              nbvs       = new_bvars xs ns2

  new_bvars xs ns = map new_bvar (zip xs (name_sequence ns))

  tcletrec1 gamma ns nbvs e FAILURE = FAILURE
  tcletrec1 gamma ns nbvs e (OK (phi, ts))
      = tcletrec2 gamma' ns nbvs' e (unifyl phi (zip ts ts'))
        where ts'    = map old_bvar nbvs'
              nbvs'  = sub_te phi nbvs
              gamma' = sub_te phi gamma

  old_bvar (x, SCHEME [] t) = t

  tcletrec2 gamma ns nbvs e FAILURE = FAILURE
  tcletrec2 gamm ns nbvs e (OK phi)
      = tclet2 phi (tc gamma'' ns1 e)
        where ts         = map old_bvar nbvs'
              nbvs'      = sub_te phi nbvs
              gamma'     = sub_te phi gamma
              gamma''    = add_decls gamma' ns0 (map fst nbvs) ts
              (ns0, ns1) = split ns
#+end_src
