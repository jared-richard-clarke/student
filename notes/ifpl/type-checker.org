* Polymorphic Type Checking

** Sources

| source                                                   | author                |
|----------------------------------------------------------+-----------------------|
| *The Implementation of Functional Programming Lanugages* | Simon L. Peyton Jones |
| *Hindley-Milner Type System*                             | Wikipedia             |
| *Write You a Haskell*                                    | Stephen Diehl         |
| *Type Systems: Lambda Calculus to Hindley Milner*        | Adam Jones            |

** Notation

#+begin_example
  === value :: TYPE ===

  a :: A

  === tuple ===

  - Coordinates need not be the same type.
  - Tuple type determines dimension and internal types.

  (A₁ ... Aₓ) <- type

  (a₁ ... aₓ) <- value

  === list ===

  - []
  - a:as, where a:A and as::[A]

  [A]         <- type

  [a₁ ... aₓ] <- value, if all successive entries
                 of a finite list are known.

  === structured type ===

  name v₁ ... vₓ ::= c₁ t₁₁ ... t₁ₓ
                   | ...
                   | cₓ tₓ₁ ... tₓₓ

  where name = type-forming operator
        vₓ   = type variable
        cₓ   = constructor
        tₓ   = type expression

  === function ===
  - Function "f" applicable to objects a::A, whose values, (f a),
    are of type B.

  A -> B

  - right associative, binary operation
  A -> B -> C = A -> (B -> C)
#+end_example

** Polymorphism

- monomorphic :: Operations accept values of one type.

- polymorphic :: Operations accept values of more than one type.

- ad hoc polymorphism :: A type discipline that permits the same expression
  to denote distinct operations for distinct types. The addition operator
  might denote the addition of both integers, rationals, reals, and complex
  numbers.

- parametric polymorphism :: A type discipline where operations work uniformly
  for arguments of different types. Polymorphic expressions are denoted by
  schematic variables. Polymorphic types become monomorphic by consistent
  substitution of their schematic variables.

#+begin_src
  || === parametric polymorphic ===
  ||
  || A = schematic variable

  length :: [A] -> num
  length []     = 0
  length (x:xs) = (length xs) +  1

  || === monomorphic ===

  length :: [num] -> num
  length [7, 11]

  length :: [(char, char)] -> num
  length [('a', 'b'), ('c', 'd')]

  || === parametric polymorphic ===
  ||
  || A, B, C = schematic variables

  (.) :: (B -> C) -> (A -> B) -> A -> C
  (f . g) x = f (g x)

  || === parametric polymorphic ===
  ||
  || A, B = schematic variables

  foldr :: (A -> B -> B) -> B -> [A] -> B
  foldr f b []     = b
  foldr f b (a:as) = f a (foldr f b as)

  || === monomorphic ===

  foldr :: (num -> num -> num) -> num -> [num] -> num
  foldr + 0 [7, 11, 15]

  foldr :: (string -> string -> string) -> string -> [string] -> string
  foldr append [] ["abc", "def", "ghi"]
#+end_src

** Type Inference

#+begin_quote
  "...[W]e have two type expressions that will usually contain variables,
   the first giving the form of the type required by the context
   (deduced from the 'outside'), and the second giving the form of the type
   which the object can take (deduced from the 'inside'). For the whole
   expression to be well typed, these two type expressions must match,
   in the sense that by substituting for the schematic variables
   of the type expressions, they can be brought to the same form."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
#+end_quote

In order to be sure that expression *(E_{1} E_{2})* is well-typed, the function *E_{1}*
must have type *(A -> B)*, where *E_{2}* is of type *A* and *(E_{1} E_{2})* is of type
*B*.

- The function *f* of an application *(f a)* has type *(A -> V)*,
  where *a* has type *A* and *(f a)* has type *V*.

- All occurrences of a λ-bound variable must have the same types.

- If two compound type expressions are equal, then they must be formed with
  the same construction and their corresponding parts must be equal.
  More specifically: if *(T1 -> T2) = (T1' -> T2')*, then *T1 = T1'* and *T2 = T2'*.

- If *T1 = ...T1...*, where type variable *T1* occurs properly within
  the right-hand side of the equation, then the system of equations
  cannot be solved, and the expression from which the system was derived
  is ill-typed.

#+begin_example
  || === expression ===

  (λx.λy.λz. x z (y z))

  || === AST ===

  x   z y   z
   \ /   \ /
    @     @
    |     |
    +--@--+
       |
    λx.λy.λz

  || === type tree ===

  x::T0 z::T1    y::T2 z::T3
  ----------- @  ----------- @
       T4             T5
       ----------------- @
              T6
              -- λx.λy.λz
              T7

  || === constraints ===

  - The types of the sub-expressions must be related
  - by the following equations:

  T0 ~ T1 -> T4
  T2 ~ T3 -> T5
  T4 ~ T5 -> T6

  - If we assume both instances of lambda-bound "z"
  - are of the same type, we add the two equations:

  T1 ~ T3
  T7 ~ (T0              -> T2         -> T1 -> T6)
       (T1 -> T5 -> T6) -> (T1 -> T5) -> T1 -> T6
       (A  -> B  -> C)  -> (A  -> B)  -> A  -> C

  || === expression ===

  odd :: Integer -> Boolean
  age :: Integer

  odd age

  || === type tree ===

  odd : T4 ∈ Γ               age : T5 ∈ Γ
  ------------------ [Var]   ------------ [Var]
  Γ ⊢ odd : T1 -> T2         Γ ⊢ age : T3
  --------------------------------------- [App]
             Γ ⊢ odd age : T0

  || === constraints ===

        T0 ~ T2
        T1 ~ T3
  T1 -> T2 ~ T4
        T4 ~ Integer -> Boolean
        T3 ~ T5
        T5 ~ Integer

  || === unification ===

  odd : Integer -> Boolean ∈ Γ         age : Integer ∈ Γ
  ---------------------------- [Var]   ----------------- [Var]
  Γ ⊢ odd : Integer -> Boolean         Γ ⊢ age : Integer
  ------------------------------------------------------ [App]
                    Γ ⊢ odd age : Boolean
#+end_example

** Intermediate Language

A transformed program should be type checked after dependency analysis
but before lambda lifting or transformation into a supercombinator.

#+begin_example
  expression ::= variable
               | λvariable.expression
               | expression expression
               | let variable-1 = expression-1
                     ...
                     variable-x = expression-x
                 in expression
               | letrec variable-1 = expression-1
                        ...
                        variable-x = expression-x
                 in <expression>
#+end_example

** Hindley-Milner Type System

#+begin_example
  || === Expressions ===

  e = x
    | e₁ e₂
    | λx.e
    | let x = e₁ in e₂

  || === Types ===

  || --- monotype ---
  ||
  || Monotypes designate a particular type. Not to be confused
  || with monomorphic types, which exclude variables and allow
  || only ground terms.

  τ = α
    | C τ ... τ

  where α = type variable
        C = type constructor

  || --- polytype ---
  ||
  || Polytypes — or type schemes — are types containing
  || variables bound by zero or more for-all quantifiers.
  || Qualifiers can only appear top level. ∀α.α -> ∀α.α
  || is not allowed.

  σ = τ
    | ∀α.σ

  where τ    = monotype
        ∀α.σ = for-all quantifier

  +----------------------------------------+
  |     +--------------------------------+ |
  |     | +----------------------------+ | |
  |     | |      +-------------------+ | | |
  |     | |      |   +---+   +---+   | | | |
  | ∀α. | | List | ( | α | → | α | ) | | | |
  |     | |      |   +var+   +var+   | | | |
  |     | |      +--- constructor ---+ | | |
  |     | +---------- constructor -----+ | |
  |     +------------ monotype ----------+ |
  +------------------ quantifier ----------+


  || === Context and Typing ===
  ||
  || Brings together syntax expressions and types.

  || --- context --
  ||
  || A context is a list of pairs (x : σ).

  Γ = ε (empty)
    | Γ, x : σ

  || --- typing ---
  ||
  || Under the assumptions Γ, the expression e has type σ.

  Γ ⊢ e : σ

  || === Free Type Variables ===
  ||
  || For type ∀α₁ ... ∀αₓ.τ, ∀ is the quantifier binding the type variables
  || αₓ in the monotype τ.

  free(α)           = {α}

                       x
  free(C τ₁ ... τₓ) =  ∪ free(τᵢ)
                     i = 1

  free(Γ)           =  ∪ free(σ)
                     x : σ ∈ Γ

  free(∀α.σ)        = free(σ) - {α}

  free(Γ ⊢ e : σ)   = free(σ) - free(Γ)

  || === Syntax of Rules ===

  Predicate  = σ₁ ⊑ σ₂
             | α ∉ free(Γ)
             | x : σ ∈ Γ

  Judgement  = Typing

  Premise    = Judgement | Predicate

  Conclusion = Judgement

               Premise ...
  Rule       = ----------- [Name]
               Conclusion

  || === Declarative Rule System ===

  || --- Variable ---

  x : σ ∈ Γ
  ---------                        [Var]
  Γ ⊢ x : σ

  || --- Application ---

  Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
  -------------------------------- [App]
           Γ ⊢ e₁ e₂ : τ₂

  || --- Abstraction ---

  Γ, x : τ₁ ⊢ e : τ₂
  -------------------              [Abs]
  Γ ⊢ λx.e : τ₁ → τ₂

  || --- Let ---

  Γ ⊢ e₁ : σ   Γ, x : σ ⊢ e₂ : τ
  -------------------------------  [Let]
     Γ ⊢ let x = e₁ in e₂ : τ

  || --- Instantiation ---
  ||
  || Replace all instances of a quantified type variable
  || with a fresh monotype variable.
  ||
  || σ₁ ⊑ σ₂ reads "σ₁ is either more general than or equally general to σ₂".
  || More formally, σ₁ is more general than σ₂ if there is a substitution S
  || that maps the for-all quantified variables in σ₁, and S(σ₁) = σ₂

  Γ ⊢ e : σ₁    σ₁ ⊑ σ₂
  ---------------------            [Inst]
       Γ ⊢ e : σ₂

  || --- Generalization ---
  ||
  || Converts monotype τ into polytype σ by closing
  || over all free type variables in τ.

  Γ ⊢ e : σ    α ∉ free(Γ)
  ------------------------         [Gen]
      Γ ⊢ e : ∀α.σ

  || === Syntactical Rule System ===

  || --- Variable and Instantiation ---

   x : σ ∈ Γ    σ ⊑ τ
   ------------------                    [Var]
       Γ ⊢ x : τ

  || --- Application ---

  Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
  --------------------------------       [App]
           Γ ⊢ e₁ e₂ : τ₂

  || --- Abstraction ---

  Γ, x : τ₁ ⊢ e : τ₂
  -------------------                    [Abs]
  Γ ⊢ λx.e : τ₁ → τ₂

  || --- Let and Generalization ---
                       -
  Γ ⊢ e₁ : τ₁   Γ, x : Γ(τ₁) ⊢ e₂ : τ₂
  -------------------------------------  [Let]
        Γ ⊢ let x = e₁ in e₂ : τ₂

  || Quantify all monotype variables not bound in Γ
  || to give the most general type for a given
  || expression.

  -
  Γ(τ) = ∀α₁...αₓ.τ

  α₁...αₓ = free(τ) - free(Γ)

  || === Recursive Extension ===
  ||
  || Merge [Abs] and [Let], where left of "in" allows monotype variables
  || and right of "in" allows polytype variables.

  Γ, Γ' ⊢ e₁ : τ₁ ... Γ, Γ' ⊢ eₓ : τₓ    Γ, Γ'' ⊢ e : τ
  ------------------------------------------------------ [Letrec]
  Γ ⊢ letrec v₁ = e₁ ... vₓ = eₓ in e : τ

  || --- monotype variables ---
  where Γ'  = v₁ : τ₁, ... , vₓ : τₓ
  || --- polytype variables ---
                   -                 -
        Γ'' = v₁ : Γ(τ₁), ... , vₓ : Γ(τₓ)
#+end_example

*** Unification

- substitution :: A mapping from a free variable in a type to its corresponding
  term in an environment.

- constraint :: A requirement that two types have a common substitution
  instance.

- unification :: A partial function that either turns a set of constraints
  into a substitution or fails when it encounters unsatisfiable constraints.
  A unification algorithm may be described in three parts:

  1. Any type variable unifies with any type expression, and is instantiated
     to that expression. A specific theory might restrict this rule with an
     occurs check.

  2. Two type constants unify only if they are the same type.

  3. Two type constructions unify only if they are applications of the same
     type constructor and all of their component types recursively unify.

#+begin_example
  || === unification ===

  || Terms "a" and "b" are unifiable by substitution "s".

  a ~ b (s) = [s]a = [s]b

  || --- same ---

  α ~ α ([])

  || --- left-hand side ---

  α ∉ free(τ)
  ---------------
  α ~ τ ([α ↦ τ])

  || --- right-hand side ---

  α ∉ free(τ)
  ---------------
  τ ~ α ([α ↦ τ])

  || --- arrow (→) ---

  τ₁ ~ τ'₂ (s₁)    [s₁]τ₂ ~ [s₁]τ'₂ (s₂)
  --------------------------------------
  τ₁ → τ₂ ~ τ'₁ → τ'₂ (s₂ ∘ s₁)
#+end_example

** Inference Algorithms

*** Algorithm J

#+begin_example
  x : σ ∈ Γ    τ = inst(σ)
  ------------------------                                        [Var]
  Γ ⊢ x : τ

  Γ ⊢ e₁ : τ₁    Γ ⊢ e₂ : τ₂    τ' = newvar    unify(τ₁, τ₂ → τ')
  --------------------------------------------------------------- [App]
  Γ ⊢ e₁ e₂ : τ'

  τ = newvar    Γ, x : τ ⊢ e : τ'
  -------------------------------                                 [Abs]
  Γ ⊢ λx.e : τ → τ'
                       -
  Γ ⊢ e₁ : τ    Γ, x : Γ(τ) ⊢ e₂ : τ'
  ------------------------------------                            [Let]
  Γ ⊢ let x = e₁ in e₂ : τ'

  || "inst(σ)" specializes the polytype "σ" by copying the term
  || and replacing bound type variables consistently by new
  || monotype variables.

  || "newvar" produces new monotype variables.

  || Quantify all monotype variables not bound in Γ
  || to give the most general type for a given
  || expression.

  -
  Γ(τ) = ∀α₁...αₓ.τ

  α₁...αₓ = free(τ) - free(Γ)
#+end_example

*** Algorithm W

Makes the side effects imposed by the procedure *unify* explicit by expressing
its serial composition by means of the substitution *Sₓ*. The judgement
*Γ ⊢ e : τ, S* denotes a function that accepts a context and expression and
returns a monotype and substitution pairing.

#+begin_example
  x : σ ∈ Γ    τ = inst(σ)
  ------------------------                         [Var]
  Γ ⊢ x : τ, ∅

  Γ ⊢ e₁ : τ₁, S₁    S₁Γ ⊢ e₂ : τ₂, S₂
  τ' = newvar        S₃ = mgu(S₂τ₁, τ₂ → τ')
  ------------------------------------------       [App]
  Γ ⊢ e₁ e₂ : S₃τ', S₃S₂S₁

  τ = newvar    Γ, x : τ ⊢ e : τ', S
  ----------------------------------               [Abs]
  Γ ⊢ λx.e : Sτ → τ', S
                               -
  Γ ⊢ e₁ : τ , S₁   S₁Γ, x : S₁Γ(τ) ⊢ e₂ : τ', S₁
  ------------------------------------------------ [Let]
  Γ ⊢ let x = e₁ in e₂ : τ', S₂S₁

  || "mgu" is a side-effect free version of "unify", producing a substitution,
  || which is the most general unifier.

  || Quantify all monotype variables not bound in Γ
  || to give the most general type for a given
  || expression.

  -
  Γ(τ) = ∀α₁...αₓ.τ

  α₁...αₓ = free(τ) - free(Γ)
#+end_example

** Miranda Example

1. *Assign type variables*: Assign fresh type variables to expressions whose
   type is unknown.

2. *Collect constraints*: Traverse the abstract syntax tree of a program,
   gathering type constraints based on how expressions are used.
   If *f* has type *T1 -> T2*, then *x* in *(f x)* must have type *T1*.

3. *Unify*: Find substitutions for type variables that satisfy all constraints.
   Determine either the concrete types or most general polymorphic types.
   Consistent substitution means an expression is well-typed.

4. *Generalize*: For a ~let~ expression, the inferred monotype for the bound
   value is generalized to a polytype by quantifying over all free type variables,
   allowing the bound variable to be different types in the body of the expression.

#+begin_quote
  "Essentially, type inference is the process of descending the abstract syntax
   tree, assigning fresh type variables to every expression, and generating a set
   of constraints based on what information is available. Afterwards, solving the
   set of constraints (much like solving a system of equations), will result in
   a substitution. This substitution will map every generated type variable to
   an inferred principal type. The process of solving the constraints is known
   as unification. (The principal type is, more or less, the most general type
   of an expression, i.e. any other possible types for the expression are
   instances of the principal type.)"

  — *Implementing a Hindley-Milner Type System*, O5st

  "There is a partial analogy between type schemes and lambda abstractions.
   The schematic variables of a type scheme correspond to the formal parameter
   of a lambda abstraction, and the unknowns of a type scheme correspond to
   the free variables of a lambda abstraction. Applying a lambda abstraction
   to an argument involves constructing an instance of its body, substituting
   the argument for occurrences of the formal parameter
   (but copying free variables unchanged). This is very similar to the process
   of instantiating a type scheme, which involves constructing an instance
   of the type scheme template, substituting fresh type variables for
   occurrences of the schematic variables (but copying unknowns unchanged)."

  — *The Implementation of Functional Programming Languages*,
    Simon L. Peyton Jones and Peter Hancock
#+end_quote

#+begin_src
  || === Program Expressions ===

  vname == [char]

  vexp ::= VAR vname
         | LAMBDA vname vexp
         | AP vexp vexp
         | LET [vname] [vexp] vexp
         | LETREC [vname] [vexp] vexp

  || === Type Expressions ===

  tvname == [char]

  type_exp ::= TVAR tvname             || type variable
             | TCONS [char] [type_exp] || concrete type

  || t1 -> t2

  arrow :: type_exp -> type_exp
  arrow t1 t2 = TCONS "arrow" [t1, t2]

  int :: type_exp
  int = TCONS "int" []

  || (t1, t2)

  cross :: type_exp -> type_exp -> type_exp
  cross t1 t2 = TCONS "cross" [t1, t2]

  || [t]

  list :: type_exp type_exp
  list t = TCONS "list" [t]

  || Returns a list of the variable names that occur in a type expression.

  tvars_in :: type_exp -> [tvname]
  tvars t = f t []
            where
                f (TVAR x) xs     = x:xs
                f (TCONS y ts) xs = foldr f xs ts

  || === Success and Failure ===

  reply * ::= OK * | FAILURE

  || === Solving Equations ===
  ||
  || "An alleged solution of a system of type equations can be expressed
  ||  as a function from type variables (the unknowns) to type expressions
  ||  (their values)...[E]quations are satisfied when we replace (i.e. substitute)
  ||  the unknowns by their values under the function."
  ||
  || — Chapter 9: A Type-checker, Peter Hancock

  || substitutions

  subst == tvname -> type_exp

  || Derives a type expression by performing the phi substitution
  || on all the type variables in te.

  sub_type :: subst -> type_exp -> type_exp
  sub_type phi (TVAR tvn)     = phi tvn
  sub_type phi (TCONS tcn ts) = TCONS tcn (map (sub_type phi) ts)

  map :: (* -> **) -> [*] -> [**]
  map f []     = []
  map f (x:xs) = f x : map f xs

  || composition: sub_type (scomp phi psi) = (sub_type phi) ∘ (sub_type psi)

  scomp :: subst -> subst -> subst
  scomp sub2 sub1 tvn = sub_type sub2 (sub1 tvn)

  || identity: sub_type id_subst t = t

  id_subst :: subst
  id_subst tvn = TVAR tvn

  || delta substitution
  ||
  || (sub_type (delta tvn t)) maps a type expression to "t"
  || where before it had "(TVAR tvn)".

  delta :: tvname -> type_exp -> subst
  delta tvn t tvn' = t,           if tvn = tvn'
                   = TVAR tvn',   otherwise

  || idempotent: (sub_type phi) ∘ (sub_type phi) = sub_type phi
  ||
  || fixed point: sub_type phi t = t

  || === Unification ===
  ||
  || "The problem of unification is to find a maximally general
  ||  idempotent unifier of a set of pairs of expressions."
  ||
  || — Chapter 9: A Type-checker, Peter Hancock
  ||
  || type expression: (t1, t2) or t1 = t2
  ||
  || phi unifies (t1, t2) if sub_type phi t1 = sub_type phi t2

  || Expression (extend phi tvn t) will only be evaluated when:
  ||
  || 1. phi is an idempotent substitution (the solution we are trying to extend)
  || 2. t is a fixed point of phi
  || 3. tvn is unmoved by phi (tvn does not already have a value under phi)

  extend :: subst -> tvname -> type_exp -> reply subst
  extend phi tvn t = OK phi,                        if t = TVAR tvn
                   = FAILURE,                       if tvn $in (tvars_in t)
                   = OK (scomp (delta tvn t) phi),  otherwise

  || --- unification algorithm ---

  unify :: subst -> (type_exp, type_exp) -> reply subst

  unify phi ((TVAR tvn), t)
      = extend phi tvn phit,       if phitvn = TVAR tvn
      = unify phi (phitvn, phit),  otherwise
        where phitvn = phi tvn
              phit   = sub_type phi t

  unify phi ((TCONS tcn ts), (TVAR tvn))
      = unify phi ((TVAR tv), (TCONS tcn ts))

  unify phi ((TCONS tcn ts), (TCONS tcn' ts'))
      = unifyl phi (zip ts ts'),    if tcn = tcn'
      = FAILURE,                    otherwise

  zip :: [*] -> [**] -> [(*, **)]
  zip [] xs     = []
  zip (x:xs) [] = []
  zip (x:xs) (y:ys) = (x, y) : zip xs ys

  || (unifyl phi pts) constructs a substitution extending phi,
  || which unifies corresponding entries in the list of pairs pts.

  unifyl :: subst -> [(type_exp, type_exp)] -> reply subst
  unifyl phi eqns = foldr f (OK phi) eqns
                    where
                        f eqn (OK phi) = unify phi eqn
                        f eqn FAILURE  = FAILURE

  || === Type Scheme ===

  type_scheme ::= SCHEME [tvname] type_exp

  unknowns_scheme :: type_scheme -> [tvname]
  unknowns_scheme (SCHEME scvs t) = tvars_in (bar t scvs)

  bar :: [*] -> [*] -> [*]
  bar xs ys = [ x <- xs | ~(x $in ys)]

  in :: * -> [*] -> bool
  in x' []     = False
  in x' (x:xs) = True,      if x = x'
               = x' $in xs, otherwise

  sub_scheme :: subst -> type_scheme -> type_scheme
  sub_scheme phi (SCHEME scvs t)
      = SCHEME scvs (sub_type (exclude phi scvs) t)

  exclude phi scvs tvn = TVAR tvn,    if tvn $in scvs
                       = phi tvn,     otherwise

  || type environment = [(free variable, type scheme)]

  assoc_list * ** == [(*, **)]

  dom :: assoc_list * ** -> [*]
  dom al = [ k | (k, v) <- al ]

  val :: assoc_list * ** -> * -> **
  val al k = hd [ v | (k', v) <- al; k = k' ]

  install al k v = (k, v):al

  rng :: assoc_list * ** -> [**]
  rng al = map (val al) (dom al)

  type_env == assoc_list vname type_scheme

  unknowns_te :: type_env -> [tvname]
  unknowns_te gamma = appendlist (map unknowns_scheme (rng gamma))

  appendlist :: [ [*] ] -> [*]
  appendlist lls = foldr (++) [] lls

  sub_te :: subst -> type_env -> type_env
  sub_te phi gamma
      = [ (x, sub_scheme phi st) | (x, st) <- gamma ]

  || === new variables ===

  next_name :: name_supply -> tvname
  deplete   :: name_supply -> name_supply
  split     :: name_supply -> (name_supply, name_supply)

  tvname      == [num]
  name_supply == tvname

  next_name ns   = ns
  deplete (n:ns) = (n+2:ns)
  split ns       = (0:ns, 1:ns)

  name_sequence :: name_supply -> [tvname]
  name_sequence ns = next_name ns : name_sequence (deplete ns)

  || === Type Checker ===
  ||
  || (tc gamma ns e) -> reply (phi, t)
  ||
  || where gamma = type environment
  ||       ns    = supply of type variable names
  ||       e     = expression to be checked
  ||       phi   = substitution defined on unknown type variables in gamma
  ||       t     = a type derived for the expression e
  ||               in the type environment (sub_te phi gamma).
  ||               Fixed point of the substitution of phi.

  tc :: type_env -> name_supply -> vexp -> reply (subst, type_exp)
  tc gamma ns (VAR x)          = tcvar gamma ns x
  tc gamma ns (AP e1 e2)       = tcap gamma ns e1 e2
  tc gamma ns (LAMBDA x e)     = tclambda gamma ns x e
  tc gamma ns (LET xs es e)    = tclet gamma ns xs es e
  tc gamma ns (LETREC xs es e) = tcletrec gamma ns xs es e

  || --- type checking lists of expressions ---

  tcl :: type_env -> name_supply -> [vexp] -> reply (subst, [type_exp])
  tcl gamma ns []     = OK (id_subst, [])
  tcl gamma ns (e:es) = tcl1 gamma ns0 es (tc gamma ns1 e)
                        where (ns0, ns1) =  split ns

  tcl1 gamma ns es FAILURE       = FAILURE
  tcl1 gamma ns es (OK (phi, t)) = tcl2 phi t (tcl gamma' ns es)
                                   where gamma' = sub_te phi gamma

  tcl2 phi t FAILURE        = FAILURE
  tcl2 phi t (OK (psi, ts)) = OK (scomp psi phi, (subt_type psi t) : ts)

  || --- variables ---

  tcvar :: type_env -> name_supply -> vname -> reply (subst, type_exp)
  tcvar gamma ns x = OK (id_subst, newinstance ns scheme)
                     where scheme = val gamma x

  newinstance :: name_supply -> type_scheme -> type_exp
  newinstance ns (SCHEME scvs t) =
      sub_type phi t
      where al  = zip scvs (name_sequence ns)
            phi = al_to_subst al

  al_to_subst :: assoc_list tvname tvname -> subst
  al_to_subst al tvn = TVAR (val al tvn),    if tvn $in (dom al)
                     = TVAR tvn,             otherwise

  || --- application ---

  tcap :: type_env -> name_supply -> vexp -> vexp -> reply (subst, type_exp)
  tcap gamma ns e1 e2
      = tcap1 tvn (tcl gamma ns' [e1, e2])
        where tvn = next_name ns
              ns' = deplete ns

  tcap1 tvn FAILURE = FAILURE
  tcap1 tvn (OK (phi, [t1, t2]))
      = tcap2 tvn (unify phi (t1, arrow t2 (TVAR tvn)))

  tcap2 tvn FAILURE = FAILURE
  tcap2 tvn (OK phi) = OK (phi, phi tvn)

  || --- Lambda Abstractions ---

  tclambda :: type_env -> name_supply -> vname -> vexp -> reply (subst, type_exp)
  tclambda gamma ns x e
      = tclambda1 tvn (tc gamma' ns' e)
        where ns'   = deplete ns
              gamma = new_bvar (x, tvn) : gamma
              tvn   = next_name ns

  tclambda1 tvn FAILURE       = FAILURE
  tclambda1 tvn (OK (phi, t)) = OK (phi, arrow (phi tvn) t)

  new_bvar (x, tvn) = (x, SCHEME [] (TVAR tvn))

  || --- let expressions ---

  tclet :: type_env -> name_supply
           -> [vname] -> [vexp] -> vexp
           -> reply (subst, type_exp)
  tclet gamma ns xs es e
      = tclet1 gamma ns0 xs e (tcl gamma ns1 es)
        where (ns0, ns1) = split ns

  tclet1 gamma ns xs e FAILURE = FAILURE
  tclet1 gamma ns xs e (OK (phi, ts))
      = tclet2 phi (tc gamma'' ns1 e)
        where gamma''    = add_decls gamma' ns0 xs ts
              gamma'     = sub_te phi gamma
              (ns0, ns1) = split ns

  tclet2 phi FAILURE        = FAILURE
  tclet2 phi (OK (phi', t)) = OK (scomp phi' phi, t)

  || Update a type environment "gamma" so that it associates schematic types
  || formed from the types "ts" with the variables "xs".

  add_decls :: type_env -> name_supply -> [vname] -> [type_exp] -> type_env
  add_decls gamma ns xs ts
      = (zip xs schemes) ++ gamma
        where schemes  = map (genbar unknowns ns) ts
              unknowns = unknowns_te gamma

  genbar unknowns ns t
      = SCHEME (map snd al) t'
        where al   = zip scvs (name_sequence ns)
              scvs = bar (nodups (tvars_in t)) unknowns
              t'   = sub_type (al_to_subst al) t

  fst :: (*, **) -> *
  fst (x, y) = x

  snd :: (*, **) -> **
  snd (x, y) = y

  nodups xs = f [] xs
              where
                  f acc [] = acc
                  f acc (x:xs) = f acc xs,       if x $in acc
                               = f (x:acc) xs    otherwise

  || --- letrec expressions ---

  tcletrec :: type_env -> name_supply
              -> [vname] -> [vexp] -> vexp
              -> reply (subst, type_exp)
  tcletrec gamma ns xs es e
      = tcletrec1 gamma ns0 nbvs e (tcl (nbvs ++ gamma) ns1 es)
        where (ns0, ns') = split ns
              (ns1, ns2) = split ns'
              nbvs       = new_bvars xs ns2

  new_bvars xs ns = map new_bvar (zip xs (name_sequence ns))

  tcletrec1 gamma ns nbvs e FAILURE = FAILURE
  tcletrec1 gamma ns nbvs e (OK (phi, ts))
      = tcletrec2 gamma' ns nbvs' e (unifyl phi (zip ts ts'))
        where ts'    = map old_bvar nbvs'
              nbvs'  = sub_te phi nbvs
              gamma' = sub_te phi gamma

  old_bvar (x, SCHEME [] t) = t

  tcletrec2 gamma ns nbvs e FAILURE = FAILURE
  tcletrec2 gamm ns nbvs e (OK phi)
      = tclet2 phi (tc gamma'' ns1 e)
        where ts         = map old_bvar nbvs'
              nbvs'      = sub_te phi nbvs
              gamma'     = sub_te phi gamma
              gamma''    = add_decls gamma' ns0 (map fst nbvs) ts
              (ns0, ns1) = split ns
#+end_src

** Haskell Example

*Side Note*: This implementation intermingles constraint solving and traversal.

#+begin_quote
  "The Hindley-Milner type system ... is a family of type systems
  that admit the serendipitous property of having a tractable
  algorithm for determining types from untyped syntax. This is
  achieved by a process known as unification, whereby the types
  for a well-structured program give rise to a set of constraints
  that when solved always have a unique principal type.

  ...

  Milner’s observation was that since the typing rules map uniquely
  onto syntax, we can in effect run the typing rules 'backwards'
  and whenever we don’t have a known type for a subexpression,
  we 'guess' by putting a fresh variable in its place, collecting
  constraints about its usage induced by subsequent typing judgements.
  This is the essence of type inference in the ML family of languages,
  that by the generation and solving of a class of unification problems
  we can reconstruct the types uniquely from the syntax. The algorithm
  itself is largely just the structured use of a unification solver."

  — *Write You a Haskell*, Stephen Diehl
#+end_quote

#+begin_src haskell
  -- === Syntax ===

  type Name = String

  data Expr
    = Var Name
    | App Expr Expr
    | Lam Name Expr
    | Let Name Expr Expr
    | Lit Lit
    | If  Expr Expr Expr
    | Fix Expr
    | Op  Binop Expr Expr
    deriving (Show, Eq, Ord)

  data Lit
    = LInt  Integer
    | LBool Bool
    deriving (Show, Eq, Ord)

  data Binop = Add | Sub | Mul | Eql
    deriving (Eq, Ord, Show)

  data Program = Program [Decl] Expr deriving Eq

  type Decl = (String, Expr)

  -- === Types ===

  newtype TVar = TV String
    deriving (Show, Eq, Ord)

  data Type
    = TVar TVar
    | TCon String
    | TArr Type Type
    deriving (Show, Eq, Ord)

  typeInt :: Type
  typeInt = TCon "Int"
  
  typeBool :: Type
  typeBool = TCon "Bool"

  data Scheme = Forall [TVar] Type

  data TypeError
    = UnificationFail Type Type
    | InfiniteType    TVar Type
    | UnboundVariable String

  data Unique = Unique { count :: Int }

  initUnique :: Unique
  initUnique = Unique { count = 0 }

  -- === Context ===

  newtype TypeEnv = TypeEnv (Map.Map Var Scheme)

  extend :: TypeEnv -> (Var, Scheme) -> TypeEnv
  extend (TypeEnv env) (x, s) = TypeEnv (Map.insert x s env)

  emptyTyenv :: TypeEnv
  emptyTyenv = TypeEnv Map.empty

  lookupEnv :: TypeEnv -> Var -> Infer (Subst, Type)
  lookupEnv (TypeEnv env) x = do
    case Map.lookup x env of
      Nothing -> throwError (UnboundVariable (show x))
      Just s  -> do t <- instantiate s
                    return (nullSubst, t)

  -- === Inference Monad ===

  type Infer a = ExceptT TypeError (State Unique) a

  runInfer :: Infer (Subst, Type) -> Either TypeError Scheme
  runInfer m = case evalState (runExceptT m) initUnique of
    Left err  -> Left err
    Right res -> Right (closeOver res)

  -- The function "closeOver" is not fully defined here.
  -- It is part of a more elaborate Haskell compiler
  -- implementation as defined by author Stephen Diehl.

  closeOver :: (Map.Map TVar Type, Type) -> Scheme
  closeOver (sub, ty) = normalize sc
                        where sc = generalize emptyTyenv (apply sub ty)

  -- === Substitution ===

  type Subst = Map.Map TVar Type

  nullSubst :: Subst
  nullSubst = Map.empty

  compose :: Subst -> Subst -> Subst
  compose s1 s2 = Map.map (apply s1) (Map.union s2 s1)

  class Substitutable a where
    apply :: Subst -> a -> a
    ftv   :: a -> Set.Set TVar

  instance Substitutable Type where
    apply _ (TCon a)     = TCon a
    apply s t@(TVar a)   = Map.findWithDefault t a s
    apply s (TArr t1 t2) = TArr (apply s t1) (apply s t2)

    ftv TCon{}       = Set.empty
    ftv (TVar a)     = Set.singleton a
    ftv (TArr t1 t2) = Set.union (ftv t1) (ftv t2)

  instance Substitutable Scheme where
    apply s (Forall as t) = Forall as (apply s' t)
                            where s' = foldr Map.delete s as

    ftv (Forall as t) = Set.difference (ftv t) (Set.fromList as)

  instance Substitutable a => Substitutable [a] where
    apply = fmap . apply
    ftv = foldr (Set.union . ftv) Set.empty

  instance Substitutable TypeEnv where
    apply s (TypeEnv env) = TypeEnv (Map.map (apply s) env)
    ftv (TypeEnv env) = ftv (Map.elems env)

  -- === Name Generation ===

  letters :: [String]
  letters = [1..] >>= flip replicateM ['a'..'z']

  fresh :: Infer Type
  fresh = do
    s <- get
    put s{count = count s + 1}
    return (TVar (TV (letters !! count s)))

  -- === Unification ===

  occursCheck :: Substitutable a => TVar -> a -> Bool
  occursCheck a t = Set.member a (ftv t)

  unify :: Type -> Type -> Infer Subst
  unify (TArr l r) (TArr l' r') = do
    s1 <- unify l l'
    s2 <- unify (apply s1 r) (apply s1 r')
    return (compose s2 s1)

  unify (TVar a) t                 = bind a t
  unify t (TVar a)                 = bind a t
  unify (TCon a) (TCon b) | a == b = return nullSubst
  unify t1 t2                      = throwError (UnificationFail t1 t2)

  bind :: TVar -> Type -> Infer Subst
  bind a t | t == TVar a     = return nullSubst
           | occursCheck a t = throwError (InfiniteType a t)
           | otherwise       = return (Map.singleton a t)

  -- === Generalization and Instantiation ===

  instantiate :: Scheme -> Infer Type
  instantiate (Forall as t) = do
    as' <- mapM (const fresh) as
    let s = Map.fromList (zip as as')
    return (apply s t)

  generalize :: TypeEnv -> Type -> Scheme
  generalize env t = Forall as t
                     where as = Set.toList (Set.difference (ftv t) (ftv env))

  -- === Typing Rules ===

  infer :: TypeEnv -> Expr -> Infer (Subst, Type)
  infer env ex = case ex of

    -- x : σ ∈ Γ
    -- --------- [Var]
    -- Γ ⊢ x : σ
    Var x -> lookupEnv env x

    -- Γ, x : τ₁ ⊢ e : τ₂
    -- ------------------- [Abs]
    -- Γ ⊢ λx.e : τ₁ → τ₂
    Lam x e -> do
      tv <- fresh
      let env' = extend env (x, Forall [] tv)
      (s1, t1) <- infer env' e
      return (s1, apply s1 (TArr tv t1))

    -- Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
    -- -------------------------------- [App]
    --          Γ ⊢ e₁ e₂ : τ₂
    App e1 e2 -> do
      tv       <- fresh
      (s1, t1) <- infer env e1
      (s2, t2) <- infer (apply s1 env) e2
      s3       <- unify (apply s2 t1) (TArr t2 tv)
      return (s3 `compose` s2 `compose` s1, apply s3 tv)

    -- Γ ⊢ e₁ : σ   Γ, x : σ ⊢ e₂ : τ
    -- -------------------------------  [Let]
    --    Γ ⊢ let x = e₁ in e₂ : τ
    Let x e1 e2 -> do
      (s1, t1) <- infer env e1
      let env' = apply s1 env
      t' = generalize env' t1
      (s2, t2) <- infer (extend env' (x, t')) e2
      return (s1 `compose` s2, t2)

    If cond tr fl -> do
      (s1, t1) <- infer env cond
      (s2, t2) <- infer env tr
      (s3, t3) <- infer env fl
      s4       <- unify t1 typeBool
      s5       <- unify t2 t3
      return (s5 `compose` s4 `compose` s3 `compose` s2 `compose` s1, apply s5 t2)

    Fix e1 -> do
      (s1, t) <- infer env e1
      tv      <- fresh
      s2      <- unify (TArr tv tv) t
      return (s2, apply s1 tv)

    Op op e1 e2 -> do
      (s1, t1) <- infer env e1
      (s2, t2) <- infer env e2
      tv       <- fresh
      s3       <- unify (TArr t1 (TArr t2 tv)) (ops Map.! op)
      return (s1 `compose` s2 `compose` s3, apply s3 tv)

    Lit (LInt _)  -> return (nullSubst, typeInt)
    Lit (LBool _) -> return (nullSubst, typeBool)
#+end_src
