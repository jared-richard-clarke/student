
* Template Instantiation

Original source code authored by Simon L. Peyton Jones and David R. Lester.

The simplest possible implementation of a functional language is a graph reducer based
on /template instantiation/.

- A functional program is executed by evaluating an expression.
- The expression is represented by a graph.
- Evaluation is carried out by a sequence of reductions.
- Reduction replaces a reducible expression (redex) in a graph by its reduced form.
- When there are no more redexes, the expression is in /normal form/.
- At any time there may be more than one redex in the expression being evaluated, so
  there is a choice about which one to reduce next. Normal form is always the same no
  matter the order, but some reduction sequences may fail to terminate.
   /Normal Order Reduction/, the process of always selecting the outermost redex, will
   always terminate.
  
Ordinary expressions describe trees, *let* expressions describe acyclic graphs, and
*letrec* expressions describe cyclic graphs.

** Evaluation

#+begin_example
until there are no more redexes
    select the outermost redex
    reduce it
    update the redex with the result
end

=== example ===

square x = x * x
main = square (square 3)

=== reduction ===

       @! <- root
      / \
square   @
        / \
  square   3

-- reduces ->

       @
      / \
     @   \
    / \__ @!  
  *      / \
   square   3

-- reduces ->

       @
      / \
     @   \
    / \__ @
   *     / \
        @   \
       / \__ 3
      *

-- reduces ->

       @
      / \
     @   \
    / \__ 9
   *

-- reduces ->

81
#+end_example

** Primitive Redexes

The application of a built-in primitive may or may not be a redex, depending on
whether the arguments are evaluated. If not, then the arguments must be evaluated.
This is accomplished by repeatedly finding the outermost redex of each argument
and reducing it.

** Supercombinator Redexes

A supercombinator is always a redex. It can be reduced by replacing the redex with
an instance of the supercombinator body, substituting pointers to the actual arguments
for corresponding occurrences of the formal parameters.

** Unwinding the Spine to Find the Next Redex

The first step of the reduction cycle is to find the site of the next reduction to be
performed, the outermost reducible function application.

1. Starting at the root, follow the left branch of application nodes until you
   get to a supercombinator or built-in primitive. This left-branching chain of
   application nodes is called the /spine/ of the expression. This process is
   called /unwinding/ the spine. Usually a /stack/ is used to remember address
   nodes.
2. Now check how many arguments the supercombinator or primitive takes and go
   back up that number of application nodes. You have found the root of the
   outermost function application.

#+begin_example
=== expression ===

(f E1 E2 E3) where (f E1 E2)

=== stack ===

 ---------
  | --- | ------> @
  -------        / \
  | --- | ----> @!  E3
  -------      / \
  | --- | --> @   E2
  -------    / \
  | --- | > f   E1
  -------
#+end_example

A *dump*, or stack of stacks, is created to track an expression with multiple
roots. This is usually implemented as a single stack where substacks are
delineated by pointer addresses.

#+begin_example
=== expression ===

f x = let y = x * x
      in y + y

=== graph ===

      @
     / \
    f   3

-- reduces ->

     @
    / \
   @   \
  / \__ @y
 +     / \
      @   \
     / \__ 3
    *
#+end_example

** Updates

With /lazy evaluation/ a redex may not be evaluated at all, but if it is
evaluated, an update ensures that redex is evaluated only once.

#+begin_example
=== expression ===

id x = x
f p = (id p) * p
main = f (sqrt 4)

=== reduction ==

       @
      / \
     @   \
    / \   \
   *   @   \
      / \__ @
    id     / \
        sqrt  4

-- reduces ->

       @
      / \
     @   \
    / \   \
   *   #   \
        \__ @
           / \
        sqrt  4

where # = indirection node
#+end_example
