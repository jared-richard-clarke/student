* Core Language, Pretty Printing, Parsing

Original source code authored by Simon L. Peyton Jones and David R. Lester.

** Core Language

#+begin_src haskell
type Name = String

-- A core lang program is a list of supercombinator definitions.
type Program a = [ScDefn a]
type CoreProgram = Program Name

-- Supercombinator (top-level) definition = (name, arguments, body)
type ScDefn a = (Name, [a], Expr a)
type CoreScDefn = ScDefn Name

-- Case expressions
type Alter a = (Int, [a], Expr a)
type CoreAlt = Alter Name

type CoreExpr = Expr Name

-- The main expr data type
data Expr a
  = EVar Name               -- Variables
  | ENum Int                -- Numbers
  | EConstr Int Int         -- Constructor tag arity
  | EAp (Expr a) (Expr a)   -- Applications
  | ELet                    -- Let(rec) expressions
      Bool                  --   boolean with True = recursive,
      [(a, Expr a)]         --   Definitions
      (Expr a)              --   Body of let(rec)
  | ECase                   -- Case expression
      (Expr a)              --   Expression to scrutinise
      [Alter a]             --   Alternatives
  | ELam [a] (Expr a)       -- Lambda abstractions
  deriving (Show, Eq)

-- Definition = (variable name, expression).
bindersOf :: [(a,b)] -> [a]
bindersOf = map fst

rhssOf :: [(a,b)] -> [b]
rhssOf = map snd

isAtomicExpr :: Expr a -> Bool
isAtomicExpr (EVar _) = True
isAtomicExpr (ENum _) = True
isAtomicExpr _        = False

isApp :: Expr t -> Bool
isApp (EAp _ _) = True
isApp _         = False

isCompound :: Expr t -> Bool
isCompound (ENum _)      = False
isCompound (EVar _)      = False
isCompound (EConstr _ _) = False
isCompound _             = True

reservedOps = [ "=", ",", ";","->","<-", "\\", "."]
keywords    = [ "let", "letrec", "case", "in", "of", "Pack" ]
relOps      = ["<", ">", "==", "~=", ">=","<="]
arithOps    = [ "+","-","*","/"]
bitOps      = ["&","|"]

{- === Core Standard Prelude ===
   I x           = x
   K x y         = x
   K1 x y        = y
   S f g x       = f x (g x)
   compose f g x = f (g x)
   twice f       = compose f f
 -}
preludeDefs :: CoreProgram
preludeDefs
  = [ ("I", ["x"], EVar "x")
    , ("K", ["x","y"], EVar "x")
    , ("K1",["x","y"], EVar "y")
    , ("S", ["f","g","x"], EAp (EAp (EVar "f") (EVar "x"))
                               (EAp (EVar "g") (EVar "x")))
    , ("compose", ["f","g","x"], EAp (EVar "f")
                                     (EAp (EVar "g") (EVar "x")))
    , ("twice", ["f"], EAp (EAp (EVar "compose") (EVar "f")) (EVar "f"))
    ]

{-
  not x   = if x False True
  or x y  = if x True y
  xor x y = if x (not y) y
-}
extraPreludeDefs :: CoreProgram
extraPreludeDefs
  = [ ("False", [], EConstr 1 0)
    , ("True",  [], EConstr 2 0)
    , ("not",   ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
                                 (EVar "False"))
                            (EVar "True"))
    , ("and",   ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
                                      (EVar "y"))
                               (EVar "False"))
    , ("or",    ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
                                      (EVar "True"))
                                  (EVar "y"))
    , ("xor",   ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
                                      (EAp (EVar "not") (EVar "y")))
                                 (EVar "y"))
    , ("MkPair", [], EConstr 1 2)
    , ("fst",    ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
                              (EVar "K"))
    , ("snd",    ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
                            (EVar "K1"))
    , ("LCons",  [], EConstr 2 2)
    , ("Nil",    [], EConstr 1 0)
    , ("head",   ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
                                    (EVar "abort"))
                               (EVar "K"))
    , ("tail",   ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
                                    (EVar "abort"))
                               (EVar "K1"))
    ]
#+end_src

** Pretty Printer

#+begin_src haskell
  -- The general idea of "Iseq" is to postpone all work until the eventual
  -- call of "iDisplay", which converts "Iseq" into a string.
  
  data Iseq = INil
            | IStr String
            | IAppend Iseq Iseq
            | IIndent Iseq
            | INewline

  iNil :: Iseq
  iNil = INil
  
  iStr :: String -> Iseq
  iStr str = IStr str
  
  iAppend :: Iseq -> Iseq -> Iseq
  iAppend seq1 seq2 = IAppend seq1 seq2
  
  iIndent :: Iseq -> Iseq
  iIndent seq = IIdent seq
  
  iNewline :: Iseq
  iNewline = INewline
  
  iDisplay :: Iseq -> String
  iDisplay seq = flatten 0 [(seq, 0)]
  
  isSpace = iStr " "
  
  iConcat = foldr iAppend iNil
  
  iInterleave sep []         = iNil
  iInterleave sep [seq]      = seq
  iInterleave sep (seq:seqs) = seq `iAppend` (sep `iAppend` iInterleave sep seqs)

  -- Constructing "Iseq"
  
  pprProgram prog = iInterleave (iAppend (iStr " ;") iNewline) (map pprSc prog)

  pprSc (name, args, body)
    = iConcat [ iStr name, iSpace, pprArgs args,
                iStr " = ", iIndent (pprExpr body) ]
  
  pprExpr :: CoreExpr -> Iseq
  pprExpr (ENum n) = iNum n
  pprExpr (EVar v) = iStr v
  pprExpr (EAp (EAp (EVar "+")  e1) e2) = iConcat [pprAExpr e1, iStr " + ",  pprAExpr e2]
  pprExpr (EAp (EAp (EVar "-")  e1) e2) = iConcat [pprAExpr e1, iStr " - ",  pprAExpr e2]
  pprExpr (EAp (EAp (EVar "*")  e1) e2) = iConcat [pprAExpr e1, iStr " * ",  pprAExpr e2]
  pprExpr (EAp (EAp (EVar "/")  e1) e2) = iConcat [pprAExpr e1, iStr " / ",  pprAExpr e2]
  pprExpr (EAp (EAp (EVar "<")  e1) e2) = iConcat [pprAExpr e1, iStr " < ",  pprAExpr e2]
  pprExpr (EAp (EAp (EVar "<=") e1) e2) = iConcat [pprAExpr e1, iStr " <= ", pprAExpr e2]
  pprExpr (EAp (EAp (EVar "==") e1) e2) = iConcat [pprAExpr e1, iStr " == ", pprAExpr e2]
  pprExpr (EAp (EAp (EVar "~=") e1) e2) = iConcat [pprAExpr e1, iStr " ~= ", pprAExpr e2]
  pprExpr (EAp (EAp (EVar ">=") e1) e2) = iConcat [pprAExpr e1, iStr " >= ", pprAExpr e2]
  pprExpr (EAp (EAp (EVar ">")  e1) e2) = iConcat [pprAExpr e1, iStr " > ",  pprAExpr e2]
  pprExpr (EAp (EAp (EVar "&")  e1) e2) = iConcat [pprAExpr e1, iStr " & ",  pprAExpr e2]
  pprExpr (EAp (EAp (EVar "|")  e1) e2) = iConcat [pprAExpr e1, iStr " | ",  pprAExpr e2]
  pprExpr (EAp e1 e2)                   = iConcat [ pprExpr e1, iSpace,      pprAExpr e2]
  
  pprExpr (ELet isrec defns expr)
    = iConcat [ iStr keyword, iNewline,
                iStr " ", iIndent (pprDefns defns), iNewline,
                iStr "in ", pprExpr expr ]
       where
       keyword | not isrec = "let"
               | isrec = "letrec"
  
  pprExpr (ECase e alts)
    = iConcat [ iStr "case ", pprExpr e, iStr " of", iNewline,
                iStr " ", iIndent (iInterleave iNl (map pprAlt alts)) ]
      where
      iNl = iConcat [ iStr ";", iNewline ]
      pprAlt (tag, args, rhs)
        = iConcat [ iStr "<", iNum tag, iStr "> ",
                    pprArgs args, iStr " -> ",
                    iIndent (pprExpr rhs) ]
  
  pprExpr (ELam args body)
    = iConcat [ iStr "(\\", pprArgs args, iStr ". ", iIndent (pprExpr body),
                iStr ")"]
  
  pprArgs args = iInterleave iSpace (map iStr args)
  
  pprAExpr e | isAtomic Expr e = pprExpr e
  pprAExpr e | otherwise = iConcat [iStr "(", pprExpr e, iStr ")"]

  -- Layout and Indentation
  
  flatten :: Int -> [(Iseq, Int)] -> String
  flatten col [] = ""
  
  flatten col ((IAppend seq 1 seq 2, indent) : seqs)
    = flatten col ((seq1, indent) : (seq2, indent) : seqs)
  
  flatten col ((INil, indent) :  seqs) = flatten col seqs
  
  flatten col ((IStr s, indent): seqs)
    = s ++ flatten (col + length s) seqs
  
  flatten col ((IIndent seq, indent) : seqs)
    = flatten col ((seq, col) : seqs)
  
  flatten col ((INewLine, indent) : seqs)
    = '\n' : (space indent) ++ (flatten indent seqs)

  iNum :: Int -> Iseq
  iNum n = iStr (show n)

  iFWNum :: Int -> Int -> Iseq
  iFWNum width n
    = iStr (space (width - length digits) ++ digits)
      where
      digits = show n

  iLayn :: [Iseq] -> Iseq
  iLayn seqs = iConcat (map lay_item (zip [1..] seqs))
               where
               lay_item (n, seq)
                 = iConcat [iFWNum 4 n, iStr ") ", iIndent seq, iNewline]
#+end_src

** Lexer and Parser

#+begin_src haskell
  parse :: String -> CoreProgram
  parse = syntax . clex
  
  -- lexical analysis

  type Token = String
  
  clex :: String -> [Token]
  -- discard leading whitespace
  clex (c:cs) | isWhiteSpace c = clex cs

  -- decimal digits
  clex (c:cs) | isDigit c = num_token : clex rest_cs
                where
                num_token = c : takeWhile isDigit cs
                rest_cs = dropWhile isDigit cs

  -- identifiers
  clex (c:cs) | isAlpha c = var_token : clex rest_cs
                where
                var_token = c : takeWhile isIdChar cs
                rest cs = dropWhile isIdChar cs

  -- comments
  clex ('|':'|':cs) = clex (dropWhile (/= '\n') cs)

  -- two-character operators
  clex (c1:c2:c3) | ([c1, c2] `elem` twoCharOps) = [c1, c2] : clex cs

  -- other
  clex (c:cs) = [c] : clex cs

  -- empty
  clex [] = []

  isIdChar, isWhiteSpace :: Char -> Bool
  isIdChar c = isAlpha c || isDigit c || (c == '_')
  isWhiteSpace c = c `elem` " \t\n"

  twoCharOps :: [String]
  twoCharOps = ["==", "~=", ">=", "<=", "->"]

  -- Parser
  
  type Parser a = [Token] -> [(a, [Token])]

  pSat :: (String, Bool) -> Parser String
  pSat pred [] = []
  pSat pred (token:tokens) | pred tok = [(token, tokens)]
                           | otherwise = []
  pLit s = pSat (== s)

  pVar = pSat isVar
         where
         isVar s = isAlpha (head s) && s `notElem` keywords

  keywords :: [String]
  keywords = ["let", "letrec", "case", "in", "of", "Pack"]
  
  pNum = pSat (isDigit . head) `pApply` numvalue

  numvalue :: String -> Int
  numvalue = foldl1 (\a c -> 10 * a + ord c - ord '0') 0
  
  -- choices
  pAlt :: Parser a -> Parser a -> Parser a
  pAlt p1 p2 tokens = (p1 tokens) ++ (p2 tokens)

  -- sequences
  pThen :: (a -> b -> c) Parser a -> Parser b -> Parser c
  pThen combine p1 p2 tokens
    = [(combine v1 v2, tokens2) | (v1, tokens1) <- p1 tokens,
                                  (v2, tokens2) <- p2 tokens1]

  pThen3 :: (a -> b -> c -> d) -> Parser a -> Parser b -> Parser c -> Parser d
  pThen3 combine p1 p2 p3 tokens
    = [(combine v1, v2, v3, tokens3) | (v1, tokens1) <- p1 tokens,
                                       (v2, tokens2) <- p2 tokens1,
                                       (v3, tokens3) <- p3 tokens2]

  pThen4 :: (a -> b -> c -> d) -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e
  pThen4 combine p1 p2 p3 p4 tokens
    = [(combine v1, v2, v3, v4, tokens4) | (v1, tokens1) <- p1 tokens,
                                           (v2, tokens2) <- p2 tokens1,
                                           (v3, tokens3) <- p3 tokens2,
                                           (v4, tokens4) <- p4 tokens3]

  pOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]
  pOneOrMoreWithSep p sep = pThen (:) p (pOneOrMoreWithSep_c p sep)
  pOneOrMoreWithSep_c p psep
    = (pThen discard_sep psep (pOneOrMoreWithSep p psep)) `pAlt` (pEmpty [])
      where
      discard_sep sep vs = vs
  
  pEmpty :: a -> Parser a
  pEmpty v tokens = [(v, tokens)]

  pOneOrMore :: Parser a -> Parser [a]
  pOneOrMore p = pThen (:) p (pZeroOrMore p)

  pZeroOrMore :: Parser a -> Parser [a]
  pZeroOrMore p = (pOneOrMore p) `pAlt` (pEmpty [])

  -- mapping
  pApply :: Parser a -> (a -> b) -> Parser b
  pApply p f tokens [(f v, tokens') | (v, tokens') <- p tokens]
  
  syntax :: [Token] -> CoreProgram
  syntax = take_first_parse . pProgram
         where
         take_first_parse ((prog, []) : others) = prog
         take_first_parse (parse      : others) = take_first_parse others
         take_first_parse other                 = error "Syntax error"

  pProgram :: Parser CoreProgram
  pProgram = pOneOrMoreWithSep pSc (pLit ";")

  pSc :: Parser CoreScDefn
  pSc = pThen4 mk_sc pVar (pZeroOrMore pVar) (pLit "=") pExpr

  mk_sc sc args eq rhs = (sc, args, rhs)

  pExpr = pLet `pAlt` (pCase `pAlt` (pLambda `pAlt` pExpr1))

  pLet = pThen4 mk_let
                ((pLit "let") `pAlt` (pLit "letrec")) pDefns
                (pLit "in") pExpr
         where
         mk_let keyword defns in' expr = Elet (keyword == "letrec") defns expr

  pDefns = pOneOrMoreWithSep pDefn (pLit ";")
  pDefn = pThen3 mk_defn pVar (pLit "=") pExpr
          where
          mkdefn var equals rhs = (var, rhs)

  pCase = pThen4 mk_case (pLit "case") pExpr (pLit "of") pAlters
          where
          mk_case case' e of' alts = ECase e alts

  pAlters = pOneOrMoreWithSep pAlter (pLit ";")
  pAlter = pThen4 mk_alt pTag (pZeroOrMore pVar) (pLit "->") pExpr
           where
           mk_alt tag args arrow rhs = (tag, args, rhs)

  pTag = pThen3 get_tag (pLit "<") pNum (pLit ">")
         where
         get_tag lb tag rb = tag

  pLambda = pThen4 mk_lam
                (pLit "\\") (pOneOrMore pVar) (pLit ".") pExpr
            where
            mk_lam lam vars dot expr = ELam vars expr

  data PartialExpr = NoOp | FoundOp Name CoreExpr

  pExpr1 :: Parser CoreExpr
  pExpr1 = pThen assembleOp pExpr2 pExpr1c
  
  pExpr1c :: Parser PartialExpr
  pExpr1c = (pThen FoundOp (pLit "|") pExpr1) `pAlt` (pEmpty NoOp)

  assembleOp :: CoreExpr -> PartialExpr -> CoreExpr
  assembleOp e1 NoOp = e1
  assembleOp e1 (FoundOp op e2) = EAp (EAp (EVar op) e1) e2
  
  pExpr2 = pThen assembleOp pExpr4 pExpr3c
  pExpr2c = (pThen FoundOp pRelop pExpr4) `pAlt` (pEmpty NoOp)

  pRelop = pSat (`elem` relops)
           where
           relops = ["<=", "<", ">=", ">", "==", "~="]

  pExpr4 = pThen assembleOp pExpr5 pExpr4c
  pExpr4c = (pThen FoundOp (pLit "+") pExpr4) `pAlt`
            ((pThen FoundOp (pLit "-") pExpr5  `pAlt`
              pEmpty NoOp))

  pExpr5 = pThen assembleOp pExpr6 pExpr5c
  pExpr5c = (pThen FoundOp (pLit "*") pExpr5) `pAlt`
            ((pThen FoundOp (pLit "/") pExpr6) `pAlt`
             (pEmpty NoOp))

  pExpr6 = (pOneOrMore pAtomic) `pApply` mk_ap_chain
           where
           mk_ap_chain (fn:args) = foldl1 EAp fn args

  pAtomic = pConstr `pAlt`
            (pBracExpr `pAlt`
            ((pVar `pApply` EVar) `pAlt`
            ((pNum `pApply` ENum))))

  pBracExpr = pThen3 mk_brack (pLit "(") pExpr (pLit ")")
              where
              mk_brack open expr close = expr

  pConstr = pThen4 pick_constr (pLit "Cons") (pLit "{") pTagArity (pLit "}")
            where
            pick_constr cons lbrack constr rbrack = constr
            pTagArity = pThen3 mk_constr pNum (pLit ",") pNum
            mk_constr tag comma arity = Econstr tag arity
#+end_src
