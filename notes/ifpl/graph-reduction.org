* Graph Reduction

** Sources

| source                                                   | author                |
|----------------------------------------------------------+-----------------------|
| *The Implementation of Functional Programming Languages* | Simon L. Peyton Jones |

** Abstract Syntax Trees

In all implementations of graph reduction, the expression to be evaluated is held
in memory in the machine form of its syntax tree.

The leaves of the tree are constant values (such as ~0~, ~'a'~, ~TRUE~), built-in
functions (such as ~+~, ~-~, ~*~), or variable names. The ~@~ sign is called the
tag of the node, which indicates function application.

#+begin_example
  === expression ===
  (+ 7 (* 7 11))

  === syntax tree ===
        @
     /     \
    @       @
   / \     / \
  +   7   @   11
         / \
        *   7

  === expression ===
  (CONS E1 E2)

  === syntax tree ===
        @
       / \
      @   E2
     / \
  CONS  E1

  === CONS Cell ===
    :
   / \
  E1 E2

  === expression ===
  λx.+ x 1

  === syntax tree ===
      λx
      |
      @
     / \
    @   1
   / \
  +   x
#+end_example

** The Graph

The process of reduction performs successive transformations on the syntax tree. During
this process the *tree* becomes a *graph*. The term *graph* here meaning a network
of nodes connected together by *directed edges*. A graph differs from a tree in that
two edges can point to the same node.

*** Concrete Representations

#+begin_example
  Node Type   | Abstract Node | Concrete Cell
  ------------+---------------+-----------------
              |               | +---+---+---+
  application |   @           | | @ |   |   |
              |  / \          | +---+-|-+-|-+
              | f   x         |       V   V
              |               |       f   x
  ------------+---------------+-----------------
              |               | +---+-----+---+
  lambda      |   λx          | | λ | "x" |   |
  abstraction |   |           | +---+-----+-|-+
              |  body         |             V
              |               |            body
  ------------+---------------+-----------------
              |               | +---+---+---+
  CONS cell   |   :           | | : |   |   |
              |  / \          | +---+-|-+-|-+
              | x   y         |       V   V
              |               |       x   y
  ------------+---------------+-----------------
              |               | +---+---+---+
  number      | 7             | | N | 7 |   |
              |               | +---+---+---+
  ------------+---------------+-----------------
              |               | +---+---+---+
  built-in    | +             | | P | + |   |
  function    |               | +---+---+---+
              |               |   ^
              |               |   +- cell tag
#+end_example

In a typical implementation each node of the tree would be represented by a small
contiguous area of store, called a cell. A cell holds a *tag* — which describes
the type of the cell — and two or more fields.

#+begin_example
  === variable-sized cell ===
  +-----+---------+-----+---------+
  | tag | field 1 | ... | field n |
  +-----+---------+-----+---------+

  === fixed-sized cell ===
  +-----+---------+---+
  | tag | field 1 |   |
  +-----+---------+-|-+
     +--------------+
     V
  +-----+---------+---+
  | tag | field 1 |   |
  +-----+---------+-|-+
                   ...
                    |
     +--------------+
     V
  +-----+-------------+---------+
  | tag | field n - 1 | field n |
  +-----+-------------+---------+

      where field = pointer -> another cell
         or field = data
#+end_example

*** Boxed and Unboxed Objects

- unboxed :: Data objects described by a single field — integers, booleans, characters,
  and built-in operators. Any field that may contain a pointer may also contain an
  unboxed object. These fields must be distinguished by a pointer-bit.

- boxed :: Data objects described by one or more cells. The tag of a cell completely
  determines which fields of the cell are pointers and which are not.

#+begin_example
  === expression ===
  (+ 7 11)

  === boxed ===
  +------------+     +-----------+
  | @ | ptr |  | --> | N | 11 |  |
  +------------+     +-----------+
         |
    +----+
    V
  +------------+     +----------+
  | @ | ptr |  | --> | N | 7 |  |
  +------------+     +----------+
         |
    +----+        Tags: @ application
    V                   P built-in
  +----------+          N number
  | P | + |  |
  +----------+

  === unboxed ===
  +--------------+
  | @ | ptr | 11 |
  +--------------+
         |
    +----+
    V
  +-----------+
  | @ | + | 7 |
  +-----------+

  --- unboxed: pointer field ---

  +---+----------+
  | 1 | address -|->
  +---+----------+
    ^
    +- pointer bit

  --- unboxed: non-pointer field ---

  +---+------+
  | 0 | data |
  +---+------+
#+end_example

*** Storage Management and Garbage Collection

Cells are abstracted from an area of storage called the *heap*, which is simply an
unordered collection of cells. The term heap emphasizes that the physical adjacency
of two cells is purely coincidental. What matters is which cell points to which.

Graph reduction allocates and discards cells, or rather discards pointers to cells.
A cell can be reused once there are no more pointers pointing to it. Cells with no
pointers are said to be *garbage*. A garbage collector automatically identifies and
recycles garbage cells.

** Lazy Evaluation

- lazy evaluation :: An implementation strategy of lazy graph reduction.

   - Normal order evaluation to weak head normal form.

   - Pointer substitution.

   - Overwriting the root of the redex with its result.

In most imperative languages, arguments to a function are evaluated before the function
is called — *call by value*. The inverse of this is *call by need*. In the context of
functional languages, *call by need* is often called *lazy evaluation*, since it
postpones work until it becomes unavoidable. Conversely, *call by value* is often
called *eager evaluation*.

*Call by need* is rarely implemented in imperative languages for two main reasons:

1. The evaluation of an argument my cause side-effects in other parts of the program.
   The exact time in which an argument is evaluated is crucial to the correct
   behavior of a program.

2. It is hard to implement in a stack-based implementation.

*** Normal Order Reduction

Any implementation of *lazy evaluation* has two ingredients:

1. Arguments to functions should be evaluated only when their value is needed, not
   when the function is applied.

2. Arguments should only be evaluated once, and, if possible, not at all.

The first ingredient is directly implemented using normal order reduction, where the
outermost, leftmost redex is reduced first.

#+begin_example
  === Strict and Non-Strict Evaluation ===

  non-strict evaluation -> 7
  strict evaluation     -> non-terminating

  (λx.7) <infinity>

  === Weak Head Normal Form ===

  A lambda expression is in weak head normal form if and only if it is of the form

      F E₁ E₂ ... Eₓ

  where x ≥ 0
  and   either F is a variable or data object
        or F is a lambda abstraction or built-in function
           and (F E₁ E₂ ... Eₑ) is not a redex or any e ≥ x.

  An expression has no top-level redex if and only if it is in weak head normal form.

  === Head Normal Form ===

  A lambda expression is in head normal form if and only if it is of the form

      λx₁.λx₂...λxₓ.(v E₁ E₂ ... Eₑ)

  where x, e ≥ 0
        v is a variable (xₓ), data object, or built-in function
  and   (v E₁ E₂ ... Eₐ) is not a redex for any a ≥ e

  === Normal Order Reduction ===

  original expression
      |
      | normal order reductions
      | of top-level redexes
      |
      V
  weak head normal form (no top-level redexes)
      |
      | normal order reductions
      | of inner redexes
      |
      V
  normal form (no redexes at all)
#+end_example

*** Pointer Substitution

To avoid copying large expressions and duplicating redexes, substitute
pointers to an argument when overwriting a formal parameter.

- sharing :: One or more pointers to the same expression, wherein
  an expression tree becomes a graph.

#+begin_example
  === Tree to Graph Reduction ====

  (λx.AND x x) (NOT TRUE) - reduces -> AND (NOT TRUE) (NOT TRUE)

       +-- @ --+                             @
       |       |                            / \
      λx       @                           @   \
       |      / \                         / \   \
       @   NOT   TRUE                   AND  +-- @
      / \                                       / \
     @   x                                   NOT   TRUE
    / \
  AND  x
#+end_example

*** Overwriting the Root of the Redex

#+begin_example
  AND (NOT TRUE) (NOT TRUE) - reduces -> AND FALSE FALSE

       @                                      @
      / \                                    / \
     @   \                                  @   \
    / \   \                                / \   \
  AND  +-- @ <- root                     AND  +-- FALSE <- root
          / \
       NOT   TRUE                             NOT   TRUE
                                               ^--+--^
                                                  |
                                              If unreachable, reclaim with
                                              garbage collector.
#+end_example

*** Constructing the Lambda Body

Lambda abstractions must remain intact in case they are shared
amongst multiple expressions.

#+begin_example
        @ <- root                         @ <- root
       / \                               / \
     λx  TRUE  - reduces ->  λx <-+   NOT   TRUE
      |                       |   |
      @                       @   +- original abstraction
     / \                     / \
  NOT   x                 NOT   x
#+end_example

** Built-In Function Application

#+begin_example
  (+ 7 (* 11 2)) -> (+ 7 22) -> 29

       @ <- root
     /   \
    @     @
   / \   / \
  +   7 @   2
       / \
      *   11

  - reduces ->

       @ <- root
     /   \
    @     22
   / \
  +   7 @   2
       / \
      *   11

  - reduces ->

       29 <- root

    @     22
   / \
  +   7 @   2
       / \
      *   11
#+end_example

*** Implementing Y

#+begin_example
  Y f -> f (Y f)

  1. Acyclic

       @ <- root    @ <- root
      / \          / \
     Y   f        f   @
                     / \
                    Y   f

  2. Cyclic (cyclic or knot-tying Y)

                    +----------+
                    V          |
       @ <- root    @ <- root  |
      / \          / \         |
     Y   f        f   +--------+
#+end_example

** Reduction Algorithm So Far

1. Unwind the spine until something other than an application node is encountered.

2. Examine the objects found at the tip of the spine.

   - A Data Object :: Check that it is not applied to anything. If not, the expression
     is in *weak head normal form* so STOP. Otherwise there is an ERROR.

   - A Built-In Function :: Check the number of arguments available. If there are too
     few arguments, the expression is in WHNF so STOP. Otherwise evaluate any arguments
     required, execute the built-in function and overwrite the root of the redex with
     the result.

   - A Lambda Abstraction :: Check that there is an argument. If not, the expression is
     in WHNF so STOP. Otherwise instantiate the body of the lambda abstraction, substituting
     pointers to the arguments for the formal parameters, and overwrite the root of the
     redex with the result.

#+begin_example
  === The Spine ===

              +- spine / graph (heap storage)
  base        |
  +---+       V   +
  | ◍-|-----> @   |
  |---|      / \  |
  | ◍-|---> @   Y | unwinding the spine
  |---|    / \    |
  | ◍-|-> f   X   |
  +---+   ^   ^   V
  top     |   |
   ^     tip  +- rib
   |
   +- pointer stack
#+end_example
