* The Lambda Calculus

** Lambda Expression Syntax

For this particular lambda calculus:

- Lower case names denote variables: (*x*, *y*).

- Single, upper-case letters denote whole lambda expressions: (*M*, *E*).

- Symbols and upper-case identifiers denote built-in functions: (*AND*, *IF*, *+*, *CONS*).

#+begin_example
  <expression> ::= <constant>               Built-in constant
               |   <variable>               Variable name
               |   <expression><expression> Application
               |   λ<variable>.<expression> Lambda abstraction
#+end_example

As opposed to the pure lambda calculus, an applied lambda calculus — such as the
one in this book — can be extended with primitive constants and operations:

1. arithmetic functions: (*+*, *-*, *\times{}*, */*)

2. constants: ((*0*, *1*, *2* ...), (*TRUE*, *FALSE*), ('*a*', '*b*', '*c*' ...), (*NIL*))

3. logical functions: (*AND*, *OR*, *NOT*, *IF*)

4. data constructors: (*CONS*, *HEAD*, *TAIL*)

** Lambda Abstraction

#+begin_example
  λx.+ x 7

  -- reads ->

  λ                x  .    +   x    7
  ^                ^  ^    ^   ^    ^
  |                |  |    |   |    |
  That function of x that adds x to 7
#+end_example

The body of a lambda abstraction extends as far to the right as possible:
*λx.M N* implies *λx.(M E)*, not *(λx.M) E*.

** Bound and Free Variables

The operator *λ* binds its variable wherever it occurs in the body of the abstraction.
Variables that fall within the scope of an abstraction is *bound*. All other variables
are free.

- The set of free variables of a lambda expression *M* is denoted as *FV(M)*:

  1. *FV(x) = {x}*, where *x* is a variable.

  2. *FV(λx.M) = FV(M) \ {x}*

  3. *FV(M N) = FV(M) ∪ FV(N)*

#+begin_example
       +-- bound
  λx.+ x y
         +-- free

             +-- bound
  + x ((λx.+ x 7) 4)
    +-- free
#+end_example

** β-Conversion (Beta)

*(λx.M) E ⟷ M[E/x]*

Denotes relation between function abstraction and application.

** α-Conversion (Alpha)

*λx.M[x] ⟷ λy.M[y]*

Prevents name clashes of formal parameters within lambda abstractions through
consistent renaming.

** η-Conversion (Eta)

*λx.M x ⟷ M* where *x ∉ FV(M)* and *M* denotes a function.

Eliminates redundant lambda abstractions.

** The Name-Capture Problem

β-reduction is only valid provided the free variables of the argument do not clash
with any formal parameters in the body of the lambda abstraction. α-Conversion is
sometimes necessary to avoid this.

** Denotational Semantics of The Lambda Calculus (Simplified)

#+begin_example
Eval[k] p      = difference between syntactic abstraction
		 and equational operations. Allow precision that
		 is hard to achieve using only reduction rules.
Eval[x] p      = p x
Eval[E1, E2] p = (Eval[E1] p) (Eval[E2] p)
Eval[λx.E] p a = Eval[E] p[x=a]

    where k          is a constant or built-in function
	  x          is a variable
	  E, E1, E2  are expressions
	  p          is the environment
#+end_example

* The Enriched Lambda Calculus

This enriched lambda calculus is specific to
*The Implementation of Functional Programming Languages*
  
#+begin_example
<exp> ::= <constant>
      |   <variable>
      |   <exp><exp>
      |   λ<pattern>.<exp>
      |   let <pattern> = <exp> in <exp>
      |   letrec <pattern> = <exp>
		 ...
		 <pattern> = <exp>
	  in <exp>
      |   <exp> ▯ <exp>
      |   case <variable> of
	  <pattern> -> <exp>
	  ...
	  <pattern> -> <exp>

<pattern> ::= <constant>
	  |   <variable>
	  |   <constructor><pattern>
			   ...
			   <pattern>

 ▯ is an infix operator for handling pattern match errors:

 a    ▯ b = a
 FAIL ▯ b = b
 ⊥    ▯ b = ⊥

 hd (x:xs) = x
 hd = λxs'.(((λ(CONS x xs).x) xs') ▯ ERROR)

 if hd is applied to NIL, then an ERROR will result.
 #+end_example

** *let* Semantics

   #+begin_example
   (let v = B in E) ≡ ((λv.E) B)
   #+end_example

** *letrec* Semantics

#+begin_example
(letrec v = B in E) ≡ (let v = Y (λv.B) in E)
    where Y = (λh.(λx.h (x x)) (λx.h (x x)))
#+end_example

** Example Translation

#+begin_example
-- definition
average a b = (a + b) / 2

-- expression
average 2 (3 + 5)

-- enriched lambda calculus
let
  average = λa.λb.(/ (+ a b) 2)
in
  average 2 (+ 3 5)

-- plain lambda calculus
(λaverage.(average 2 (+ 3 5))) (λa.λb.(/ (+ a b) 2))
#+end_example
