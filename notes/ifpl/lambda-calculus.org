* The Lambda Calculus

** Sources

| source                                                   | author                              |
|----------------------------------------------------------+-------------------------------------|
| *The Implementation of Functional Programming Languages* | Simon L. Peyton Jones               |
| *The Lambda Calculus*                                    | Stanford Encyclopedia of Philosophy |
| *Church's Thesis and Functional Programming*             | David Turner                        |

** Expression Syntax and Notational Conventions

For this particular lambda calculus:

- Lower case names denote variables: (*x*, *y*, ...).

- Single, upper-case letters denote whole lambda expressions: (*M*, *E*, ...).

- Symbols and upper-case identifiers denote built-in functions: (*AND*, *IF*, *+*, *CONS*, ...).

#+begin_example
  <expression> ::= <constant>               # Built-in constant
               |   <variable>               # Variable name
               |   <expression><expression> # Application
               |   λ<variable>.<expression> # Lambda abstraction
#+end_example

As opposed to the pure lambda calculus, an applied lambda calculus is extended
with primitive constants and operations:

1. arithmetic functions: (*+*, *-*, *\star{}*, */*)

2. constants: ((*0*, *1*, *2* ...), (*TRUE*, *FALSE*), ('*a*', '*b*', '*c*' ...), (*NIL*))

3. logical functions: (*AND*, *OR*, *NOT*, *IF*)

4. data constructors: (*CONS*, *HEAD*, *TAIL*)

#+begin_example
  === abstraction ===

  λx.+ x 7

  λ                x  .    +   x    7
  ^                ^  ^    ^   ^    ^
  |                |  |    |   |    |
  That function of x that adds x to 7

  # The scope of an abstraction, λ, extends
  # as far to the right as possible — delimited
  # only by brackets.

  λx.+ x 7 = (λx.+ x 7), not (λx.+) x 7 or (λx.+ x) 7

  === application ===

  # Arity 1, left associative.

  + x 7 → ((+ x) 7)
#+end_example

** Bound and Free Variables

The operator *λ* binds its variable wherever it occurs in the body of the abstraction.
Variables that fall within the scope of an abstraction are *bound*. All other variables
are *free*.

| free                    | bound                   |
|-------------------------+-------------------------|
| FV(x) = {x}             | BV(x) = ∅               |
| FV(M N) = FV(M) ∪ FV(N) | BV(M N) = BV(M) ∪ BV(N) |
| FV(λx[M]) = FV(M) \ {x} | BV(λx[M]) = BV(M) ∪ {x} |

#+begin_example
       +-- bound
  λx.+ x y
         +-- free

             +-- bound
  + x ((λx.+ x 7) 4)
    +-- free


  === scope ===

  # "x" is bound in "λx" but free in "E"

  λx.E

       +-- bound in abstraction
  λx.+ x

       +-- free in body
    (+ x)

  # The inner "x" is not substituted for in the first reduction,
  # since it is not free in the body of the outer "λx" abstraction.

    (λx.(λx.+ (- x 1)) x 2) 3

  ⇒ (λx.+ (- x 1)) 3 2

  ⇒ (+ (- 3 1) 2)

  ⇒ 4
#+end_example

#+begin_quote
  "The result of applying a lambda abstraction to an argument is an
   instance of the body of the lambda abstraction in which free
   occurrences of the formal parameter in the body are replaced with
   copies of the argument."

  — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

** Conversion Rules

- λ-conversion :: Written *⇔*, the smallest reflexive, symmetric, transitive, and substitutive
  relation on terms *→α*, *→β* and *→η*.

  - reflexive :: ∀x ∈ X : xRx, where xRx is infix notation for (x, x) ∈ R.

  - symmetric :: ∀x∀y ∈ X : xRy → yRx, where xRy is infix notation for (x, y) ∈ R.

  - transitive :: ∀x∀y∀z ∈ X : (xRy ∧ yRx) → xRz, where xRy is infix notation for (x, y) ∈ R.

- λ-reduction :: Written *⇒*, omits the symmetry of the previous definition for an oriented relation.

- β-conversion (Beta) :: *(λx.M) E ⇔ M[E/x]*

  - Denotes the substitutive relation between function abstraction and application.

  - The reductive expression *(λx.M) E ⇒ M[E/x]* reads, "Substitute expression *E*
    for all *free* occurrences of variable *x* in expression *M*".

- α-conversion (Alpha) :: *(λx.M) ⇔ λy.M[y/x]*, where *y ∉ FV(M)*

  - β-reduction is valid provided the free variables of an argument do not
    clash with any formal parameters in the body of the lambda abstraction.
    α-conversion renames bound variables to prevent variable name capture.

- η-conversion (Eta) :: *λx.M x ⇔ M* where *x ∉ FV(M)* and *M* denotes a function.

  - Eliminates redundant lambda abstractions.

- δ-conversion :: Rules of conversion for built-in functions — each rule specific
  to its particular function.

** Reduction

- redex :: Called a *reducible expression*, it is the left-hand side of rule β or η.

- reduct :: A term to which a redex reduces. *M[N/x]* is the reduct of *(λx.M) N*

- normal form :: A term that contains no redex.

- normalizing :: A term that can be converted to normal form.

- non-normalizing :: A term that *cannot* be converted to normal form,
  such as *(λx.xx)(λx.xx) →β (λx.xx)(λx.xx)*.

- Church-Rosser Theorem 1 :: If *E_{1} ⇔ E_{2}*, then there exists an expression *E*,
  such that *E_{1} ⇒ E* and *E_{2} ⇒ E*.

  - *corrollary*: No expression can be converted into two distinct normal forms.
    Normal forms must be α-convertible. All reduction sequences that terminate
    will reach the same result.

  - *proof*: Suppose that *E ⇔ E_{1}* and *E ⇔ E_{2}*, where *E_{1}* and *E_{2}* are in
    normal form. Then, *E_{1} ⇔ E_{2}* and, by CRT-1, there must exist an expression
    *F*, such that *E_{1} ⇒ F* and *E_{2} ⇒ F*. But *E_{1}* and *E_{2}* have no redexes,
    so *E_{1} = F = E_{2}*.

- normal order reduction :: The leftmost, outermost redex reduces first.

#+begin_quote
  "[Normal order reduction] embodies the intuition that arguments
   to functions may be discarded..."

   — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

- Church-Rosser Theorem 2 :: If *E_{1} ⇒ E_{2}* is in normal form, then there exists
  a normal order reduction sequence from *E_{1}* to *E_{2}*.

- evaluation :: Successive reductions of redexes until an expression is in normal form.

** Recursion

#+begin_example
  # === Y Combinator ===

  Y := λf.(λx.f (x x)) (λx.f (x x))

  # === fixed point ===

  Y F

  ≡ (λf.(λx.f (x x)) (λx.f (x x))) F

  ≡ (λx.F (x x)) (λx.F (x x))

  ≡ F ((λx.F (x x)) (λx.F (x x)))

  ≡ F (Y F)

  Y F → F (Y F)
#+end_example

** The Enriched Lambda Calculus

#+begin_example
  <expression> ::= <constant>
               |   <variable>
               |   <expression><expression>
               |   λ<pattern>.<expression>
               |   let <pattern> = <expression> in <expression>
               |   letrec <pattern> = <expression>
                          ...
                          <pattern> = <expression>
                   in <expression>
               |   <expression> ▯ <expression>
               |   case <variable> of
                   <pattern> -> <expression>
                   ...
                   <pattern> -> <expression>

  <pattern> ::= <constant>
            |   <variable>
            |   <constructor><pattern>
                             ...
                             <pattern>
#+end_example

** Translations

#+begin_example
  || === Miranda Program ===

  +--------------+
  | definition 1 |
  | definition 2 |
  | ...          |
  | definition x |
  |--------------|
  | expression   |
  +--------------+

  || === TE[expression] = translate expression ===

  TE[ : ]               ≡ CONS

  TE[ [] ]              ≡ NIL

  TE[ [E₁, E₂ ... Eₓ] ] ≡ CONS TE[E₁] TE[ [E₂ ... Eₓ] ]

  TE[ (E₁, E₂) ]        ≡ PAIR TE[E₁] TE[E₂]

  TE[ (E₁, E₂, E₃) ]    ≡ TRIPLE TE[E₁] TE[E₂] TE[E₃]

  TE[True]              ≡ TRUE

  TE[False]             ≡ FALSE

  TE[k]                 ≡ k

  TE[v]                 ≡ v

  TE[E₁ E₂]             ≡ TE[E₁] TE[E₂]

  TE[E₁ infix E₂]       ≡ TE[infix] TE[E₁] TE[E₂]

  TE[E₁ $v E₂]          ≡ TE[v] TE[E₁] TE[E₂]

  TE[E₁ ▯ E₂]           ≡ FATBAR E₁ E₂

      where k      = literal constant or built-in operator
            v      = variable
            Eₓ     = expressions
            infix  = built-in infix operator
            $v     = function as infix operation

  || === TD[definition] = translate definition ===

  TD[p = R] ≡ TE[p] = TR[R]

  || The syntax of patterns is a subset of the syntax of expressions.

    +-                  -+
  TD| f p₁₁ ... p₁ₓ = R₁ | ≡ f = (λv₁ ... λvₓ.( ((λTE[p₁₁] ... λTE[p₁ₓ]. TR[R₁]) v₁ ... vₓ)
    | ...                |                    ▯ ...
    | f pₓ₁ ... pₓₓ = Rₓ |                    ▯ ((λTE[pₓ₁] ... λTE[pₓₓ]. TR[Rₓ]) v₁ ... vₓ)
    +-                  -+                    ▯ ERROR))

    where f   = variable
          vₓ  = new variable bound in Rₓ
          pₓₓ = pattern
          Rₓ  = right-hand side

  || === TR[rhs] = translate right-hand side ===

    +-               -+
  TR|   A₁, G₁        | ≡ letrec TD[D₁]
    | = ...           |          ...
    | = Aₓ, Gₓ        |          TD[Dₓ]
    | where D₁ ... Dₓ |   in
    +-               -+      (IF TE[G₁] TE[A₁]
                              ...
                             (IF TE[Gₓ] TE[Aₓ] FAIL) ...)

  If Gₓ is absent, or True, then the final IF-expression
  should be replaced by TE[Aₓ].

      where Aₓ = expression
            Gₓ = boolean-valued expression
            Dₓ = definition

  || === list comprehensions ===

  flatmap f []     = []
  flatmap f (x:xs) = (f x) ++ (flatmap f xs)

  TE[ [E | v <- L; Q] ] ≡ flatmap (λv.TE[ [E | Q] ]) TE[L]

  TE[ [E | B; Q] ]      ≡ IF TE[B] TE[ [E | Q] ] NIL

  TE[ [E | ] ]          ≡ CONS TE[E] NIL

  where E = expression
        B = boolean expression
        L = list
        Q = qualifiers (zero or more)
        v = variable

  || - optimizations ->

  TE[ [E | Q] ] ≡ TQ[ [E | Q] ++ [] ]

  TQ[ [E | v <- L₁; Q] ++ L₂ ]

  ≡ letrec h = λus. case us of
                   NIL        -> TE[L₂]
                   CONS v us' -> TQ[ [E | Q] ++ (h us') ]
    in (h TE[L₁])

  TQ[ [E | B; Q] ++ L ] ≡ IF TE[B] TQ[ [E | Q] ++ L ] TE[L]

  TQ[ [E | ] ++ L ]     ≡ CONS TE[E] TE[L]

  where h, us, us' = new variables bound in E, L₁, L₂, or Q
#+end_example

** Transformations

*** Variable, Constant, Sum, and Product Expressions

#+begin_quote
  "In the case when the pattern *p* is a variable there is nothing to do,
   because no pattern-matching is involved."

  — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

#+begin_example
  || === constants ===

  (λk.E)             ≡ (λv.IF (= k v) E FAIL)
                       where v = new variable bound in E
                             k = constant

  || === products and sums ===

  (λ(t p₁ ... pₓ).E) ≡ (UNPACK-PRODUCT-t (λp₁ ... λpₓ.E))

  (λ(s p₁ ... pₓ).E) ≡ (UNPACK-SUM-s (λp₁ ... pₓ.E))

  where t = product constructor
        s = sum constructor

  || === UNPACK semantics ===

  UNPACK-PRODUCT-t f v = f (SELECT-t-1 v) ... (SELECT-t-x v)

  UNPACK-SUM-s f (s v₁ ... vₓ)  = f v₁ ... vₓ
  UNPACK-SUM-s f (s' v₁ ... vₓ) = FAIL, if s ≠ s'
  UNPACK-SUM-s f ⊥              = ⊥

  || === constructor functions ===

  s                = PACK-SUM-d-r
  UNPACK-SUM-s     = UNPACK-SUM-d-r

  t                = PACK-PRODUCT-r
  UNPACK-PRODUCT-t = UNPACK-PRODUCT-r
                     where SELECT-t-x = SELECT-r-x

  where s = sum constructor
        d = structure tag
        t = product constructor
        r = constructor arity

  || --- examples ---

  tree ::= LEAF num | BRANCH tree tree

  || - transforms ->

  LEAF              = PACK-SUM-1-1
  BRANCH            = PACK-SUM-2-2
  UNPACK-SUM-LEAF   = UNPACK-SUM-1-1
  UNPACK-SUM-BRANCH = UNPACK-SUM-2-2

  pair * ** ::= PAIR * **

  || - transforms ->

  PAIR                = PACK-PRODUCT-2
  UNPACK-PRODUCT-PAIR = UNPACK-PRODUCT-2
  SELECT-PAIR-1       = SELECT-2-1
  SELECT-PAIR-2       = SELECT-2-2
#+end_example

*** ~let~ and ~letrec~ Expressions

1. The left-hand side of each definition of a *simple* let(rec)-expression
   must be a variable.

2. The left-hand side of each definition of an *irrefutable* let(rec)-expression
   must be an irrefutable pattern.

3. The left-hand side of each definition of a *general* let(rec)-expression may
   be any arbitrary pattern.

There are strong efficiency reasons for including *simple let(rec)-expressions*
in the target language, rather than transforming them into the ordinary lambda calculus.

1. Miranda is a polymorphically-typed language. It is impossible to type-check
   a program once it has been transformed into the ordinary lambda calculus.

2. *let-expressions* can be evaluated much more efficiently than the corresponding
   application of a lambda abstraction.

3. Recursion in the ordinary lambda calculus must be expressed via
   the inefficient *Y-combinator*

#+begin_example
            Dependency Analysis
           +-----------------------------+
           |                             V
          +-------------------------------+
          | general let(rec) expressions  |
          +-------------------------------+
           | Conformality Transformation |
           V                             V
  +-----------------+           +--------------------+
  | irrefutable let |<--------- | irrefutable letrec |
  +-----------------+           +--------------------+
           |                             |
           V                             V
    +------------+                +---------------+
    | simple let |                | simple letrec |
    +------------+                +---------------+
           |
           V
  +-----------------+
  | lambda calculus |
  +-----------------+

  || === simple let -> lambda calculus ===

  let v = B in E ≡ (λv.E) B

  || --- examples ---

  let x = 3
      y = 4
  in (* x y)

  || - transforms ->

  let x = 3
  in let y = 4
     in (* x y)

  || - transforms ->

  λx.λy.(* x y) 3 4

  || === irrefutable let -> simple let ===
  ||
  || Side Note: Variable patterns need not be transformed,
  || because they are already in simple form.

  let (t p₁ ... pₓ) = B in E

  || - equivalent ->

  let v = B
  in let p₁ = SELECT-t-1 v
         ...
         pₓ = SELECT-t-r v
     in E

  where v = new variable bound in E

  || - equivalent ->

  λv.((λp₁...λpₓ.E) (SELECT-t-1 v) ... (SELECT-t-r v)) B

  || === irrefutable letrec -> simple letrec ===

  letrec (t p₁ ... pₓ) = B
         < definitions >
  in E

  || - equivalent ->

  letrec v  = B
         p₁ = SELECT-t-1 v
         ...
         pₓ = SELECT-t-x v
         < definitions >
  in E

  where v = new variable bound in E or B

  || === irrefutable letrec -> irrefutable let ===

  || -- multiple definitions --
  letrec p₁ = B₁
         ...
         pₓ = Bₓ
  in E

  || - equivalent ->

  letrec (t p₁ ... pₓ) = (t B₁ ... Bₓ) in E

  || -- single definition --
  letrec p = B in E

  || - equivalent ->

  let p = Y (λp.B) in E
          where Y = λf.(λx.f (x x)) (λx.f (x x))

  || === refutable let and letrec ===

  let(rec) p = B

  || -- conformality transformation --

  let(rec) (t v₁ ... vₓ) = let v = B
                           in ((λp.(t v₁ ... vₓ)) v) ▯ ERROR

  where {v₁ ... vₓ} = Var(p)
        t           = product constructor
        vₓ          = unique variable

  Var(p)             = {v}, if p = variable
  Var(p)             = {},  if p = constant
  Var((c p₁ ... pₓ)) = Var(p₁) ∪ ... ∪ Var(pₓ)
#+end_example

*** ~case~ Expressions

#+begin_example
  || === product types ==

  case v of
      t v₁ ... vₓ -> E₁

  || - equivalent ->

  let v₁ = SELECT-t-1 v
      ...
      vₓ = SELECT-t-r v
  in E₁

  || === sum types ===

  case v of
      s  v₁₁ ... v₁ₓ -> E₁
      ...
      sₓ vₓ₁ ... vₓₓ -> Eₓ

  || - equivalent ->

  CASE-T v (let v₁₁ = SELECT-SUM-s₁-1 v
                ...
                v₁ₓ = SELECT-SUM-s₁-x v
            in E₁)
           ...
           (let vₓ₁ = SELECT-SUM-sₓ-1 v
                ...
                vₓₓ = SELECT-SUM-sₓ-x v
            in Eₓ)

  || === CASE-T semantics ===

  CASE-T (sₓ a₁ ... aₓ) b₁ ... bₓ ... bₑ = bₓ
  CASE-T ⊥              b₁ ... bₓ ... bₑ = ⊥

      where T = sum constructor type
#+end_example

** Miranda to Lambda Examples

#+begin_example
  || Miranda: average
  average a b = (a + b) / 2

  average 2 (3 + 5)

  || enriched lambda calculus
  let
    average = λa.(λb./ (+ a b) 2)
  in
    average 2 (+ 3 5)

  || plain lambda calculus
  (λaverage.(average 2 (+ 3 5))) λa.(λb./ (+ a b) 2)

  || Miranda: flip
  flip 0 = 1
  flip 1 = 0

  || enriched lambda calculus
  flip = λx.( ((λ0.1) x)
            ▯ ((λ1.0) x)
            ▯ ERROR)

  || - equivalent ->

  flip = λx.( ((λv.IF (= 0 v) 1 FAIL) x)
            ▯ ((λv.IF (= 1 v) 0 FAIL) x)
            ▯ ERROR)

  || Miranda: head
  head (x:xs) = x

  || enriched lambda calculus
  head = λxs'.(((λ(CONS x xs).x) xs') ▯ ERROR)

  || - equivalent ->

  head = λxs'.let (PAIR x xs) = let v = xs'
                                in ((λ(CONS x xs).PAIR x xs) v) ▯ ERROR
              in x

  || - equivalent ->

  head = λxs'.let pair = let v = xs'
                         in ((λ(CONS x xs).PAIR x xs) v) ▯ ERROR
              in let x  = SELECT-PAIR-1 pair
                     xs = SELECT-PAIR-2 pair
                 in x

  || - equivalent ->

  head = λxs'.let pair = let v = xs'
                         in case v of
                            NIL       -> ERROR
                            CONS x xs -> PAIR x xs
              in let x  = SELECT-PAIR-1 pair
                     xs = SELECT-PAIR-2 pair
                 in x

  || - equivalent ->

  head = λxs'.let pair = let v = xs'
                         in CASE-T v (let e = SELECT-SUM-NIL v
                                      in ERROR)
                                     (let x  = SELECT-SUM-CONS-1 v
                                          xs = SELECT-SUM-CONS-2 v
                                      in PAIR x xs)
              in let x  = SELECT-PAIR-1 pair
                     xs = SELECT-PAIR-2 pair
                 in x

  || Miranda: sum
  sum [] = 0
  sum (x:xs) = x + sum xs

  || enriched lambda calculus
  sum = λxs'.( ((λNIL.0) xs')
             ▯ ((λ(CONS x xs).+ x (sum xs)) xs')
             ▯ ERROR)

  || - equivalent ->

  sum = λxs'.case xs' of
             NIL       -> 0
             CONS x xs ->  (+ x (sum xs))

  || Miranda: reflect
  reflect (LEAF n) = LEAF n
  reflect (BRANCH x y) = BRANCH (reflect y) (reflect x)

  || enriched lambda calculus
  reflect = λt.( ((λ(LEAF n).LEAF n) t)
               ▯ ((λ(BRANCH x y).BRANCH (reflect y) (reflect x)) t)
               ▯ ERROR)

  || - equivalent ->

  reflect = λt.( (UNPACK-SUM-LEAF (λn.LEAF n) t)
               ▯ (UNPACK-SUM-BRANCH (λt₁.λt₂.BRANCH (reflect t₁) (reflect t₂)) t)
               ▯ ERROR)

  || Miranda: xor
  xor False y    = y
  xor True False = True
  xor True True  = False

  || enriched lambda calculus
  xor = λx.λy.( ((λFALSE.λy.y) x y)
              ▯ ((λTRUE.λFALSE.TRUE) x y)
              ▯ ((λTRUE.λTRUE.FALSE) x y)
              ▯ ERROR)

  || - equivalent ->

  xor = λx.λy.case x of
              FALSE -> y
              TRUE  -> case y of
                       FALSE -> TRUE
                       TRUE  -> FALSE

  || Miranda: addPair
  addPair w = x + y
              where (x, y) = w

  || enriched lambda calculus
  addPair = λw.letrec (PAIR x y) = w
               in (+ x y)

  || - equivalent ->

  addPair = λw.letrec v = w
                      x = SELECT-PAIR-1 v
                      y = SELECT-PAIR-2 v
               in (+ x y)
#+end_example

** General Structured Types

#+begin_quote
  "An important difference in structured types in Miranda from that of ML
   or Hope, is that in Miranda constructor functions are lazy; that is
   they do not evaluate their arguments. The components of a structured
   object are evaluated only when (and if) they are subsequently extracted
   and used, not when the object is built."

  — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

#+begin_example
  T ::= c₁ T₁₁ ... T₁ₓ
      | ...
      | cₓ Tₓ₁ ... Tₓₓ

      where Tₓ = types
            cₓ = constructors

  === sum of products ===

  T = T₁ + ... + Tₓ

      where Tₓ = Tₓ₁ × ... × Tₓₓ

 === examples ===

 tree * ::= LEAF * | BRANCH (tree *) (tree *)

 list * ::= NIL | CONS * (list *)

 pair * **       ::= PAIR * **
 triple * ** *** ::= TRIPLE * ** ***

 boolean ::= TRUE | FALSE

     where *, **, *** = generic type variables
           lowercase  = type-forming operator
           UPPERCASE  = constructor function
#+end_example

** Pattern Matching

1. overlapping patterns

2. constant patterns

3. nested patterns

4. multiple arguments

5. non-exhaustive sets of equations

6. conditional equations (guards)

7. repeated variables

#+begin_example
  || 0 is both a literal constant and a pattern
  || that overlaps with "n".

  factorial 0 = 1
  factorial n = n * factorial (n - 1)

  || Both patterns are overlapping and nested. They are also
  || non-exhaustive since neither pattern matches the empty
  || list "[]".

  last (x:[]) = x
  last (x:xs) = last xs

  || A constant pattern can be replaced with a variable
  || and a guard equation.
  ||
  || guard -------+--------+
  ||              |        |
  factorial n = 1, if n = 0
              = n * factorial (n - 1)

  || The repeated use of variable "x" implies equality.

  dedup []       = []
  dedup [x]      = [x]
  dedup [x:x:xs] = dedup (x:xs)
  dedup [x:y:ys] = dedup x : dedup y:ys
#+end_example

- pattern :: Either a variable, a constant, or a constructor pattern
  of the form ~(c p₁ ... pₓ)~ where ~c~ is a constructor of arity ~x~
  and ~p₁ ... pₓ~ are patterns. All patterns should be distinct.

- sum pattern :: ~(s p₁ ... pₓ)~

- product pattern :: ~(t p₁ ... pₓ)~

- simple pattern :: ~(c v₁ ... vₓ)~, where ~v₁ ... vₓ~ are distinct variables.

- nested pattern :: A constructor pattern that is *not* simple. A pattern
  that contains constructor patterns within itself.

- refutable pattern :: A pattern match that can fail.

- irrefutable pattern :: A pattern *p* is irrefutable if is either a variable, *v*,
  or a product pattern *(t p₁ ... pₓ)*, where *p₁ ... pₓ* are irrefutable patterns.

#+begin_quote
  "Intuitively, we expect the semantics to be 'try the first equation,
   and if that fails try the second, and so on'. This introduces the
   idea that a pattern-match might fail. Such failure does not
   necessarily indicate an error, since there might be a subsequent
   equation which would match. Hence, we introduce a new built-in value
   *FAIL*, which is returned when a pattern-match fails."

  — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

** Denotational Semantics

Two perspectives on functions:

1. An algorithm, which will produce a value given an argument. A dynamic or operational
   view of a function as a sequence of operations in time.

2. A set of ordered argument-value pairs. A static or denotational view of a function
   as a fixed set of associations.

*β*, *α*, and *η* are purely syntactic transformations. The lambda calculus is a formal system
for manipulating syntactic symbols.

The purpose of denotational semantics of a language is to assign a value to every expression
in that language. An expression is a syntactic object, formed according to the syntax rules
of the language. A value, by contrast, is an abstract mathematical object.

The function *Eval* maps syntactic expressions to mathematical values.

#+begin_example
  +-------------+           +--------+
  | expressions | - Eval -> | values |
  +-------------+           +--------+

  Eval[ k ]​​ env      = A built-in operation that requires semantic equations to specify
                       both its meaning and imply its operational behavior.

  Eval[ x ]​ env      = env x

  Eval[ E₁ E₂ ]​ env  = (Eval[E₁]​ env) (Eval[E₂]​ env)

  Eval[ λx.E ]​ env v = Eval[E]​ env[x = v]
                       where env[x = v] x = v
                             env[x = v] y = env y

  Eval[<non-normalizing>] = ⊥

  where k   = a constant or built-in function
        x   = a variable
        Eₓ  = expressions
        env = the environment, a function that maps variables to values
        v   = value
        ⊥   = non-terminating

  === pattern matching ===

  Eval[ λk.E ] v = Eval[E], if v = Eval[k]
  Eval[ λk.E ] v = FAIL,    if v ≠ Eval[k] and v ≠ ⊥
  Eval[ λk.E ] ⊥ = ⊥

  Eval[ λ(s p₁ ... pₓ).E ] (s v₁ ... vₓ)  = Eval[ λp₁ ... λpₓ.E ] v₁ ... vₓ
  Eval[ λ(s p₁ ... pₓ).E ] (s' v₁ ... vₓ) = FAIL if s ≠ s'
  Eval[ λ(s p₁ ... pₓ).E ] ⊥              = ⊥

  Eval[ λ(t p₁ ... pₓ).E ] v = Eval[ λp₁ ... λpₓ.E ] (SELECT-t-1 v)
                                                     ...
                                                     (SELECT-t-x v)

  where k  = constant
        s  = sum constructor
        t  = product constructor
        pₓ = patterns
        E  = expression
        vₓ = values

        SELECT-t-x (t v₁ ... vₓ ... vₑ) = vₓ
        SELECT-t-x ⊥                    = ⊥

  === ▯ operator ===

  a    ▯ b = a    if a ≠ ⊥ and a ≠ FAIL
  FAIL ▯ b = b
  ⊥    ▯ b = ⊥
#+end_example

- strict :: A function *f* is strict if and only if *f ⊥ = ⊥*.

#+begin_quote
  "Here [ *SELECT-t-x* ] is a built-in function which selects the [ *xth* ]
   field from a structured object built with constructor *t* ...

   Suppose that *(λp.E)*, where *p* is a product pattern, is applied to an
   expression *A*. The rule for lazy product-matching postpones the
   evaluation of argument *A* by binding the names for the components to
   applications of [ *SELECT-t-x* ] to *A*, rather than evaluating *A*
   and extracting its components directly."

  — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote
