* The Lambda Calculus

** Sources

| source                                                   | author                              |
|----------------------------------------------------------+-------------------------------------|
| *The Implementation of Functional Programming Languages* | Simon L. Peyton Jones               |
| *The Lambda Calculus*                                    | Stanford Encyclopedia of Philosophy |
| *Church's Thesis and Functional Programming*             | David Turner                        |

** Expression Syntax and Notational Conventions

For this particular lambda calculus:

- Lower case names denote variables: (*x*, *y*, ...).

- Single, upper-case letters denote whole lambda expressions: (*M*, *E*, ...).

- Symbols and upper-case identifiers denote built-in functions: (*AND*, *IF*, *+*, *CONS*, ...).

#+begin_example
  <expression> ::= <constant>               # Built-in constant
               |   <variable>               # Variable name
               |   <expression><expression> # Application
               |   λ<variable>.<expression> # Lambda abstraction
#+end_example

As opposed to the pure lambda calculus, an applied lambda calculus is extended
with primitive constants and operations:

1. arithmetic functions: (*+*, *-*, *\star{}*, */*)

2. constants: ((*0*, *1*, *2* ...), (*TRUE*, *FALSE*), ('*a*', '*b*', '*c*' ...), (*NIL*))

3. logical functions: (*AND*, *OR*, *NOT*, *IF*)

4. data constructors: (*CONS*, *HEAD*, *TAIL*)

#+begin_example
  === abstraction ===

  λx.+ x 7

  λ                x  .    +   x    7
  ^                ^  ^    ^   ^    ^
  |                |  |    |   |    |
  That function of x that adds x to 7

  # The scope of an abstraction, λ, extends
  # as far to the right as possible — delimited
  # only by brackets.

  λx.+ x 7 = (λx.+ x 7), not (λx.+) x 7 or (λx.+ x) 7

  === application ===

  # Arity 1, left associative.

  + x 7 → ((+ x) 7)
#+end_example

** Bound and Free Variables

The operator *λ* binds its variable wherever it occurs in the body of the abstraction.
Variables that fall within the scope of an abstraction are *bound*. All other variables
are *free*.

| free                    | bound                   |
|-------------------------+-------------------------|
| FV(x) = {x}             | BV(x) = ∅               |
| FV(M N) = FV(M) ∪ FV(N) | BV(M N) = BV(M) ∪ BV(N) |
| FV(λx[M]) = FV(M) \ {x} | BV(λx[M]) = BV(M) ∪ {x} |

#+begin_example
       +-- bound
  λx.+ x y
         +-- free

             +-- bound
  + x ((λx.+ x 7) 4)
    +-- free


  === scope ===

  # "x" is bound in "λx" but free in "E"

  λx.E

       +-- bound in abstraction
  λx.+ x

       +-- free in body
    (+ x)

  # The inner occurrence of "x" is not free in
  # the body of the outer "λx" abstraction.

    (λx.(λx.+ (- x 1)) x 2) 3

  ⇒ (λx.+ (- x 1)) 3 2

  ⇒ (+ (- 3 1) 2)

  ⇒ 4
#+end_example

#+begin_quote
  "The result of applying a lambda abstraction to an argument is an
   instance of the body of the lambda abstraction in which free
   occurrences of the formal parameter in the body are replaced with
   copies of the argument."

  — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

** Conversion Rules

- λ-conversion :: Written *⇔*, the smallest reflexive, symmetric, transitive, and substitutive
  relation on terms *→α*, *→β* and *→η*.

  - reflexive :: ∀x ∈ X : xRx, where xRx is infix notation for (x,x) ∈ R.

  - symmetric :: ∀x,y ∈ X : xRy → yRx, where xRy is infix notation for (x,y) ∈ R.

  - transitive :: ∀x,y,z ∈ X : (xRy ∧ yRx) → xRz, where xRy is infix notation for (x,y) ∈ R.

- λ-reduction :: Written *⇒*, omits the symmetry of the previous definition for an oriented relation.

- β-Conversion (Beta) :: *(λx.M) E ⇔ M[E/x]*

  - Denotes the substitutive relation between function abstraction and application.

  - The reductive expression *(λx.M) E ⇒ M[E/x]* reads, "Substitute expression *E*
    for all *free* occurrences of variable *x* in expression *M*".

- α-Conversion (Alpha) :: *(λx.M) ⇔ λy.M[y/x]*, where *y ∉ FV(M)*

  - Prevents name clashes of formal parameters within lambda
    abstractions through consistent renaming.

- η-Conversion (Eta) :: *λx.M x ⇔ M* where *x ∉ FV(M)* and *M* denotes a function.

  - Eliminates redundant lambda abstractions.

- δ-conversion :: Rules of conversion for built-in functions — each rule specific
  to its particular function.

** Reduction

- redex :: Called a *reducible expression*, it is the left-hand side of rule β or η.

- reduct :: A term to which a redex reduces. *M[N/x]* is the reduct of *(λx.M) N*

- normal form :: A term that contains no redex.

- normalizing :: A term that can be converted to normal form.

- non-normalizing :: A term that *cannot* be converted to normal form,
  such as *(λx.xx)(λx.xx) →β (λx.xx)(λx.xx)*.

- Church-Rosser Theorem 1 :: If *E_{1} ⇔ E_{2}*, then there exists an expression *E*,
  such that *E_{1} ⇒ E* and *E_{2} ⇒ E*.

  - *corrollary*: No expression can be converted into two distinct normal forms.
    Normal forms must be α-convertible. All reduction sequences that terminate
    will reach the same result.

  - *proof*: Suppose that *E ⇔ E_{1}* and *E ⇔ E_{2}*, where *E_{1}* and *E_{2}* are in
    normal form. Then, *E_{1} ⇔ E_{2}* and, by CRT-1, there must exist an expression
    *F*, such that *E_{1} ⇒ F* and *E_{2} ⇒ F*. But *E_{1}* and *E_{2}* have no redexes,
    so *E_{1} = F = E_{2}*.

- normal order reduction :: The leftmost, outermost redex should be reduced first.

- Church-Rosser Theorem 2 :: If *E_{1} ⇒ E_{2}* is in normal form, then there exists
  a normal order reduction sequence from *E_{1}* to *E_{2}*.

- evaluation :: Successive reductions of redexes until an expression is in normal form.

** Recursion

#+begin_example
  # === Y Combinator ===
  
  Y := λf.(λx.f (x x)) (λx.f (x x))

  # === fixed point ===

  Y F

  ≡ (λf.(λx.f (x x)) (λx.f (x x))) F

  ≡ (λx.F (x x)) (λx.F (x x))

  ≡ F ((λx.F (x x)) (λx.F (x x)))

  ≡ F (Y F)

  Y F → F (Y F)
#+end_example

** Denotational Semantics

Two perspectives on functions:

1. An algorithm, which will produce a value given an argument. A dynamic or operational
   view of a function as a sequence of operations in time.

2. A set of ordered argument-value pairs. A static or denotational view of a function
   as a fixed set of associations.

*β*, *α*, and *η* are purely syntactic transformations. The lambda calculus is a formal system
for manipulating syntactic symbols.

The purpose of denotational semantics of a language is to assign a value to every expression
in that language. An expression is a syntactic object, formed according to the syntax rules
of the language. A value, by contrast, is an abstract mathematical object.

The function *Eval* maps syntactic expressions to mathematical values.

#+begin_example
  Eval[k] p      = A built-in operation that requires semantic equations to specify
                   both its meaning and imply its operational behavior.

  Eval[x] p      = p x

  Eval[E1, E2] p = (Eval[E1] p) (Eval[E2] p)

  Eval[λx.E] p a = Eval[E] p[x=a]

      where k          is a constant or built-in function
            x          is a variable
            E, E1, E2  are expressions
            p          is the environment, a function that maps variables to values
#+end_example

** The Enriched Lambda Calculus

#+begin_example
  <expression> ::= <constant>
               |   <variable>
               |   <expression><expression>
               |   λ<pattern>.<expression>
               |   let <pattern> = <expression> in <expression>
               |   letrec <pattern> = <expression>
                          ...
                          <pattern> = <expression>
                   in <expression>
               |   <expression> ▯ <expression>
               |   case <variable> of
                   <pattern> -> <expression>
                   ...
                   <pattern> -> <expression>

  <pattern> ::= <constant>
            |   <variable>
            |   <constructor><pattern>
                             ...
                             <pattern>
#+end_example

*** *let* Semantics

#+begin_example
  let v = B in E ≡ (λv.E) B
#+end_example

As a matter of convenience, multiple definitions can be written in the same ~let~.

#+begin_example
  # === example 1 ===

  let x = 3
      y = 4
  in (* x y)

  # - equivalent ->

  let x = 3
  in let y = 4
     in (* x y)

  # - equivalent ->

  λx.(λy.(* x y)) 3 4

  # === example 2 ===

  let x = 3
      y = 4
      z = (* x y)
  in z

  # - equivalent ->

  let x = 3
  in let y = 4
     in let z = (* x y)
        in z

  # - equivalent ->

  λx.(λy.(λz.z) (* x y)) 3 4
#+end_example

*** *letrec* Semantics

#+begin_example
  letrec v = B in E ≡ let v = Y (λv.B) in E
                      where Y = (λf.(λx.f (x x)) (λx.f (x x)))
#+end_example

*** Example Translation

#+begin_example
  # definition
  average a b = (a + b) / 2

  # expression
  average 2 (3 + 5)

  # enriched lambda calculus
  let
    average = λa.λb.(/ (+ a b) 2)
  in
    average 2 (+ 3 5)

  # plain lambda calculus
  (λaverage.(average 2 (+ 3 5))) (λa.λb.(/ (+ a b) 2))
#+end_example

*** *▯* Operator Semantics

- infix

- associative

- identity = *FAIL*

#+begin_example
  a    ▯ b = a    if a ≠ ⊥ and a ≠ FAIL
  FAIL ▯ b = b
  ⊥    ▯ b = ⊥
#+end_example
