* The Lambda Calculus

** Sources

| source                                                   | author                              |
|----------------------------------------------------------+-------------------------------------|
| *The Implementation of Functional Programming Languages* | Simon L. Peyton Jones               |
| *The Lambda Calculus*                                    | Stanford Encyclopedia of Philosophy |

** Expression Syntax and Notational Conventions

For this particular lambda calculus:

- Lower case names denote variables: (*x*, *y*, ...).

- Single, upper-case letters denote whole lambda expressions: (*M*, *E*, ...).

- Symbols and upper-case identifiers denote built-in functions: (*AND*, *IF*, *+*, *CONS*, ...).

#+begin_example
  <expression> ::= <constant>               # Built-in constant
               |   <variable>               # Variable name
               |   <expression><expression> # Application
               |   λ<variable>.<expression> # Lambda abstraction
#+end_example

As opposed to the pure lambda calculus, an applied lambda calculus is extended
with primitive constants and operations:

1. arithmetic functions: (*+*, *-*, *\star{}*, */*)

2. constants: ((*0*, *1*, *2* ...), (*TRUE*, *FALSE*), ('*a*'*, '*b*', '*c*' ...), (*NIL*))

3. logical functions: (*AND*, *OR*, *NOT*, *IF*)

4. data constructors: (*CONS*, *HEAD*, *TAIL*)

#+begin_example
  === abstraction ===
  
  λx.+ x 7

  λ                x  .    +   x    7
  ^                ^  ^    ^   ^    ^
  |                |  |    |   |    |
  That function of x that adds x to 7

  # Body extends rightward unless delimited by brackets.

  λx.+ x 7 = λx.(+ x 7), not (λx.+) x 7 or (λx.+ x) 7

  === application ===

  # Arity 1, left associative.

  + x 7 → ((+ x) 7)
#+end_example

** Bound and Free Variables

The operator *λ* binds its variable wherever it occurs in the body of the abstraction.
Variables that fall within the scope of an abstraction are *bound*. All other variables
are *free*.

| free                    | bound                   |
|-------------------------+-------------------------|
| FV(x) = {x}             | BV(x) = ∅               |
| FV(M N) = FV(M) ∪ FV(N) | BV(M N) = BV(M) ∪ BV(N) |
| FV(λx[M]) = FV(M) \ {x} | BV(λx[M]) = BV(M) ∪ {x} |

#+begin_example
       +-- bound
  λx.+ x y
         +-- free

             +-- bound
  + x ((λx.+ x 7) 4)
    +-- free
#+end_example

** Conversion Rules

*** λ-conversion

Written *⇔*, the smallest reflexive, symmetric, transitive, and substitutive
relation on terms *→α*, *→β* and *→η*.

*** λ-reduction

Written *⇒*, omits the symmetry of the previous definition for an oriented relation.

*** β-Conversion (Beta)

*(λx.M) E ⇔ M[E/x]*

Denotes relation between function abstraction and application.

*** α-Conversion (Alpha)

*λx.M[x] ⇔ λy.M[y]*

Prevents name clashes of formal parameters within lambda abstractions through
consistent renaming.

*** η-Conversion (Eta)

*λx.M x ⇔ M* where *x ∉ FV(M)* and *M* denotes a function.

Eliminates redundant lambda abstractions.

** Recursion

#+begin_example
  # === Y Combinator ===
  
  Y := λf.(λx.f (x x)) (λx.f (x x))

  # === fixed point ===

  Y F

  ≡ (λf.(λx.f (x x)) (λx.f (x x))) F

  ≡ (λx.F (x x)) (λx.F (x x))

  ≡ F ((λx.F (x x)) (λx.F (x x)))

  ≡ F (Y F)

  Y F → F (Y F)
#+end_example

** Denotational Semantics

Two perspectives on functions:

1. An algorithm, which will produce a value given an argument. A dynamic or operational
   view of a function as a sequence of operations in time.

2. A set of ordered argument-value pairs. A static or denotational view of a function
   as a fixed set of associations.

*β*, *α*, and *η* are purely syntactic transformations. The lambda calculus is a formal system
for manipulating syntactic symbols.

The purpose of denotational semantics of a language is to assign a value to every expression
in that language. An expression is a syntactic object, formed according to the syntax rules
of the language. A value, by contrast, is an abstract mathematical object.

The function *Eval* maps syntactic expressions to mathematical values.

#+begin_example
  Eval[k] p      = A built-in operation that requires semantic equations to specify
                   both its meaning and imply its operational behavior.

  Eval[x] p      = p x

  Eval[E1, E2] p = (Eval[E1] p) (Eval[E2] p)

  Eval[λx.E] p a = Eval[E] p[x=a]

      where k          is a constant or built-in function
            x          is a variable
            E, E1, E2  are expressions
            p          is the environment, a function that maps variables to values
#+end_example

** The Enriched Lambda Calculus

#+begin_example
  <expression> ::= <constant>
               |   <variable>
               |   <expression><expression>
               |   λ<pattern>.<expression>
               |   let <pattern> = <expression> in <expression>
               |   letrec <pattern> = <expression>
                          ...
                          <pattern> = <expression>
                   in <expression>
               |   <expression> ▯ <expression>
               |   case <variable> of
                   <pattern> -> <expression>
                   ...
                   <pattern> -> <expression>

  <pattern> ::= <constant>
            |   <variable>
            |   <constructor><pattern>
                             ...
                             <pattern>
#+end_example

*** *let* Semantics

#+begin_example
  let v = B in E ≡ (λv.E) B
#+end_example

As a matter of convenience, multiple definitions can be written in the same ~let~.

#+begin_example
  # === example 1 ===

  let x = 3
      y = 4
  in (* x y)

  # - equivalent ->

  let x = 3
  in let y = 4
     in (* x y)

  # - equivalent ->

  λx.(λy.(* x y)) 3 4

  # === example 2 ===

  let x = 3
      y = 4
      z = (* x y)
  in z

  # - equivalent ->

  let x = 3
  in let y = 4
     in let z = (* x y)
        in z

  # - equivalent ->

  λx.(λy.(λz.z) (* x y)) 3 4
#+end_example

*** *letrec* Semantics

#+begin_example
  letrec v = B in E ≡ let v = Y (λv.B) in E
                      where Y = (λf.(λx.f (x x)) (λx.f (x x)))
#+end_example

*** Example Translation

#+begin_example
  # definition
  average a b = (a + b) / 2

  # expression
  average 2 (3 + 5)

  # enriched lambda calculus
  let
    average = λa.λb.(/ (+ a b) 2)
  in
    average 2 (+ 3 5)

  # plain lambda calculus
  (λaverage.(average 2 (+ 3 5))) (λa.λb.(/ (+ a b) 2))
#+end_example

*** *▯* Operator Semantics

- infix

- associative

- identity = *FAIL*

#+begin_example
  a    ▯ b = a    if a ≠ ⊥ and a ≠ FAIL
  FAIL ▯ b = b
  ⊥    ▯ b = ⊥
#+end_example
