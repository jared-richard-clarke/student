* The Lambda Calculus

** Sources

| source                                                   | author                              |
|----------------------------------------------------------+-------------------------------------|
| *The Implementation of Functional Programming Languages* | Simon L. Peyton Jones               |
| *The Lambda Calculus*                                    | Stanford Encyclopedia of Philosophy |
| *Church's Thesis and Functional Programming*             | David Turner                        |

** Expression Syntax and Notational Conventions

For this particular lambda calculus:

- Lower case names denote variables: (*x*, *y*, ...).

- Single, upper-case letters denote whole lambda expressions: (*M*, *E*, ...).

- Symbols and upper-case identifiers denote built-in functions: (*AND*, *IF*, *+*, *CONS*, ...).

#+begin_example
  <expression> ::= <constant>               # Built-in constant
               |   <variable>               # Variable name
               |   <expression><expression> # Application
               |   λ<variable>.<expression> # Lambda abstraction
#+end_example

As opposed to the pure lambda calculus, an applied lambda calculus is extended
with primitive constants and operations:

1. arithmetic functions: (*+*, *-*, *\star{}*, */*)

2. constants: ((*0*, *1*, *2* ...), (*TRUE*, *FALSE*), ('*a*', '*b*', '*c*' ...), (*NIL*))

3. logical functions: (*AND*, *OR*, *NOT*, *IF*)

4. data constructors: (*CONS*, *HEAD*, *TAIL*)

#+begin_example
  === abstraction ===

  λx.+ x 7

  λ                x  .    +   x    7
  ^                ^  ^    ^   ^    ^
  |                |  |    |   |    |
  That function of x that adds x to 7

  # The scope of an abstraction, λ, extends
  # as far to the right as possible — delimited
  # only by brackets.

  λx.+ x 7 = (λx.+ x 7), not (λx.+) x 7 or (λx.+ x) 7

  === application ===

  # Arity 1, left associative.

  + x 7 → ((+ x) 7)
#+end_example

** Bound and Free Variables

The operator *λ* binds its variable wherever it occurs in the body of the abstraction.
Variables that fall within the scope of an abstraction are *bound*. All other variables
are *free*.

| free                    | bound                   |
|-------------------------+-------------------------|
| FV(x) = {x}             | BV(x) = ∅               |
| FV(M N) = FV(M) ∪ FV(N) | BV(M N) = BV(M) ∪ BV(N) |
| FV(λx[M]) = FV(M) \ {x} | BV(λx[M]) = BV(M) ∪ {x} |

#+begin_example
       +-- bound
  λx.+ x y
         +-- free

             +-- bound
  + x ((λx.+ x 7) 4)
    +-- free


  === scope ===

  # "x" is bound in "λx" but free in "E"

  λx.E

       +-- bound in abstraction
  λx.+ x

       +-- free in body
    (+ x)

  # The inner "x" is not substituted for in the first reduction,
  # since it is not free in the body of the outer "λx" abstraction.

    (λx.(λx.+ (- x 1)) x 2) 3

  ⇒ (λx.+ (- x 1)) 3 2

  ⇒ (+ (- 3 1) 2)

  ⇒ 4
#+end_example

#+begin_quote
  "The result of applying a lambda abstraction to an argument is an
   instance of the body of the lambda abstraction in which free
   occurrences of the formal parameter in the body are replaced with
   copies of the argument."

  — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

** Conversion Rules

- λ-conversion :: Written *⇔*, the smallest reflexive, symmetric, transitive, and substitutive
  relation on terms *→α*, *→β* and *→η*.

  - reflexive :: ∀x ∈ X : xRx, where xRx is infix notation for (x, x) ∈ R.

  - symmetric :: ∀x∀y ∈ X : xRy → yRx, where xRy is infix notation for (x, y) ∈ R.

  - transitive :: ∀x∀y∀z ∈ X : (xRy ∧ yRx) → xRz, where xRy is infix notation for (x, y) ∈ R.

- λ-reduction :: Written *⇒*, omits the symmetry of the previous definition for an oriented relation.

- β-conversion (Beta) :: *(λx.M) E ⇔ M[E/x]*

  - Denotes the substitutive relation between function abstraction and application.

  - The reductive expression *(λx.M) E ⇒ M[E/x]* reads, "Substitute expression *E*
    for all *free* occurrences of variable *x* in expression *M*".

- α-conversion (Alpha) :: *(λx.M) ⇔ λy.M[y/x]*, where *y ∉ FV(M)*

  - β-reduction is valid provided the free variables of an argument do not
    clash with any formal parameters in the body of the lambda abstraction.
    α-conversion renames bound variables to prevent variable name capture.

- η-conversion (Eta) :: *λx.M x ⇔ M* where *x ∉ FV(M)* and *M* denotes a function.

  - Eliminates redundant lambda abstractions.

- δ-conversion :: Rules of conversion for built-in functions — each rule specific
  to its particular function.

** Reduction

- redex :: Called a *reducible expression*, it is the left-hand side of rule β or η.

- reduct :: A term to which a redex reduces. *M[N/x]* is the reduct of *(λx.M) N*

- normal form :: A term that contains no redex.

- normalizing :: A term that can be converted to normal form.

- non-normalizing :: A term that *cannot* be converted to normal form,
  such as *(λx.xx)(λx.xx) →β (λx.xx)(λx.xx)*.

- Church-Rosser Theorem 1 :: If *E_{1} ⇔ E_{2}*, then there exists an expression *E*,
  such that *E_{1} ⇒ E* and *E_{2} ⇒ E*.

  - *corrollary*: No expression can be converted into two distinct normal forms.
    Normal forms must be α-convertible. All reduction sequences that terminate
    will reach the same result.

  - *proof*: Suppose that *E ⇔ E_{1}* and *E ⇔ E_{2}*, where *E_{1}* and *E_{2}* are in
    normal form. Then, *E_{1} ⇔ E_{2}* and, by CRT-1, there must exist an expression
    *F*, such that *E_{1} ⇒ F* and *E_{2} ⇒ F*. But *E_{1}* and *E_{2}* have no redexes,
    so *E_{1} = F = E_{2}*.

- normal order reduction :: The leftmost, outermost redex reduces first.

#+begin_quote
  "[Normal order reduction] embodies the intuition that arguments
   to functions may be discarded..."

   — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

- Church-Rosser Theorem 2 :: If *E_{1} ⇒ E_{2}* is in normal form, then there exists
  a normal order reduction sequence from *E_{1}* to *E_{2}*.

- evaluation :: Successive reductions of redexes until an expression is in normal form.

** Recursion

#+begin_example
  # === Y Combinator ===

  Y := λf.(λx.f (x x)) (λx.f (x x))

  # === fixed point ===

  Y F

  ≡ (λf.(λx.f (x x)) (λx.f (x x))) F

  ≡ (λx.F (x x)) (λx.F (x x))

  ≡ F ((λx.F (x x)) (λx.F (x x)))

  ≡ F (Y F)

  Y F → F (Y F)
#+end_example

** The Enriched Lambda Calculus

#+begin_example
  <expression> ::= <constant>
               |   <variable>
               |   <expression><expression>
               |   λ<pattern>.<expression>
               |   let <pattern> = <expression> in <expression>
               |   letrec <pattern> = <expression>
                          ...
                          <pattern> = <expression>
                   in <expression>
               |   <expression> ▯ <expression>
               |   case <variable> of
                   <pattern> -> <expression>
                   ...
                   <pattern> -> <expression>

  <pattern> ::= <constant>
            |   <variable>
            |   <constructor><pattern>
                             ...
                             <pattern>
#+end_example

*** ~let~ Translation

#+begin_example
  let v = B in E

  # - equivalent ->

  (λv.E) B
#+end_example

As a matter of convenience, multiple definitions can be written in the same ~let~.

#+begin_example
  let x = 3
      y = 4
  in (* x y)

  # - equivalent ->

  let x = 3
  in let y = 4
     in (* x y)

  # - equivalent ->

  λx.(λy.(* x y)) 3 4
#+end_example

*** ~letrec~ Translation

#+begin_example
  letrec v = B in E

  # - equivalent ->

  let v = Y (λv.B) in E
          where Y = λf.(λx.f (x x)) (λx.f (x x))

 # - equivalent ->

 (λv.E) (Y (λv.B))
        where Y = λf.(λx.f (x x)) (λx.f (x x))
#+end_example

** Miranda to Lambda

*** Translation Scheme

#+begin_example
  === Miranda Program ===

  +--------------+
  | definition 1 |
  | definition 2 |
  | ...          |
  | definition x |
  |--------------|
  | expression   |
  +--------------+

  === TE[expression] = translate expression ===

  TE[ : ]               ≡ CONS

  TE[ [] ]              ≡ NIL

  TE[ [E₁, E₂ ... Eₓ] ] ≡ CONS TE[E₁] TE[ [E₂ ... Eₓ] ]

  TE[ (E₁, E₂) ]        ≡ PAIR TE[E₁] TE[E₂]

  TE[ (E₁, E₂, E₃) ]    ≡ TRIPLE TE[E₁] TE[E₂] TE[E₃]

  TE[True]              ≡ TRUE

  TE[False]             ≡ FALSE

  TE[k]                 ≡ k

  TE[v]                 ≡ v

  TE[E₁ E₂]             ≡ TE[E₁] TE[E₂]

  TE[E₁ infix E₂]       ≡ TE[infix] TE[E₁] TE[E₂]

  TE[E₁ $v E₂]          ≡ TE[v] TE[E₁] TE[E₂]

      where k      = literal constant or built-in operator
            v      = variable
            Eₓ     = expressions
            infix  = built-in infix operator
            $v     = function as infix operation

  === TD[definition] = translate definition ===

  TD[p = R] ≡ TE[p] = TR[R]

    +-                  -+
  TD| f p₁₁ ... p₁ₓ = R₁ | ≡ f = (λv₁ ... λvₓ.( ((λTE[p₁₁] ... λTE[p₁ₓ]. TR[R₁]) v₁ ... vₓ)
    | ...                |                    ▯ ...
    | f pₓ₁ ... pₓₓ = Rₓ |                    ▯ ((λTE[pₓ₁] ... λTE[pₓₓ]. TR[Rₓ]) v₁ ... vₓ)
    +-                  -+                    ▯ ERROR))

    where f   = variable
          vₓ  = variable bound in Rₓ
          pₓₓ = pattern
          Rₓ  = right-hand side

  === TR[rhs] = translate right-hand side ===

    +-               -+
  TR|   A₁, G₁        | ≡ letrec TD[D₁]
    | = ...           |          ...
    | = Aₓ, Gₓ        |          TD[Dₓ]
    | where D₁ ... Dₓ |   in
    +-               -+      (IF TE[G₁] TE[A₁]
                              ...
                             (IF TE[Gₓ] TE[Aₓ] FAIL) ...)

  If Gₓ is absent, or True, then the final IF-expression
  should be replaced by TE[Aₓ].

      where Aₓ = expression
            Gₓ = boolean-valued expression
            Dₓ = definition
#+end_example

*** Basic Translation

#+begin_example
  # definition
  average a b = (a + b) / 2

  # expression
  average 2 (3 + 5)

  # enriched lambda calculus
  let
    average = λa.(λb./ (+ a b) 2)
  in
    average 2 (+ 3 5)

  # plain lambda calculus
  (λaverage.(average 2 (+ 3 5))) λa.(λb./ (+ a b) 2)
#+end_example

*** Pattern-Match Translation

#+begin_example
  # Miranda
  head (x:xs) = x

  # enriched lambda calculus
  head = λxs'.(((λ(CONS x xs).x) xs') ▯ ERROR)

  # Miranda
  reflect (LEAF n) = LEAF n
  reflect (BRANCH x y) = BRANCH (reflect y) (reflect x)

  # enriched lambda calculus

  reflect = λt.( ((λ(LEAF n).LEAF n) t)
               ▯ ((λ(BRANCH x y).BRANCH (reflect y) (reflect x)) t)
               ▯ ERROR)

  # Miranda
  xor False y    = y
  xor True False = True
  xor True True  = False

  # enriched lambda calculus
  xor = λx.λy.( ((λFALSE.λy.y) x y)
              ▯ ((λTRUE.λFALSE.TRUE) x y)
              ▯ ((λTRUE.λTRUE.FALSE) x y)
              ▯ ERROR)

  # Miranda
  addPair w = x + y
              where (x, y) = w

  # enriched lambda calculus
  addPair = λw.(letrec (PAIR x y) = w in (+ x y))
#+end_example

** General Structured Types

#+begin_example
  T ::= c₁ T₁₁ ... T₁ₓ
      | ...
      | cₓ Tₓ₁ ... Tₓₓ

      where Tₓ = types
            cₓ = constructors

  === sum of products ===

  T = T₁ + ... + Tₓ

      where Tₓ = Tₓ₁ × ... × Tₓₓ
#+end_example

** Pattern Matching

1. overlapping patterns

2. constant patterns

3. nested patterns

4. multiple arguments

5. non-exhaustive sets of equations

6. conditional equations

7. repeated variables

- pattern :: Either a variable, a constant, or a constructor pattern
  of the form ~(c p₁ ... pₓ)~ where ~c~ is a constructor of arity ~x~
  and ~p₁ ... pₓ~ are patterns. All patterns should be distinct.

- sum pattern :: ~(s p₁ ... pₓ)~

- product pattern :: ~(t p₁ ... pₓ)~

- simple pattern :: ~(c v₁ ... vₓ)~, where ~v₁ ... vₓ~ are distinct variables.

- nested pattern :: A constructor pattern that is *not* simple.

#+begin_quote
  "Intuitively, we expect the semantics to be 'try the first equation,
   and if that fails try the second, and so on'. This introduces the
   idea that a pattern-match might fail. Such failure does not
   necessarily indicate an error, since there might be a subsequent
   equation which would match. Hence, we introduce a new built-in value
   *FAIL*, which is returned when a pattern-match fails."

  — *The Implementation of Functional Programming Languages*, Simon L. Peyton Jones
#+end_quote

** Denotational Semantics

Two perspectives on functions:

1. An algorithm, which will produce a value given an argument. A dynamic or operational
   view of a function as a sequence of operations in time.

2. A set of ordered argument-value pairs. A static or denotational view of a function
   as a fixed set of associations.

*β*, *α*, and *η* are purely syntactic transformations. The lambda calculus is a formal system
for manipulating syntactic symbols.

The purpose of denotational semantics of a language is to assign a value to every expression
in that language. An expression is a syntactic object, formed according to the syntax rules
of the language. A value, by contrast, is an abstract mathematical object.

The function *Eval* maps syntactic expressions to mathematical values.

#+begin_example
  +-------------+           +--------+
  | expressions | - Eval -> | values |
  +-------------+           +--------+

  Eval[ k ]​​ p      = A built-in operation that requires semantic equations to specify
                     both its meaning and imply its operational behavior.

  Eval[ x ]​ p      = p x

  Eval[ E₁ E₂ ]​ p  = (Eval[E₁]​ p) (Eval[E₂]​ p)

  Eval[ λx.E ]​ p a = Eval[E]​ p[x = a]
                     where p[x = a] x = a
                           p[x = a] y = p y

  Eval[<non-normalizing>] = ⊥

  where k  = a constant or built-in function
        x  = a variable
        Eₓ = expressions
        p  = the environment, a function that maps variables to values
        ⊥  = non-terminating

  === pattern matching ===

  Eval[ λx.E ] v = Eval[E] if v = Eval[x]
  Eval[ λx.E ] v = FAIL    if v ≠ Eval[x] and v ≠ ⊥
  Eval[ λx.E ] ⊥ = ⊥

  Eval[ λ(s p₁ ... pₓ).E ] (s v₁ ... vₓ)  = Eval[ λp₁ ... λpₓ.E ] v₁ ... vₓ
  Eval[ λ(s p₁ ... pₓ).E ] (s' v₁ ... vₓ) = FAIL if s ≠ s'
  Eval[ λ(s p₁ ... pₓ).E ] ⊥              = ⊥

  Eval[ λ(t p₁ ... pₓ).E ] v = Eval[ λp₁ ... λpₓ.E ] (SELECT-t-1 v)
                                                     ...
                                                     (SELECT-t-x v)

  where k  = constant
        s  = sum constructor
        t  = product constructor
        pₓ = patterns
        E  = expression
        vₓ = values

        SELECT-t-x (t v₁ ... vₓ ... vₑ) = vₓ
        SELECT-t-x ⊥                    = ⊥

  === ▯ operator ===

  a    ▯ b = a    if a ≠ ⊥ and a ≠ FAIL
  FAIL ▯ b = b
  ⊥    ▯ b = ⊥
#+end_example

- strict :: A function *f* is strict if and only if *f ⊥ = ⊥*.
