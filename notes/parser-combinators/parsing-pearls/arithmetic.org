* Parsing Arithmetic Expressions

| source              | author                        |
|---------------------+-------------------------------|
| *Functional Pearls* | Graham Hutton and Erik Meijer |

** Expression Grammar

#+begin_example
  expr    ::= expr add-op term   | term
  term    ::= term mul-op factor | factor
  factor  ::= digit | ( expr )
  digit   ::= [0-9]
  add-op  ::= + | -
  mul-op  ::= * | /
#+end_example

** Parser and Evaluator

#+begin_src haskell
  expr  :: Parser Int
  addop :: Parser (Int -> Int -> Int)
  mulop :: Parser (Int -> Int -> Int)

  expr = term `chainl1` addop

  term = factor `chainl1` mulop

  factor = digit +++ do { symbol "("; n <- expr; symbol ")"; return n }

  digit = do { x <- token (sat isDigit); return (ord x - ord '0') }

  addop = do { symbol "+"; return (+)} +++ do {symbol "-"; return (-) }

  mulop = do { symbol "*"; return (*)} +++ do {symbol "/"; return (div) }

  -- apply expr "1 - 2 * 3 + 4" -> [(-1, "")]
#+end_src

