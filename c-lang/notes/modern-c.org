* Modern C

** Sources

| source              | author       |
|---------------------+--------------|
| *Modern C*          | Jens Gustedt |
| *C Syntax*          | Wikipedia    |
| *C Reference*       | cppreference |
| *Compiler Explorer* | godbolt.org  |

** Primary Types

The C language provides the four basic arithmetic type specifiers ~char~, ~int~, ~float~,
and ~double~, and the modifiers ~signed~, ~unsigned~, ~short~, and ~long~.

The type ~size_t~ represents values in range ~[0, SIZE_MAX]~. Depending on the platform ~SIZE_MAX~
is equal to ~2^16 - 1~, ~2^32 - 1~, or ~2^64 - 1~. ~SIZE_MAX~ is contained in ~stdint.h~. ~size_t~
is an unsigned integer type.

Narrow types must be promoted to a wider type — usually a ~signed int~ — before they are used
in an arithmetic expression.

- Use ~size_t~ for sizes, cardinalities, or ordinals.

- Use ~unsigned~ for small, non-negative quantities.

- Use ~signed~ for small quantities that bear a sign.

- Use ~ptrdiff_t~ for large differences that bear a sign.

- Use ~double~ for floating-point calculations.

- Use ~double complex~ for complex calculations.

#+begin_example
  | class                     | systematic name      | other name          | rank |
  |---------------------------+----------------------+---------------------+------|<
  |                           | _Bool                | bool                | 0    | |
  |                           | unsigned char        |                     | 1    | +-+
  |                unsigned   | unsigned short       |                     | 2    | | |
  |                           |----------------------+---------------------+------|<  |
  |                           | unsigned int         | unsigned            | 3    |   |
  |                           | unsigned long        |                     | 4    |   +- narrow types
  |                           | unsigned long long   |                     | 5    |   |
  |                -----------+----------------------+---------------------+------|<  |
  | integers       [un]signed | char                 |                     | 1    | | |
  |                -----------+----------------------+---------------------+------| +-+
  |                           | signed char          |                     | 1    | |
  |                           | signed short         | short               | 2    | |
  |                           |----------------------+---------------------+------|<
  |                signed     | signed int           | signed or int       | 3    |
  |                           | signed long          | long                | 4    |
  |                           | signed long long     | long long           | 5    |
  |---------------------------+----------------------+---------------------+------|
  |                           | float                |                     |      |
  |                real       | double               |                     |      |
  |                           | long double          |                     |      |
  | floating point            |----------------------+---------------------+------|
  |                           | float _Complex       | float complex       |      |
  |                complex    | double _Complex      | double complex      |      |
  |                           | long double _Complex | long double complex |      |
#+end_example

** Semantic Arithmetic Types

| type        | header     | meaning                              |
|-------------+------------+--------------------------------------|
| ~size_t~    | ~stddef.h~ | type for "sizes" and cardinalities   |
|-------------+------------+--------------------------------------|
| ~ptrdiff_t~ | ~stddef.h~ | type for size differences            |
|-------------+------------+--------------------------------------|
| ~uint8_t~   | ~stdint.h~ | 8-bit unsigned integer               |
|-------------+------------+--------------------------------------|
| ~uint16_t~  | ~stdint.h~ | 16-bit unsigned integer              |
|-------------+------------+--------------------------------------|
| ~uint32_t~  | ~stdint.h~ | 32-bit unsigned integer              |
|-------------+------------+--------------------------------------|
| ~uint64_t~  | ~stdint.h~ | 64-bit unsigned integer              |
|-------------+------------+--------------------------------------|
| ~uintmax_t~ | ~stdint.h~ | maximum-width unsigned integer       |
|-------------+------------+--------------------------------------|
| ~int8_t~    | ~stdint.h~ | 8-bit signed integer                 |
|-------------+------------+--------------------------------------|
| ~int16_t~   | ~stdint.h~ | 16-bit signed integer                |
|-------------+------------+--------------------------------------|
| ~int32_t~   | ~stdint.h~ | 32-bit signed integer                |
|-------------+------------+--------------------------------------|
| ~int64_t~   | ~stdint.h~ | 64-bit signed integer                |
|-------------+------------+--------------------------------------|
| ~intmax_t~  | ~stdint.h~ | maximum-width signed integer         |
|-------------+------------+--------------------------------------|
| ~time_t~    | ~time.h~   | calendar time in seconds since epoch |
|-------------+------------+--------------------------------------|
| ~clock_t~   | ~time.h~   | processor time                       |

** Operator Precedence

|------------+----------------------+---------------------------------------------------+---------------|
|          1 | ~++~ ~--~            | Postfix increment and decrement                   | left          |
|            | ~()~                 | Function call                                     |               |
|            | ~[]~                 | Array subscripting                                |               |
|            | ~.~                  | Structure and union member access                 |               |
|            | ~->~                 | Structure and union member access through pointer |               |
|            | ~(type){list}~       | Compound literal (C99)                            |               |
|------------+----------------------+---------------------------------------------------+---------------|
|          2 | ~++~ ~--~            | Prefix increment and decrement                    | right         |
|            | ~+~ ~-~              | Unary plus and minus                              |               |
|            | ~!~ ~                | Logical and bitwise NOT                           |               |
|            | ~(type)~             | Cast                                              |               |
|            | ~*~                  | Indirection (dereference)                         |               |
|            | ~&~                  | Address-of                                        |               |
|            | ~sizeof~             | Size-of                                           |               |
|            | ~_Alignof~           | Alignment requirement (C11)                       |               |
|------------+----------------------+---------------------------------------------------+---------------|
|          3 | ~*~ ~/~ ~%~          | Multiplication, division, and remainder           | left          |
|          4 | ~+~ ~-~              | Addition and subtraction                          |               |
|          5 | ~>>~ ~<<~            | Bitwise right shift and left shift                |               |
|          6 | ~<~ ~<=~             | Relational operators *<* and *≤*                  |               |
|            | ~>~ ~>=~             | Relational operators *>* and *≥*                  |               |
|          7 | ~==~ ~!=~            | Relational operators *=* and *≠*                  |               |
|          8 | ~&~                  | Bitwise AND                                       |               |
|          9 | ~^~                  | Bitwise XOR                                       |               |
|         10 | ~|~                  | Bitwise OR                                        |               |
|         11 | ~&&~                 | Logical AND                                       |               |
|         12 | ~||~                 | Logical OR                                        |               |
|------------+----------------------+---------------------------------------------------+---------------|
|         13 | ~?:~                 | Ternary conditional                               | right         |
|         14 | ~=~                  | Assignment                                        |               |
|            | ~+=~ ~-=~            | Assignment by sum and difference                  |               |
|            | ~*=~ ~/=~ ~%=~       | Assignment by product, quotient, and remainder    |               |
|            | ~>>=~ ~<<=~          | Assignment by bitwise right shift and left shift  |               |
|            | ~&=~ ~^=~ ~|=~       | Assignment by bitwise AND, XOR, and OR            |               |
|------------+----------------------+---------------------------------------------------+---------------|
|         15 | ~,~                  | Comma                                             | left          |

** Type Operators

| operator   | alt-name   | form             | type T | operation     |
|------------+------------+------------------+--------+---------------|
| ~sizeof~   |            | ~sizeof(T)~      | any    | size          |
| ~_Alignof~ | ~alignof~  | ~_Alignof(T)~    | any    | alignment     |
|            | ~offsetof~ | ~offsetof(T, m)~ | struct | member offset |

- The ~sizeof~ operator can be applied to both types (~sizeof(int)~) and expressions (~sizeof 7~).
  Although parentheses need only wrap types, its good practice to be consistent and wrap both types
  and expressions.

** Assorted Syntax and Semantics

#+begin_src c
  /* === Compound Assignment === */

  x += y;

  /* - equivalent -> */

  x = x + y;

  /* === Definition and Intialization === */

  int variable = 11;

  /* - equivalent -> */

  int variable;
  variable = 11;

  /* === Prefix Increment/Decrement === */

  x = ++i;
  x = --i;

  /* - equivalent -> */

  i = i + 1;
  x = i;
  i = i - 1;
  x = i;

  /* === Postfix Increment/Decrement === */

  x = i++;
  x = i--;

  /* - equivalent -> */

  x = i;
  i = i + 1;
  x = i;
  i = i - 1;

  /* === For Loop === */

  int x, sum;
  sum = 0;
  for (x = 1; x <= 10; x += 1) {
      sum += x;
  }

  /* - equivalent -> */

  int x, sum;
  sum = 0;
  x   = 1;
  while (x <= 10) {
      sum += x;
      x   += 1;
  }

  int sum = 0;
  /*
    Starting in C99, a variable declared in the initialization
    part of a for loop's header has block scope restricted to the
    loop and its body.
  */
  for (int x = 1; x <= 10; x += 1) {
      sum += x;
  }

  /* - equivalent -> */

  int sum = 0;
  {
      int x = 1;
      while (x <= 10) {
          sum += x;
          x   += 1;
      }
  }

  /* === Infinite For Loop === */

  int sum = 0;
  for (;;) {
      sum += 1;
  }

  /* - equivalent -> */

  int sum = 0;
  while (true) {
      sum += 1;
  }

  /* === comma operator === */

  int a, b, c;
  c = (a = 7, b = 11, a + b);

  /* - equivalent -> */

  int a, b, c;
  a = 7;
  b = 11;
  c = a + b;
#+end_src

** The C Libraries

| name              | description                                  |
|-------------------+----------------------------------------------|
| ~<assert.h>~      | Runtime condition assertion                  |
| ~<complex.h>~     | Complex numbers                              |
| ~<ctype.h>~       | Character classification and conversion      |
| ~<errno.h>~       | Error codes                                  |
| ~<fenv.h>~        | Floating-point environment                   |
| ~<float.h>~       | Properties of floating-point types           |
| ~<inttypes.h>~    | Formatting conversion of integer types       |
| ~<iso646.h>~      | Alternative spellings for operators          |
| ~<limits.h>~      | Properties of integer types                  |
| ~<locale.h>~      | Internationalization                         |
| ~<math.h>~        | Type-specific mathematical functions         |
| ~<setjmp.h>~      | Non-local jumps                              |
| ~<signal.h>~      | Signal-handling functions                    |
| ~<stdalign.h>~    | Alignment of objects                         |
| ~<stdarg.h>~      | Functions with varying numbers of arguments  |
| ~<stdatomic.h>~   | Atomic operations                            |
| ~<stdbool.h>~     | Booleans                                     |
| ~<stddef.h>~      | Basic types and macros                       |
| ~<stdint.h>~      | Exact-width integer types                    |
| ~<stdio.h>~       | Input and output                             |
| ~<stdlib.h>~      | Basic functions                              |
| ~<stdnoreturn.h>~ | Non-returning functions                      |
| ~<string.h>~      | String handling                              |
| ~<tgmath.h>~      | Type-generic mathematical functions          |
| ~<threads.h>~     | Threads and control structures               |
| ~<time.h>~        | Handling time                                |
| ~<uchar.h>~       | Unicode characters                           |
| ~<wchar.h>~       | Wide strings                                 |
| ~<wctype.h>~      | Wide character classification and conversion |

** Derived Data Types

- Arrays :: Combine items that all have the same base type.

  - fixed-length arrays (FLA): ~char letters[26]~

  - variable-length arrays (VLA): ~int values[size]~ where ~size~ = variable

| Feature            | Fixed-Length Array  | Variable-Length Array        |
|--------------------+---------------------+------------------------------|
| size determination | compile time        | run time                     |
| size expression    | constant expression | variable                     |
| memory allocation  | static              | automatic                    |
| scope              | global or local     | local to a function or block |
| availability       | all C standards     | C99: required, C11: optional |

- Structures :: Combine items that may have different base types.

- Pointers :: Entities that refer to an object in memory, are null, or are indeterminate.

- Unions :: Overlay items of different base types in the same memory location.

- typedef :: Creates a new name for an existing type.

*** Arrays

- Arrays are not pointers, although the two are closely related.

- An array in a condition evaluates ~true~. The truth comes from the array decay operation.

- There are array objects but no array values.

- Arrays can't be compared.

- Arrays can't be assigned to.

- *VLAs* can't have initializers.

- *VLAs* can't be declared outside functions.

- The length of an *FLA* is determined by an integer constant expression (*ICE*) or
  by an initializer.

- An array-length specification must be strictly positive.

- An array with a length that is not an integer constant expression is a *VLA*.

- The length of array ~A~ is ~(sizeof A)/(sizeof A[0])~.

- The innermost dimension of an array parameter to a function is lost.

- Don't use the ~sizeof~ operator on array parameters to functions.

- Array parameters behave as if the array is *passed by reference*.

- A string is a 0-terminated array of *char*. An array of *char* without a 0-terminator
  is not a string.

| declaration                         | storage location                      | mutability | scope                | persistence      |
|-------------------------------------+---------------------------------------+------------+----------------------+------------------|
| ~char *string = "literal;"~         | read-only data segment                | immutable  | local/global         | program duration |
| ~const char *string = "literal;"~   | read-only data segment                | immutable  | local/global         | program duration |
| ~const char string[] = "literal;"~  | read-only data segment                | immutable  | local/global         | program duration |
| ~char string[] = "literal;"~        | stack local, read-write static/global | mutable    | local/global         | varies by scope  |
| ~static char string[] = "literal;"~ | read-write data segment               | mutable    | local or file global | program duration |

- Use ~const char string[]~ when you need an immutable, fixed-size string,
  whose size is known at compile time and you do not need to reassign the
  variable to a different string. ~sizeof~ returns the length of the string,
  including its null terminator.

- Use ~const char* string~ when you need a pointer to an immutable string,
  whose pointer can be reassigned to point to different immutable strings.
  This is also the common way to pass constant strings to functions, where
  the array decays into a pointer. ~sizeof~ returns the size of the string's
  pointer.

- Using a string function with a non-string has undefined behavior.

*** Pointers

The term *pointer* stands for a special derived type construct that "points" or "refers" to
something. Pointers are considered scalar values: arithmetic operations are defined for them,
such as offset addition and subtraction. They have state, including a dedicated null state.

- ~*~ (object-of) operator :: In a declaration, the operator declares a new pointer type.
  In an expression, the operator accesses an object to which a pointer refers.

- ~&~ (address-of) operator :: Refers to an object through its address.

- Pointers are either valid, null, or indeterminate.

- Initialization or assignment with ~0~ makes a pointer null.

- In logical expressions, pointers evaluate to ~false~ if they are null.

- Indeterminate pointers lead to undefined behavior. If we can't ensure that a pointer
  is valid, we must at least ensure that it is set to null.

- Always initialize pointers.

- Using the *object-of* operator, (*\star{}*), with an indeterminate or null pointer has
  undefined behavior. An indeterminate pointer might access a random object in memory,
  whereas a null pointer will crash a program. This null pointer behavior is considered
  a feature.

- A valid pointer points to the first element of an array of its reference type.
  In other words, a pointer may reference either a single value in memory or an
  array of unknown length *n*.

#+begin_src c
  void swap(double* p1, double* p2) {
    double temp = *p1;
    *p1 = *p2;
    *p2 = temp;
  }

  // - equivalent ->

  void swap(double p1[static 1], double p2[static 1]) {
    double temp = p1[0];
    p1[0] = p2[0];
    p2[0] = temp;
  }
#+end_src

**** Pointer Arithmetic

#+begin_src c
  // === Sum 1 ===
  //
  //      0              i              length - 1
  //       --------       --------       --------
  // a -> | double | ... | double | ... | double |
  //       --------       --------       --------
  //                          ^
  //                          |
  //                        a + i
  //
  double sum(size_t length, const double* a) {
    double sum = 0.0;
    for (size_t i = 0; i < length; i += 1) {
      sum += *(a + i);
    }
    return sum;
  }

  // === Sum 2 ===
  //
  //      0              i              length - 1
  //       --------       --------       --------
  // a -> | double | ... | double | ... | double | ...
  //       --------       --------       --------
  //                     ^                             ^
  //                     |                             |
  //                     p                           a + length
  //
  double sum(size_t length, const double* a) {
    double sum = 0.0;
    for (const double* p = a; p < a+length; p += 1) {
      sum += *p;
    }
    return sum;
  }

  // === Sum 3 ===
  //
  //      0              i              length - 1
  //       --------       --------       --------
  // a -> | double | ... | double | ... | double | ...
  //       --------       --------       --------
  //                     ^                             ^
  //                     |                             |
  //                     a                            end
  //
  double sum(size_t length, const double* a) {
    double sum = 0.0;
    // Constant pointer to a constant double.
    // Neither the pointer nor double may be mutated.
    for (const double* const end = a + length; a < end; a += 1) {
      sum += *a;
    }
    return sum;
  }

  // === Decrement ===
  pointer--
  // - equivalent ->
  pointer - 1 * sizeof(type)

  // === Increment ===
  pointer++
  // - equivalent ->
  pointer + 1 * sizeof(type)

  //  === Memory ===
  //  -----------------------------------
  // | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
  //  -----------------------------------
  //   <---------------^--------------->
  //  ptr--           ptr             ptr++
  //
  //  where sizeof(type) = 4 bytes

  // === Addition ===
  pointer + 2
  // - equivalent ->
  pointer + 2 * sizeof(type)

  //  === Memory ===
  //  -----------------------------------
  // | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
  //  -----------------------------------
  //   +------------------------------->
  //  ptr                          ptr + 2
  //
  //  where sizeof(type) = 4 bytes

  // === Subtraction ===
  pointer - 2
  // - equivalent ->
  pointer - 2 * sizeof(type)

  //  === Memory ===
  //  -----------------------------------
  // | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
  //  -----------------------------------
  //   <-------------------------------+
  //  ptr - 2                         ptr
  //
  //  where sizeof(type) = 4 bytes
#+end_src

- The length of an array object cannot be reconstructed from a pointer.

- Pointers are not arrays but can refer to arrays.

- Only subtract pointers from elements of an array object — the same array object.
  Calculates the offset between two addresses.

#+begin_example
  // === Pointer Subtraction ===
  pointer 8 - pointer 4 = 4 bytes

  sizeof(integer) = 4 bytes

  4 / sizeof(integer) = offset 1
#+end_example

- All pointer differences have type ~ptrdiff_t~.

- Use ~ptrdiff_t~ to encode signed differences of positions or sizes.

- For printing, cast pointer values to ~void*~, and use the format ~%p~ specifier.

- Accessing an object that has a *trap representation* of its type is undefined behavior.

- trap representation :: A nonsense bit pattern that is unintentionally interpreted as
  a specific type.

- When dereferenced, a pointed-to object must be of the designated type.

- A pointer must point to a valid object or one position beyond a valid object or be null.

- Don't use ~NULL~. It hides more than it clarifies. Generally, use ~0~. Otherwise, use
  the sequence ~(void*)0~ for pointers.

| ~NULL~ expansion      | type               |
|-----------------------+--------------------|
| ~0U~                  | unsigned           |
| ~0~, ~'\0'~, ~enum 0~ | signed             |
| ~0UL~                 | unsigned long      |
| ~0L~                  | signed long        |
| ~0ULL~                | unsigned long long |
| ~0LL~                 | signed long long   |
| ~(void*)0~            | void*              |

- Don't hide pointers in a ~typedef~.

- Array and pointer access are the same. ~A[i]~ is equivalent to ~*(A + i)~

- array-to-pointer decay :: Evaluation of an array ~A~ returns ~&A[0]~. Whenever an array
  occurs that requires a value, it decays to a pointer and all additional information is
  lost.

- For structs, operations ~(*object).x~ and ~object->x~ are equivalent.

- In a function declaration, any array parameter rewrites to a pointer.

- Only the innermost dimension of an array parameter is rewritten. ~A[x][y]~ becomes ~(*A)[y]~.

- Declare length parameters before array parameters.

- The validity of array arguments to functions must be guaranteed by the programmer.

- function decay :: A function ~f~ without a following opening ~(~ decays to a pointer to
  its start.

- Function pointers must be used with their exact type. The calling conventions for functions
  with different prototypes may be quite different and the pointer itself tracks none of this.

- The function call operator ~(...)~ applies to function pointers.

In terms of the abstract state machine, pointer decay is always performed, and a function
is always called via a function pointer:

#+begin_src c
  double f(double x);

  // Equivalent calls to "f". Steps in the abstract state machine.
  f(7);     // Decay -> call
  (&f)(7);  // Address of -> call
  (*f)(7);  // Decay -> dereference -> decay -> call
  (*&f)(7); // Address of -> dereference -> decay -> call
  (&*f)(7); // Decay -> dereference -> address of -> call
#+end_src

*** Structures

#+begin_src c
  // Declare type.
  struct birds {
    char const* jay;
    char const* magpie;
    char const* raven;
    char const* chough;
  };

  struct birds names = {
    .jay    = "Joe",
    .magpie = "Frau",
    .raven  = "Lissy",
    .chough = "Henry",
  };

  // - Equivalent ->

  struct birds names;

  names.jay    = "Joe";
  names.magpie = "Frau";
  names.raven  = "Lissy";
  names.chough = "Henry";

  struct Point {
    double x;
    double y;
  };

  // === or ===

  typedef struct Point {
    double x;
    double y;
  } Point;

  Point coordinate = { 3, 4 };
  // As of C99, struct fields can be set by name.
  Point coordinate = { .x = 3, .y = 4 };
#+end_src

- Omitted structure initializers force the corresponding member to 0.

- A structure's initializer must initialize at least one member.

- Structure parameters are passed by value.

- Structures can be assigned with ~=~ but not compared with ~==~ or ~!=~.

- All struct declarations in a nested declaration have the same scope of visibility.

*** Type Aliases

- Forward-declare a ~struct~ within a ~typedef~ using the same identifier as the tag name.

#+begin_src c
  typedef struct birds birds;
  struct birds { ... };
#+end_src

- A ~typedef~ only creates an alias for a type, but never a new type.

- Identifier names terminating with ~_t~ for ~typdef~ are reserved by convention.

** Flexible Array Members

*Flexible Array Members* are a feature introduced in the C99 standard that allow structs
to contain a variable-sized array, preferably declared as the last member. The structure
must contain at least one named member in addition to the flexible array. The size of
the structure is determined by the static size of its other members plus the
dynamically-allocated memory of the array.

#+begin_src c
  typedef struct Student {
      int id;
      // Convention to store the size of the flexible array.
      int size;
      // Flexible Array Member.
      char name[];
  } Student;

  Student* new_student(int id, char* name) {
      size_t size = sizeof(Student) + sizeof(char) * strlen(name);
      Student* student = malloc(size);

      student->id = id;
      strcpy(student->name, name);
      student->size = size;

      return student;
  }
#+end_src

** The C Memory Model

- Each pointer type is derived from another type, it base type. Each derived type is a distinct
  new type.

- Uniform memory model :: All objects are an assemblage of *bytes*. The ~sizeof~ operator
  measures the size of an object in terms of bytes that it uses. There are three distinct
  types that by definition use exactly one byte of memory: the character type ~char~,
  ~unsigned char~, and ~signed char~.

- ~sizeof(char)~ is ~1~ by definition.

- Every object ~A~ can be viewed as ~unsigned char[sizeof A]~. All objects can be inspected
  and manipulated as if they were arrays of a particular character type.

#+begin_example
  === Two's Complement Signed Representation — Little Endian Object Representation ===

                                          +---------------------------+
                                          |                   30      |
         Semantic Type                    | int32_t  -b₃₁2³¹ + Σ bᵢ2ⁱ |
                                          |                   i=0     |
                                          +---------------------------+
                                                        |
                                                        |
                                                     typedef
                                                        |
                                                        |
                                         +------------------------------+
                                         |                      30      |
            Basic Type                   | signed int  -b₃₁2³¹ + Σ bᵢ2ⁱ |
                                         |                      i=0     |
                                         +------------------------------+
                                                        |
                                                        |
                                               sign representation
                                                        |
                                  [3]           [2]     |     [1]         [0]
                            +-------------+-------------+------------+-----------+
  Binary Representation     | b31 ... b24 | b23 ... b16 | b15 ... b8 | b7 ... b0 |
                            +-------------+-------------+------------+-----------+
                                                        |
                                                        |
                                                    endianness
                                                        |
                               [0]             [1]      |      [2]             [3]
                        +---------------+---------------+---------------+---------------+
  Object Representation | unsigned char | unsigned char | unsigned char | unsigned char |
                        +---------------+---------------+---------------+---------------+
       unsigned char[4]  +0     |        +1     |        +2     |        +3     |
                        +---------------+---------------+---------------+---------------+
       Storage Instance | byte          | byte          | byte          | byte          |
                        +---------------+---------------+---------------+---------------+
                  void*  +0     |        +1     |        +2     |        +3     |
                        +---------------+---------------+---------------+---------------+
     OS/Physical Memory | byte          | byte          | byte          | byte          |
                        +---------------+---------------+---------------+---------------+
#+end_example

- Use the type ~char~ for character and string data.

- Use the type ~unsigned char~ as the atom of all object types.

- The ~sizeof~ operator can be applied to objects and object types.

- The size of all objects of type ~T~ is ~sizeof(T)~.

#+begin_quote
  "Unfortunately, the types that are used to compose all other object types are derived
   from *char*, the type we looked at for the characters of strings. This is merely a
   historical accident, and you shouldn’t read too much into it. In particular, you
   should clearly distinguish the two different use cases."

  — Jens Gustedt
#+end_quote

- With the exclusion of character types, only pointers of the same base type may alias.

*** Pointers to Unspecific Objects

The object representation ~unsigned char[sizeof A]~ of object ~A~ provides access to
memory that is stripped of its original type information. C has a tool to handle such
pointers more generically. These are pointers to non-type ~void~.

- Any object pointer converts to and from ~void*~. Think of a ~void*~ pointer that holds the
  address of an existing object as a pointer into a storage instance that holds that object.
  Object pointers are considered separate from function pointers.

- An object has storage, type, and value.

- Converting an object pointer to ~void*~ and then back to the same type is the identity
  operation. Converting to ~void*~ loses the type information, but the value remains intact.

- Casting :: ~(T)X~ casts an expression of type ~X~ to type ~T~.

#+begin_quote
  "In addition to the implicit conversions that we have seen until now, C also allows us to
   convert explicitly using casts. With a cast, you are telling the compiler that you know
   better than it does, that the type of the object behind the pointer is not what it thinks,
   and that it should shut up. In most use cases that I have come across in real life, the
   compiler was right and the programmer was wrong: even experienced programmers tend to abuse
   casts to hide poor design decisions concerning types."

  — Jens Gustedt
#+end_quote

- Effective Types :: To cope with the different views of the same object that pointers may provide,
  C has introduced the concept of effective types, which heavily restrict how an object can be
  accessed.

- Objects must be accessed through their effective type or through a pointer to a character type.

- Any member of an object that has an effective ~union~ type can be accessed at any time, provided
  the byte representation amounts to a valid value of the access type.

- The effective type of a variable or compound literal is the type of its declaration.

- Variables and compound literals must be accessed through their declared type or through a
  pointer to a character type. Any object can be seen as being composed of ~unsigned char~,
  but no array of unsigned chars can be used through another type.

- Memory can be aligned differently according to the need for a specific data type.
  Most non-character types must start at a particular byte position — usually a word boundary.
  Only particular arrays of ~unsigned char~ can represent particular object types.

** Storage

- Static :: Either objects defined in file scope or variables declared within function blocks
  that are prefixed with the storage specifier ~static~. These object lifetimes span the entire
  program execution, either being completely defined at compile time or resolved by a system's
  startup procedure.

| class                  | scope                                  | duration                             |
|------------------------+----------------------------------------+--------------------------------------|
| Static Local Variable  | Function block                         | Retains value between function calls |
| Global Variable        | Accessible everywhere, unless shadowed | Entire duration of program           |
| Static Global Variable | File where it is declared              | Entire duration of program           |

- Automatic :: Any block-scope variables that are not declared ~static~, block-scope compound
  literals, and some temporary objects that are returned by function calls. They are typically
  local variables created when program execution enters the scope in which they are defined
  and are destroyed when that scope is exited. Such object lifetimes can be determined by the
  compiler.

  - Unless they are VLA or temporary objects, automatic objects have a lifetime corresponding
    to the execution of their block of definition.

  - For an object that is not VLA, lifetime starts when the scope of the definition is entered,
    and it ends when that scope is left.

  - Initializers of automatic variables and compound literals are evaluated each time the
    definition is met.

  - Each recursive call to a function creates a new local instance of an automatic object.

  - The ~&~ operator is not allowed for variables declared with ~register~, meaning variables
    declared with ~register~ can't alias.

- Allocated :: Objects that are created and destroyed at runtime via ~malloc~ and related
  allocation functions. These storage instances are byte arrays and do not have interpretation
  as objects. They acquire an effective type only after something is stored inside them. Each
  newly-allocated array returns ~void*~, a pointer without type information. Assignment converts
  the pointer to its effective type.

  - ~malloc~ indicates failure by a returning a null pointer value — typically ~(void*)0~.

  - For every allocation, there must be a ~free~. Only call ~free~ with pointers as they
    are returned by ~malloc~, ~calloc~, ~aligned_alloc~, or ~realloc~.

#+begin_src c
  #include <stdlib.h>

  void* malloc(size_t size);
  void* free(void* ptr);
  // calloc (clear allocate) sets all bits of new storage to 0.
  void* calloc(size_t nmemb, size_t size);
  void* realloc(void* ptr, size_t size);
  void* aligned_alloc(size_t alignment, size_t size);
#+end_src

| storage class   | lifetime                      | scope                     | default initializer    |
|-----------------+-------------------------------+---------------------------+------------------------|
| ~auto~          | block (stack)                 | block                     | uninitialized          |
| ~register~      | block (stack or CPU register) | block                     | uninitialized          |
| ~static~        | program                       | block or unit compilation | zero                   |
| ~extern~        | program                       | global (entire program)   | zero                   |
| ~_Thread_local~ | thread                        |                           |                        |
| none            | dynamic (heap)                |                           | zero if using ~calloc~ |

** State Machines: C to Assembly

*** Numbers Loop

**** C Source Code

#+begin_src c
  #define BOUND 10

  int add(int x, int y) { return x + y; }

  int main(int argc, const char* argv[]) {
      int sum = 0;
      int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
      for(int index = 0; index < BOUND; index += 1) {
          sum = add(sum, numbers[index]);
      }
      return 0;
  }
#+end_src

**** Assembly Output ~x86-64 gcc 14.2~

#+begin_src asm
  add:
          push    rbp                           ; <+
          mov     rbp, rsp                      ;  |
          mov     DWORD PTR [rbp-4], edi        ;  |- Setup callframe for "add" function;
          mov     DWORD PTR [rbp-8], esi        ;  |
          mov     edx, DWORD PTR [rbp-4]        ;  |
          mov     eax, DWORD PTR [rbp-8]        ; <+
          add     eax, edx                      ; <-- Call the add operator.
          pop     rbp                           ; <-- Return to caller of "add" function.
          ret                                   ; <+
  main:
          push    rbp                           ; <+
          mov     rbp, rsp                      ;  |
          sub     rsp, 64                       ;  |- Setup up callframe for "main" function.
          mov     DWORD PTR [rbp-52], edi       ;  |
          mov     QWORD PTR [rbp-64], rsi       ; <+
          mov     DWORD PTR [rbp-4], 0          ; <-- Move 0 into "sum".
          mov     DWORD PTR [rbp-48], 1         ; <+
          mov     DWORD PTR [rbp-44], 2         ;  |
          mov     DWORD PTR [rbp-40], 3         ;  |
          mov     DWORD PTR [rbp-36], 4         ;  |
          mov     DWORD PTR [rbp-32], 5         ;  |- Setup "numbers" array.
          mov     DWORD PTR [rbp-28], 6         ;  |
          mov     DWORD PTR [rbp-24], 7         ;  |
          mov     DWORD PTR [rbp-20], 8         ;  |
          mov     DWORD PTR [rbp-16], 9         ;  |
          mov     DWORD PTR [rbp-12], 10        ; <+
          mov     DWORD PTR [rbp-8], 0          ; <- Start of "for" loop. Initialize "index".
          jmp     .L4                           ; <- Jump to predicate.
  .L5:
          mov     eax, DWORD PTR [rbp-8]        ; <-- Move "index" into register "eax".
          cdqe                                  ; <-- RAX := SignExtend(EAX)
          mov     edx, DWORD PTR [rbp-48+rax*4] ; <-- Index into "numbers" array.
          mov     eax, DWORD PTR [rbp-4]        ; <-- Move "sum" into "eax" register.
          mov     esi, edx                      ; <-- Move "numbers[index]" into "esi" register
          mov     edi, eax                      ; <-- Move "sum" from "eax" register to "edi" register.
          call    add                           ; <-- Call "add" function.
          mov     DWORD PTR [rbp-4], eax        ; <-- Move result into "sum" register.
          add     DWORD PTR [rbp-8], 1          ; <-- Add 1 into "index" register
  .L4:
          cmp     DWORD PTR [rbp-8], 9          ; <-- Compare "index" to "BOUND".
          jle     .L5                           ; <-- Jumps to body of "for" loop if condition is satisfied.
          mov     eax, 0                        ; <-- Return success code 0 from "main".
          leave                                 ; <-- Exit "main".
          ret                                   ; <+
#+end_src

*** Copy String

**** C Source Code

#+begin_src c
  #include <stdlib.h>

  const char name[] = "Jared Clarke";

  char* copy_string(char* destination, const char* source) {
      char* base = destination;
      while (*source != '\0') {
          *destination = *source;
          source += 1;
          destination += 1;
      }
      *destination = '\0';
      return base;
  }

  int main(int argc, const char* argv[]) {
      char* text = malloc(sizeof(name));
      copy_string(text, name);
      free(text);
      text = NULL;
      return 0;
  }
#+end_src

**** Assembly Output ~x86-64 gcc 15.2~

#+begin_src asm
  name:
          .string "Jared Clarke"           ; <- string constant

  copy_string:
          push    rbp                      ; <+
          mov     rbp, rsp                 ;  |- Set up state for "copy_string" function.
          mov     QWORD PTR [rbp-24], rdi  ;  |
          mov     QWORD PTR [rbp-32], rsi  ; <+
          mov     rax, QWORD PTR [rbp-24]  ; <-- Save the first pointer to "destination".
          mov     QWORD PTR [rbp-8], rax   ; <+
          jmp     .L2                      ; <-- Jump to "while" loop.
  .L3:
          mov     rax, QWORD PTR [rbp-32]  ; <+
          movzx   edx, BYTE PTR [rax]      ;  |- Copy value from "source" to "destination".
          mov     rax, QWORD PTR [rbp-24]  ;  |
          mov     BYTE PTR [rax], dl       ; <+
          add     QWORD PTR [rbp-32], 1    ; <-- Increment pointer to "source".
          add     QWORD PTR [rbp-24], 1    ; <-- Increment pointer to "destination".
  .L2:
          mov     rax, QWORD PTR [rbp-32]  ; <+
          movzx   eax, BYTE PTR [rax]      ;  |- If predicate is satisfied, jump to "while" block.
          test    al, al                   ;  |
          jne     .L3                      ; <+
          mov     rax, QWORD PTR [rbp-24]  ; <+- Append '\0' to end of "destination" array.
          mov     BYTE PTR [rax], 0        ; <+
          mov     rax, QWORD PTR [rbp-8]   ; <-- Return first pointer to "destination".
          pop     rbp                      ; <+- Return to caller of "copy_string".
          ret                              ; <+

  main:
          push    rbp                      ; <+
          mov     rbp, rsp                 ;  |
          sub     rsp, 32                  ;  |- Set up state for "main" function.
          mov     DWORD PTR [rbp-20], edi  ;  |
          mov     QWORD PTR [rbp-32], rsi  ; <+
          mov     edi, 13                  ; <+
          call    malloc                   ;  |- Allocate a 13-part array of type "char".
          mov     QWORD PTR [rbp-8], rax   ; <+
          mov     rax, QWORD PTR [rbp-8]   ; <+
          mov     esi, OFFSET FLAT:.name   ;  |- Call "copy_string".
          mov     rdi, rax                 ;  |
          call    copy_string              ; <+
          mov     rax, QWORD PTR [rbp-8]   ; <+
          mov     rdi, rax                 ;  |- Free memory for "text".
          call    free                     ; <+
          mov     QWORD PTR [rbp-8], 0     ; <-- Set "text" pointer to NULL.
          mov     eax, 0                   ; <-- Return success code 0 from "main" function.
          leave                            ; <-- Exit "main" function.
          ret                              ; <+
#+end_src

*** Add Vectors

**** C Source Code

#+begin_src c
  typedef struct Vec2 {
      float x;
      float y;
  } Vec2;

  Vec2 add(Vec2 v1, Vec2 v2) {
      Vec2 result = { v1.x + v2.x, v1.y + v2.y };
      return result;
  }

  int main(int argc, const char* argv[]) {
      Vec2 v1 = { 3.0, 4.0 };
      Vec2 v2 = { 7.0, 11.0 };
      Vec2 v3 = add(v1, v2);
      return 0;
  }
#+end_src

**** Assembly Output ~x86-64 gcc 14.2~

#+begin_src asm
  add:
          push    rbp                       ; <+
          mov     rbp, rsp                  ;  |- Set up state for "add" function.
          movq    QWORD PTR [rbp-24], xmm0  ;  |
          movq    QWORD PTR [rbp-32], xmm1  ; <+
          movss   xmm1, DWORD PTR [rbp-24]  ; <+
          movss   xmm0, DWORD PTR [rbp-32]  ;  |
          addss   xmm0, xmm1                ;  |
          movss   DWORD PTR [rbp-8], xmm0   ;  |- Add "v1" to "v2" and place sum in "result".
          movss   xmm1, DWORD PTR [rbp-20]  ;  |
          movss   xmm0, DWORD PTR [rbp-28]  ;  |
          addss   xmm0, xmm1                ;  |
          movss   DWORD PTR [rbp-4], xmm0   ; <+
          mov     rax, QWORD PTR [rbp-8]    ; <-- Return "result".
          movq    xmm0, rax                 ; <+
          pop     rbp                       ;  |- Return to caller of "add" function.
          ret                               ; <+
  main:
          push    rbp                       ; <+
          mov     rbp, rsp                  ;  |
          sub     rsp, 48                   ;  |- Set up state for "main" function.
          mov     DWORD PTR [rbp-36], edi   ;  |
          mov     QWORD PTR [rbp-48], rsi   ; <+
          movss   xmm0, DWORD PTR .LC0[rip] ; <+
          movss   DWORD PTR [rbp-8], xmm0   ;  |- Declare and initialize "v1".
          movss   xmm0, DWORD PTR .LC1[rip] ;  |
          movss   DWORD PTR [rbp-4], xmm0   ; <+
          movss   xmm0, DWORD PTR .LC2[rip] ; <+
          movss   DWORD PTR [rbp-16], xmm0  ;  |- Declare and initialize "v2".
          movss   xmm0, DWORD PTR .LC3[rip] ;  |
          movss   DWORD PTR [rbp-12], xmm0  ; <+
          movq    xmm0, QWORD PTR [rbp-16]  ; <+
          mov     rax, QWORD PTR [rbp-8]    ;  |
          movdqa  xmm1, xmm0                ;  |
          movq    xmm0, rax                 ;  |- Call "add" on "v1" and "v2" and place result in "v3".
          call    add                       ;  |
          movq    rax, xmm0                 ;  |
          mov     QWORD PTR [rbp-24], rax   ; <+
          mov     eax, 0                    ; <-- Return success code 0 from "main" function.
          leave                             ; <-- Exit "main" function.
          ret                               ; <+
  .LC0:
          .long   1077936128                ; <--  3.0f
  .LC1:                                     ;
          .long   1082130432                ; <--  4.0f
  .LC2:                                     ;
          .long   1088421888                ; <--  7.0f
  .LC3:                                     ;
          .long   1093664768                ; <-- 11.0f
#+end_src

** Safety

- All block-scope variables should be initialized.

- Dynamic allocation should be done with ~calloc~ instead of ~malloc~.

- Dedicated initialization functions should be implemented for dynamically-allocated
  data structures.

- Functions that receive pointers should use array syntax and distinguish different cases:

#+begin_src c
  // Pointer to a single object, where the pointer is expected
  // to be non-null.
  void function(double a[static 1]);

  // Pointer to a collection of objects of known number, where the
  // pointer is expected to be non-null.
  void function(double a[static 7]);

  // Pointer to a collection of objects of unknown number, where the
  // pointer is expected to be non-null.
  void function(size_t n, double a[n]);

  // Pointer to a single object or a null pointer. Such a function
  // must guarantee execution remains in a defined state when
  // receiving a null pointer.
  void function(double* a);
#+end_src

- Avoid taking the address of block-scope (local) variables.

- Use unsigned integer types for loop indices. Handle wrap-around explicitly.
