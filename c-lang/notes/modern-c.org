* Modern C

** Sources

| source              | author       |
|---------------------+--------------|
| *Modern C*          | Jens Gustedt |
| *C Syntax*          | Wikipedia    |
| *C Reference*       | cppreference |
| *Compiler Explorer* | godbolt.org  |

** Primary Types

The C language provides the four basic arithmetic type specifiers ~char~, ~int~, ~float~,
and ~double~, and the modifiers ~signed~, ~unsigned~, ~short~, and ~long~.

The type ~size_t~ represents values in range ~[0, SIZE_MAX]~. Depending on the platform ~SIZE_MAX~
is equal to ~2^16 - 1~, ~2^32 - 1~, or ~2^64 - 1~. ~SIZE_MAX~ is contained in ~stdint.h~. ~size_t~
is an unsigned integer type.

Narrow types must be promoted to a wider type — usually a ~signed int~ — before they are used
in an arithmetic expression.

- Use ~size_t~ for sizes, cardinalities, or ordinals.

- Use ~unsigned~ for small, non-negative quantities.

- Use ~signed~ for small quantities that bear a sign.

- Use ~ptrdiff_t~ for large differences that bear a sign.

- Use ~double~ for floating-point calculations.

- Use ~double complex~ for complex calculations.

#+begin_example
  | class                     | systematic name      | other name          | rank |
  |---------------------------+----------------------+---------------------+------|<
  |                           | _Bool                | bool                | 0    | |
  |                           | unsigned char        |                     | 1    | +-+
  |                unsigned   | unsigned short       |                     | 2    | | |
  |                           |----------------------+---------------------+------|<  |
  |                           | unsigned int         | unsigned            | 3    |   |
  |                           | unsigned long        |                     | 4    |   +- narrow types
  |                           | unsigned long long   |                     | 5    |   |
  |                -----------+----------------------+---------------------+------|<  |
  | integers       [un]signed | char                 |                     | 1    | | |
  |                -----------+----------------------+---------------------+------| +-+
  |                           | signed char          |                     | 1    | |
  |                           | signed short         | short               | 2    | |
  |                           |----------------------+---------------------+------|<
  |                signed     | signed int           | signed or int       | 3    |
  |                           | signed long          | long                | 4    |
  |                           | signed long long     | long long           | 5    |
  |---------------------------+----------------------+---------------------+------|
  |                           | float                |                     |      |
  |                real       | double               |                     |      |
  |                           | long double          |                     |      |
  | floating point            |----------------------+---------------------+------|
  |                           | float _Complex       | float complex       |      |
  |                complex    | double _Complex      | double complex      |      |
  |                           | long double _Complex | long double complex |      |
#+end_example

** Semantic Arithmetic Types

| type        | header     | meaning                              |
|-------------+------------+--------------------------------------|
| ~size_t~    | ~stddef.h~ | type for "sizes" and cardinalities   |
|-------------+------------+--------------------------------------|
| ~ptrdiff_t~ | ~stddef.h~ | type for size differences            |
|-------------+------------+--------------------------------------|
| ~uint8_t~   | ~stdint.h~ | 8-bit unsigned integer               |
|-------------+------------+--------------------------------------|
| ~uint16_t~  | ~stdint.h~ | 16-bit unsigned integer              |
|-------------+------------+--------------------------------------|
| ~uint32_t~  | ~stdint.h~ | 32-bit unsigned integer              |
|-------------+------------+--------------------------------------|
| ~uint64_t~  | ~stdint.h~ | 64-bit unsigned integer              |
|-------------+------------+--------------------------------------|
| ~uintmax_t~ | ~stdint.h~ | maximum-width unsigned integer       |
|-------------+------------+--------------------------------------|
| ~int8_t~    | ~stdint.h~ | 8-bit signed integer                 |
|-------------+------------+--------------------------------------|
| ~int16_t~   | ~stdint.h~ | 16-bit signed integer                |
|-------------+------------+--------------------------------------|
| ~int32_t~   | ~stdint.h~ | 32-bit signed integer                |
|-------------+------------+--------------------------------------|
| ~int64_t~   | ~stdint.h~ | 64-bit signed integer                |
|-------------+------------+--------------------------------------|
| ~intmax_t~  | ~stdint.h~ | maximum-width signed integer         |
|-------------+------------+--------------------------------------|
| ~time_t~    | ~time.h~   | calendar time in seconds since epoch |
|-------------+------------+--------------------------------------|
| ~clock_t~   | ~time.h~   | processor time                       |

** Value Operators

| operator          | alt-name | form    | type a           | type b     | type result | operation      |
|-------------------+----------+---------+------------------+------------+-------------+----------------|
|                   |          | a       | narrow           |            | Wide        | promotion      |
| + -               |          | a@b     | pointer          | integer    | pointer     | arithmetic     |
| + - * /           |          | a@b     | arithmetic       | arithmetic | arithmetic  | arithmetic     |
| + -               |          | @a      | arithmetic       |            | arithmetic  | arithmetic     |
| %                 |          | a@b     | integer          | integer    | integer     | arithmetic     |
| ~                 | compl    | @a      | integer          |            | integer     | bitwise        |
| &                 | bitand   | a@b     | integer          | integer    | integer     | bitwise        |
| \vert{}           | bitor    | a@b     | integer          | integer    | integer     | bitwise        |
| ^                 | xor      | a@b     | integer          | integer    | integer     | bitwise        |
| << >>             |          | a@b     | integer          | positive   | integer     | bitwise        |
| == < > <= >=      |          | a@b     | scalar           | scalar     | 0, 1        | comparison     |
| !=                | not_eq   | a@b     | scalar           | scalar     | 0, 1        | comparsion     |
|                   | !!a      | a       | scalar           |            | 0, 1        | logic          |
| !a                | not      | @a      | scalar           |            | 0, 1        | logic          |
| && \vert{}\vert{} | and or   | a@b     | scalar           | scalar     | 0, 1        | logic          |
| .                 |          | a@m     | struct           |            | value       | member         |
| \star{}           |          | @a      | pointer          |            | object      | reference      |
| []                |          | a[b]    | pointer          | integer    | object      | member         |
| ->                |          | a@m     | struct pointer   |            | object      | member         |
| ()                |          | a(b...) | function pointer |            | value       | call           |
| sizeof            |          | @ a     | none             |            | size_t      | size, ICE      |
| _Alignof          | alignof  | @(a)    | none             |            | size_t      | alignment, ICE |

** Object Operators

| operator    | alt-name | form  | type                  | result  | operation      |
|-------------+----------+-------+-----------------------+---------+----------------|
|             |          | o     | array*                | pointer | array decay    |
|             |          | o     | function              | pointer | function decay |
|             |          | o     | other                 | value   | evaluation     |
| =           |          | o@a   | non-array             | value   | assignment     |
| += -= *= /= |          | o@a   | arithmetic            | value   | arithmetic     |
| += -=       |          | o@a   | pointer               | value   | arithmetic     |
| %=          |          | o@a   | integer               | value   | arithmetic     |
| ++ --       |          | @o o@ | arithmetic or pointer | value   | arithmetic     |
| &=          | and_eq   | o@a   | integer               | value   | bitwise        |
| \vert{}=    | or_eq    | o@a   | integer               | value   | bitwise        |
| ^=          | xor_eq   | o@a   | integer               | value   | bitwise        |
| <<= >>=     |          | o@a   | integer               | value   | bitwise        |
| .           |          | o@m   | struct                | object  | member         |
| []          |          | o[a]  | array*                | object  | member         |
| &           |          | @o    | any*                  | pointer | address        |
| sizeof      |          | @ o   | data object, non-VLA  | size_t  | size, ICE      |
| sizeof      |          | @ o   | VLA                   | size_t  | size           |
| _Alignof    | alignof  | @(o)  | non-function          | size_t  | alignment, ICE |

** Type Operators

| operator   | alt-name   | form             | type T | operation     |
|------------+------------+------------------+--------+---------------|
| ~sizeof~   |            | ~sizeof(T)~      | any    | size          |
| ~_Alignof~ | ~alignof~  | ~_Alignof(T)~    | any    | alignment     |
|            | ~offsetof~ | ~offsetof(T, m)~ | struct | member offset |

** The C Libraries

| name              | description                                  |
|-------------------+----------------------------------------------|
| ~<assert.h>~      | Runtime condition assertion                  |
| ~<complex.h>~     | Complex numbers                              |
| ~<ctype.h>~       | Character classification and conversion      |
| ~<errno.h>~       | Error codes                                  |
| ~<fenv.h>~        | Floating-point environment                   |
| ~<float.h>~       | Properties of floating-point types           |
| ~<inttypes.h>~    | Formatting conversion of integer types       |
| ~<iso646.h>~      | Alternative spellings for operators          |
| ~<limits.h>~      | Properties of integer types                  |
| ~<locale.h>~      | Internationalization                         |
| ~<math.h>~        | Type-specific mathematical functions         |
| ~<setjmp.h>~      | Non-local jumps                              |
| ~<signal.h>~      | Signal-handling functions                    |
| ~<stdalign.h>~    | Alignment of objects                         |
| ~<stdarg.h>~      | Functions with varying numbers of arguments  |
| ~<stdatomic.h>~   | Atomic operations                            |
| ~<stdbool.h>~     | Booleans                                     |
| ~<stddef.h>~      | Basic types and macros                       |
| ~<stdint.h>~      | Exact-width integer types                    |
| ~<stdio.h>~       | Input and output                             |
| ~<stdlib.h>~      | Basic functions                              |
| ~<stdnoreturn.h>~ | Non-returning functions                      |
| ~<string.h>~      | String handling                              |
| ~<tgmath.h>~      | Type-generic mathematical functions          |
| ~<threads.h>~     | Threads and control structures               |
| ~<time.h>~        | Handling time                                |
| ~<uchar.h>~       | Unicode characters                           |
| ~<wchar.h>~       | Wide strings                                 |
| ~<wctype.h>~      | Wide character classification and conversion |

** Derived Data Types

- Arrays :: Combine items that all have the same base type.

  - fixed-length arrays (FLA)

  - variable-length arrays (VLA)

- Structures :: Combine items that may have different base types.

- Pointers :: Entities that refer to an object in memory, are null, or are indeterminate.

- Unions :: Overlay items of different base types in the same memory location.

- typedef :: Creates a new name for an existing type.

*** Arrays

- Arrays are not pointers, although the two are closely related.

- An array in a condition evaluates ~true~. The truth comes from the array decay operation.

- There are array objects but no array values.

- Arrays can't be compared.

- Arrays can't be assigned to.

- *VLAs* can't have initializers.

- *VLAs* can't be declared outside functions.

- The length of an *FLA* is determined by an integer constant expression (*ICE*) or
  by an initializer.

- An array-length specification must be strictly positive.

- An array with a length that is not an integer constant expression is a *VLA*.

- The length of array ~A~ is ~(sizeof A)/(sizeof A[0])~.

- The innermost dimension of an array parameter to a function is lost.

- Don't use the ~sizeof~ operator on array parameters to functions.

- Array parameters behave as if the array is *passed by reference*.

- A string is a 0-terminated array of *char*. An array of *char* without a 0-terminator
  is not a string.

#+begin_src c
  // Equivalent declarations.
  char ted1    = "ted";
  char ted2    = { "ted" };
  char ted3    = { 't', 'e', 'd', '\0' };
  char ted4[4] = { 't', 'e', 'd' };

  // Not a string.
  char ted5[3] = { 't', 'e', 'd' };
#+end_src

- Using a string function with a non-string has undefined behavior.

*** Pointers

The term *pointer* stands for a special derived type construct that "points" or "refers" to
something. Pointers are considered scalar values: arithmetic operations are defined for them,
such as offset addition and subtraction. They have state, including a dedicated null state.

- ~*~ (object-of) operator :: In a declaration, the operator declares a new pointer type.
  In an expression, the operator accesses an object to which a pointer refers.

- ~&~ (address-of) operator :: Refers to an object through its address.

- Pointers are either valid, null, or indeterminate.

- Initialization or assignment with ~0~ makes a pointer null.

- In logical expressions, pointers evaluate to ~false~ if they are null.

- Indeterminate pointers lead to undefined behavior. If we can't ensure that a pointer
  is valid, we must at least ensure that it is set to null.

- Always initialize pointers.

- Using the *object-of* operator, (*\star{}*), with an indeterminate or null pointer has
  undefined behavior. An indeterminate pointer might access a random object in memory,
  whereas a null pointer will crash a program. This null pointer behavior is considered
  a feature.

- A valid pointer points to the first element of an array of its reference type.
  In other words, a pointer may reference either a single value in memory or an
  array of unknown length *n*.

#+begin_src c
  void swap(double* p1, double* p2) {
    double temp = *p1;
    *p1 = *p2;
    *p2 = temp;
  }

  // - equivalent ->

  void swap(double p1[static 1], double p2[static 1]) {
    double temp = p1[0];
    p1[0] = p2[0];
    p2[0] = temp;
  }
#+end_src

**** Pointer Addition

#+begin_src c
  // === Sum 1 ===
  //
  //      0              i              length - 1
  //       --------       --------       --------
  // a -> | double | ... | double | ... | double |
  //       --------       --------       --------
  //                          ^
  //                          |
  //                        a + i
  //
  double sum1(size_t length, double const* a) {
    double sum = 0.0;
    for (size_t i = 0; i < length; i += 1) {
      sum += *(a + i);
    }
    return sum;
  }

  // === Sum 2 ===
  //
  //      0              i              length - 1
  //       --------       --------       --------
  // a -> | double | ... | double | ... | double | ...
  //       --------       --------       --------
  //                     ^                             ^
  //                     |                             |
  //                     p                           a + length
  //
  double sum2(size_t length, double const* a) {
    double sum = 0.0;
    for (double const* p = a; p < a+length; p += 1) {
      sum += *p;
    }
    return sum;
  }

  // === Sum 3 ===
  //
  //      0              i              length - 1
  //       --------       --------       --------
  // a -> | double | ... | double | ... | double | ...
  //       --------       --------       --------
  //                     ^                             ^
  //                     |                             |
  //                     a                            end
  //
  double sum3(size_t length, double const* a) {
    double sum = 0.0;
    for (double const*const end = a + length; a < end; a += 1) {
      sum += *a;
    }
    return sum;
  }

  // === Side Note ===
  // When manipulating arrays through functions, array notation should be preferred.
  // Such conventions clarify the relationship between length and pointer arguments.
  //
  // double sum(size_t length, double const a[length]);
#+end_src

- The length of an array object cannot be reconstructed from a pointer.

- Pointers are not arrays but can refer to arrays.

- Only subtract pointers from elements of an array object — the same array object.

- All pointer differences have type ~ptrdiff_t~.

- Use ~ptrdiff_t~ to encode signed differences of positions or sizes.

- For printing, cast pointer values to ~void*~, and use the format ~%p~ specifier.

- Accessing an object that has a *trap representation* of its type is undefined behavior.

- trap representation :: A nonsense bit pattern that is unintentionally interpreted as
  a specific type.

- When dereferenced, a pointed-to object must be of the designated type.

- A pointer must point to a valid object or one position beyond a valid object or be null.

- Don't use ~NULL~. It hides more than it clarifies. Generally, use ~0~. Otherwise, use
  the sequence ~(void*)0~ for pointers.

| ~NULL~ expansion      | type               |
|-----------------------+--------------------|
| ~0U~                  | unsigned           |
| ~0~, ~'\0'~, ~enum 0~ | signed             |
| ~0UL~                 | unsigned long      |
| ~0L~                  | signed long        |
| ~0ULL~                | unsigned long long |
| ~0LL~                 | signed long long   |
| ~(void*)0~            | void*              |

- Don't hide pointers in a ~typedef~.

- Array and pointer access are the same. ~A[i]~ is equivalent to ~*(A + i)~

- array-to-pointer decay :: Evaluation of an array ~A~ returns ~&A[0]~. Whenever an array
  occurs that requires a value, it decays to a pointer and all additional information is
  lost.

- For structs, operations ~(*object).x~ and ~object->x~ are equivalent.

- In a function declaration, any array parameter rewrites to a pointer.

- Only the innermost dimension of an array parameter is rewritten. ~A[x][y]~ becomes ~(*A)[y]~.

- Declare length parameters before array parameters.

- The validity of array arguments to functions must be guaranteed by the programmer.

- function decay :: A function ~f~ without a following opening ~(~ decays to a pointer to
  its start.

- Function pointers must be used with their exact type. The calling conventions for functions
  with different prototypes may be quite different and the pointer itself tracks none of this.

- The function call operator ~(...)~ applies to function pointers.

In terms of the abstract state machine, pointer decay is always performed, and a function
is always called via a function pointer:

#+begin_src c
  double f(double x);

  // Equivalent calls to "f". Steps in the abstract state machine.
  f(7);     // Decay -> call
  (&f)(7);  // Address of -> call
  (*f)(7);  // Decay -> dereference -> decay -> call
  (*&f)(7); // Address of -> dereference -> decay -> call
  (&*f)(7); // Decay -> dereference -> address of -> call
#+end_src

*** Structures

#+begin_src c
  // Declare type.
  struct birds {
    char const* jay;
    char const* magpie;
    char const* raven;
    char const* chough;
  };

  // Instantiate a "birds" struct and assign to "names".
  struct birds names = {
    .jay    = "Joe",
    .magpie = "Frau",
    .raven  = "Lissy",
    .chough = "Henry",
  };

  // - Equivalent ->

  struct birds names;

  names.jay    = "Joe";
  names.magpie = "Frau";
  names.raven  = "Lissy";
  names.chough = "Henry";
#+end_src

- Omitted structure initializers force the corresponding member to 0.

- A structure's initializer must initialize at least one member.

- Structure parameters are passed by value.

- Structures can be assigned with ~=~ but not compared with ~==~ or ~!=~.

- All struct declarations in a nested declaration have the same scope of visibility.

*** Type Aliases

- Forward-declare a ~struct~ within a ~typedef~ using the same identifier as the tag name.

#+begin_src c
  typedef struct birds birds;
  struct birds { ... };
#+end_src

- A ~typedef~ only creates an alias for a type, but never a new type.

- Identifier names terminating with ~_t~ for ~typdef~ are reserved by convention.

** The C Memory Model

- Each pointer type is derived from another type, it base type. Each derived type is a distinct
  new type.

- Uniform memory model :: All objects are an assemblage of *bytes*. The ~sizeof~ operator
  measures the size of an object in terms of bytes that it uses. There are three distinct
  types that by definition use exactly one byte of memory: the character type ~char~,
  ~unsigned char~, and ~signed char~.

- ~sizeof(char)~ is ~1~ by definition.

- Every object ~A~ can be viewed as ~unsigned char[sizeof A]~. All objects can be inspected
  and manipulated as if they were arrays of a particular character type.

#+begin_example
  === Two's Complement Signed Representation — Little Endian Object Representation ===

                                          +---------------------------+
                                          |                   30      |
         Semantic Type                    | int32_t  -b₃₁2³¹ + Σ bᵢ2ⁱ |
                                          |                   i=0     |
                                          +---------------------------+
                                                        |
                                                        |
                                                     typedef
                                                        |
                                                        |
                                         +------------------------------+
                                         |                      30      |
            Basic Type                   | signed int  -b₃₁2³¹ + Σ bᵢ2ⁱ |
                                         |                      i=0     |
                                         +------------------------------+
                                                        |
                                                        |
                                               sign representation
                                                        |
                                  [3]           [2]     |     [1]         [0]
                            +-------------+-------------+------------+-----------+
  Binary Representation     | b31 ... b24 | b23 ... b16 | b15 ... b8 | b7 ... b0 |
                            +-------------+-------------+------------+-----------+
                                                        |
                                                        |
                                                    endianness
                                                        |
                               [0]             [1]      |      [2]             [3]
                        +---------------+---------------+---------------+---------------+
  Object Representation | unsigned char | unsigned char | unsigned char | unsigned char |
                        +---------------+---------------+---------------+---------------+
       unsigned char[4]  +0     |        +1     |        +2     |        +3     |
                        +---------------+---------------+---------------+---------------+
       Storage Instance | byte          | byte          | byte          | byte          |
                        +---------------+---------------+---------------+---------------+
                  void*  +0     |        +1     |        +2     |        +3     |
                        +---------------+---------------+---------------+---------------+
     OS/Physical Memory | byte          | byte          | byte          | byte          |
                        +---------------+---------------+---------------+---------------+
#+end_example

- Use the type ~char~ for character and string data.

- Use the type ~unsigned char~ as the atom of all object types.

- The ~sizeof~ operator can be applied to objects and object types.

- The size of all objects of type ~T~ is ~sizeof(T)~.

#+begin_quote
  "Unfortunately, the types that are used to compose all other object types are derived
   from *char*, the type we looked at for the characters of strings. This is merely a
   historical accident, and you shouldn’t read too much into it. In particular, you
   should clearly distinguish the two different use cases."

  — Jens Gustedt
#+end_quote

- With the exclusion of character types, only pointers of the same base type may alias.

*** Pointers to Unspecific Objects

The object representation ~unsigned char[sizeof A]~ of object ~A~ provides access to
memory that is stripped of its original type information. C has a tool to handle such
pointers more generically. These are pointers to non-type ~void~.

- Any object pointer converts to and from ~void*~. Think of a ~void*~ pointer that holds the
  address of an existing object as a pointer into a storage instance that holds that object.
  Object pointers are considered separate from function pointers.

- An object has storage, type, and value.

- Converting an object pointer to ~void*~ and then back to the same type is the identity
  operation. Converting to ~void*~ loses the type information, but the value remains intact.

- Casting :: ~(T)X~ casts an expression of type ~X~ to type ~T~.

#+begin_quote
  "In addition to the implicit conversions that we have seen until now, C also allows us to
   convert explicitly using casts. With a cast, you are telling the compiler that you know
   better than it does, that the type of the object behind the pointer is not what it thinks,
   and that it should shut up. In most use cases that I have come across in real life, the
   compiler was right and the programmer was wrong: even experienced programmers tend to abuse
   casts to hide poor design decisions concerning types."

  — Jens Gustedt
#+end_quote

- Effective Types :: To cope with the different views of the same object that pointers may provide,
  C has introduced the concept of effective types, which heavily restrict how an object can be
  accessed.

- Objects must be accessed through their effective type or through a pointer to a character type.

- Any member of an object that has an effective ~union~ type can be accessed at any time, provided
  the byte representation amounts to a valid value of the access type.

- The effective type of a variable or compound literal is the type of its declaration.

- Variables and compound literals must be accessed through their declared type or through a
  pointer to a character type. Any object can be seen as being composed of ~unsigned char~,
  but no array of unsigned chars can be used through another type.

- Memory can be aligned differently according to the need for a specific data type.
  Most non-character types must start at a particular byte position — usually a word boundary.
  Only particular arrays of ~unsigned char~ can represent particular object types.

** Storage

- Static :: Either objects defined in file scope or variables declared within function blocks
  that are prefixed with the storage specifier ~static~. These object lifetimes span the entire
  program execution, either being completely defined at compile time or resolved by a system's
  startup procedure.

  - *static storage duration* is not the same as declaring a variable with the *storage class*
    ~static~. The latter ensures that a variable or function has internal linkage.

  - Objects with static storage duration are always initialized.

- Automatic :: Any block-scope variables that are not declared ~static~, block-scope compound
  literals, and some temporary objects that are returned by function calls. They are typically
  local variables created when program execution enters the scope in which they are defined
  and are destroyed when that scope is exited. Such object lifetimes can be determined by the
  compiler.

  - Unless they are VLA or temporary objects, automatic objects have a lifetime corresponding
    to the execution of their block of definition.

  - For an object that is not VLA, lifetime starts when the scope of the definition is entered,
    and it ends when that scope is left.

  - Initializers of automatic variables and compound literals are evaluated each time the
    definition is met.

  - Each recursive call to a function creates a new local instance of an automatic object.

  - The ~&~ operator is not allowed for variables declared with ~register~, meaning variables
    declared with ~register~ can't alias.

- Allocated :: Objects that are created and destroyed at runtime via ~malloc~ and related
  allocation functions. These storage instances are byte arrays and do not have interpretation
  as objects. They acquire an effective type only after something is stored inside them. Each
  newly-allocated array returns ~void*~, a pointer without type information. Assignment converts
  the pointer to its effective type.

  - ~malloc~ indicates failure by a returning a null pointer value — typically ~(void*)0~.

  - For every allocation, there must be a ~free~. Only call ~free~ with pointers as they
    are returned by ~malloc~, ~calloc~, ~aligned_alloc~, or ~realloc~.

#+begin_src c
  #include <stdlib.h>

  void* malloc(size_t size);
  void* free(void* ptr);
  // calloc (clear allocate) sets all bits of new storage to 0.
  void* calloc(size_t nmemb, size_t size);
  void* realloc(void* ptr, size_t size);
  void* aligned_alloc(size_t alignment, size_t size);
#+end_src

| storage class   | lifetime                      | scope                     | default initializer    |
|-----------------+-------------------------------+---------------------------+------------------------|
| ~auto~          | block (stack)                 | block                     | uninitialized          |
| ~register~      | block (stack or CPU register) | block                     | uninitialized          |
| ~static~        | program                       | block or unit compilation | zero                   |
| ~extern~        | program                       | global (entire program)   | zero                   |
| ~_Thread_local~ | thread                        |                           |                        |
| none            | dynamic (heap)                |                           | zero if using ~calloc~ |

** The State Machine: C to Assembly

*** Numbers Loop

**** C Source Code

#+begin_src c
  int add(int x, int y) {
      return x + y;
  }

  int main (int argc, char *argv[]) {
      int index =  0;
      int bound = 10;
      int sum   =  0;

      int numbers[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

      while (index <= bound) {
          sum = add(sum, numbers[index]);
          index += 1;
      }

      return 0;
  }
#+end_src

**** Assembly Output ~x86-64 gcc 14.2~

#+begin_src asm
  add:
          push    rbp                           ; <+
          mov     rbp, rsp                      ;  |
          mov     DWORD PTR [rbp-4], edi        ;  |- Setup state for "add" function;
          mov     DWORD PTR [rbp-8], esi        ;  |
          mov     edx, DWORD PTR [rbp-4]        ;  |
          mov     eax, DWORD PTR [rbp-8]        ; <+
          add     eax, edx                      ; <-- Call the add operator.
          pop     rbp                           ; <-- Return to caller of "add" function.
          ret                                   ; <+
  main:
          push    rbp                           ; <+
          mov     rbp, rsp                      ;  |
          sub     rsp, 80                       ;  |- Setup up state for "main" function.
          mov     DWORD PTR [rbp-68], edi       ;  |
          mov     QWORD PTR [rbp-80], rsi       ; <+
          mov     DWORD PTR [rbp-4], 0          ; <-- Move 0 into "index".
          mov     DWORD PTR [rbp-12], 10        ; <-- Move 10 into "bound".
          mov     DWORD PTR [rbp-8], 0          ; <-- Move 0 into "sum".
          mov     DWORD PTR [rbp-64], 1         ; <+
          mov     DWORD PTR [rbp-60], 2         ;  |
          mov     DWORD PTR [rbp-56], 3         ;  |
          mov     DWORD PTR [rbp-52], 4         ;  |
          mov     DWORD PTR [rbp-48], 5         ;  |- Setup "numbers" array.
          mov     DWORD PTR [rbp-44], 6         ;  |
          mov     DWORD PTR [rbp-40], 7         ;  |
          mov     DWORD PTR [rbp-36], 8         ;  |
          mov     DWORD PTR [rbp-32], 9         ;  |
          mov     DWORD PTR [rbp-28], 10        ; <+
          jmp     .L4                           ; <-- Jump to "while" loop section of "main".
  .L5:
          mov     eax, DWORD PTR [rbp-4]        ; <-- Move "index" into register "eax".
          cdqe                                  ; <-- RAX := SignExtend(EAX)
          mov     edx, DWORD PTR [rbp-64+rax*4] ; <-- Index into "numbers" array.
          mov     eax, DWORD PTR [rbp-8]        ; <-- Move "sum" into "eax" register.
          mov     esi, edx                      ; <-- Move "numbers[index]" into "esi" register
          mov     edi, eax                      ; <-- Move "sum" from "eax" register to "edi" register.
          call    add                           ; <-- Call "add" function.
          mov     DWORD PTR [rbp-8], eax        ; <-- Move result into "sum" register.
          add     DWORD PTR [rbp-4], 1          ; <-- Add 1 into "index" register
  .L4:
          mov     eax, DWORD PTR [rbp-4]        ; <+
          cmp     eax, DWORD PTR [rbp-12]       ;  |- Setup "while" loop and jump to body if condition is satisfied.
          jle     .L5                           ; <+
          mov     eax, 0                        ; <-- Return success code 0 from "main".
          leave                                 ; <-- Exit "main".
          ret                                   ; <+
#+end_src

*** Copy String

**** C Source Code

#+begin_src c
  #include <stdlib.h>

  char* copy_string(char* destination, const char* source) {
      char* saved = destination;
      while (*source != '\0') {
          *destination = *source;
          source += 1;
          destination += 1;
      }
      *destination = '\0';
      return saved;
  }

  const char* name = "Jared Clarke";

  int main(int argc, char* argv[]) {
      char* text = malloc(13);
      copy_string(text, name);
      free(text);
      text = NULL;
      return 0;
  }
#+end_src

**** Assembly Output ~x86-64 gcc 14.2~

#+begin_src asm
  copy_string:
          push    rbp                      ; <+
          mov     rbp, rsp                 ;  |- Set up state for "copy_string" function.
          mov     QWORD PTR [rbp-24], rdi  ;  |
          mov     QWORD PTR [rbp-32], rsi  ; <+
          mov     rax, QWORD PTR [rbp-24]  ; <-- Save the first pointer to "destination".
          mov     QWORD PTR [rbp-8], rax   ; <+
          jmp     .L2                      ; <-- Jump to "while" loop.
  .L3:
          mov     rax, QWORD PTR [rbp-32]  ; <+
          movzx   edx, BYTE PTR [rax]      ;  |- Copy value from "source" to "destination".
          mov     rax, QWORD PTR [rbp-24]  ;  |
          mov     BYTE PTR [rax], dl       ; <+
          add     QWORD PTR [rbp-32], 1    ; <-- Increment pointer to "source".
          add     QWORD PTR [rbp-24], 1    ; <-- Increment pointer to "destination".
  .L2:
          mov     rax, QWORD PTR [rbp-32]  ; <+
          movzx   eax, BYTE PTR [rax]      ;  |- If predicate is satisfied, jump to "while" block.
          test    al, al                   ;  |
          jne     .L3                      ; <+
          mov     rax, QWORD PTR [rbp-24]  ; <+- Append '\0' to end of "destination" array.
          mov     BYTE PTR [rax], 0        ; <+
          mov     rax, QWORD PTR [rbp-8]   ; <-- Return first pointer to "destination".
          pop     rbp                      ; <+- Return to caller of "copy_string".
          ret                              ; <+
  .LC0:
          .string "Jared Clarke"           ; <-- String literal.
  name:
          .quad   .LC0
  main:
          push    rbp                      ; <+
          mov     rbp, rsp                 ;  |
          sub     rsp, 32                  ;  |- Set up state for "main" function.
          mov     DWORD PTR [rbp-20], edi  ;  |
          mov     QWORD PTR [rbp-32], rsi  ; <+
          mov     edi, 13                  ; <+
          call    malloc                   ;  |- Allocate a 13-part array of type "char".
          mov     QWORD PTR [rbp-8], rax   ; <+
          mov     rdx, QWORD PTR name[rip] ; <+
          mov     rax, QWORD PTR [rbp-8]   ;  |
          mov     rsi, rdx                 ;  |- Call "copy_string".
          mov     rdi, rax                 ;  |
          call    copy_string              ; <+
          mov     rax, QWORD PTR [rbp-8]   ; <+
          mov     rdi, rax                 ;  |- Free memory for "text".
          call    free                     ; <+
          mov     QWORD PTR [rbp-8], 0     ; <-- Set "text" pointer to NULL.
          mov     eax, 0                   ; <-- Return success code 0 from "main" function.
          leave                            ; <-- Exit "main" function.
          ret                              ; <+
#+end_src
