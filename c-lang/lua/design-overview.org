* Design Overview

** Sources

| source                        | author                                                                       |
|-------------------------------+------------------------------------------------------------------------------|
| *A Look at the Design of Lua* | Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes Filho |
| *Programming in Lua*          | Roberto Ierusalimschy                                                                             |

** Lua Standalone Interpreter

Lua is implemented not as a standalone program, but as a library with a C API.
The standalone Lua interpreter is a tiny application written on top of the C library.

#+begin_src c
  // The main code block as implemented in the Lua stand-alone interpreter.
  int main (int argc, char *argv[]) {
    int status, result;
    // Create thread state.
    lua_State *L = luaL_newstate();
    if (L == NULL) {
      l_message(argv[0], "cannot create state: not enough memory");
      return EXIT_FAILURE;
    }
    // Stop garbage collection while building state
    lua_gc(L, LUA_GCSTOP);
    // Prepare call to 'pmain' in protected mode.
    lua_pushcfunction(L, &pmain);
    // 1st argument.
    lua_pushinteger(L, argc);
    // 2nd argument.
    lua_pushlightuserdata(L, argv);
    // Call 'pmain'.
    status = lua_pcall(L, 2, 1, 0);
    // Get result.
    result = lua_toboolean(L, -1);
    report(L, status);
    lua_close(L);
    return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
  }
#+end_src

** Modules: Implementation 1

Lua loads any chunk as the body of an enclosing anonymous function. A module
is a chunk — an anonymous function — that creates and returns a table.
The table provides the namespace, lexical scoping provides encapsulation, and
first-class functions allow exportation.

#+begin_src lua
  -- Constructing a module using first-class functions and tables.
  -- function ()
       local Module = {}

       function Module.new (x, y)
         return { x = x, y = y }
       end

       function Module.add (v1, v2)
         return Module.new(v1.x + v2.x, v1.y + v2.y)
       end

       function Module.magnitude (v)
         math.sqrt(v.x ^ 2 + v.y ^ 2)
       end

       return Module
  -- end

  -- local vec = require("module")
  --
  -- five = vec.magnitude(vec.new(3, 4))
#+end_src

** Modules: Implementation 2

#+begin_src lua
  -- function ()
       local sqrt = math.sqrt
       local _ENV = {}

       function new (x, y)
         return {x = x, y = y}
       end

       function add (v1, v2)
         return new(v1.x + v2.x, v1.y + v2.y)
       end

       function magnitude (v)
         return sqrt(v.x ^ 2 + v.y ^ 2)
       end
       return _ENV
  -- end
#+end_src

* Object-Oriented Programming: Meta Tables

#+begin_src lua
  local meta = {}

  function vector (x, y)
    local v = { x = x, y = y }
    setmetatable(v, meta)
    return v
  end

  function meta.__add (v1, v2)
    return vector(v1.x + v2.x, v1.y + v2.y)
  end

  A = vector(1, 2)
  B = vector(2, 2)
  C = A + B --> { x = 3, y = 4 }
#+end_src

** Object-Oriented Programming: Protoypes

#+begin_src lua
  local Account = { balance = 0 }

  local meta = { __index = Account }

  function Account:new ()
    local object = {}
    setmetatable(object, meta)
    return object
  end

  -- Translates: object:deposit(amount) -> object:deposit(self, amount)
  --             where self = object
  function Account:deposit (amount)
    self.balance = self.balance + amount
  end

  function Account:balance ()
    return self.balance
  end

  return Account

  -- Account = require("Account")
  --
  -- account = Account:new()
  -- account:deposit(100)
  -- balance = account:balance()
#+end_src

** Object-Oriented Programming: Privacy

#+begin_src lua
  local balance = {}

  -- Set keys to weak for garbage collection.
  setmetatable(balance, { __mode = "k" })

  local Account = {}
  local meta = { __index = Account }

  function Account:new ()
    local object = {}
    setmetatable(object, meta)
    balance[object] = 0
    return object
  end

  function Account:deposit (amount)
    balance[self] = balance[self] + amount
  end

  function Account:balance ()
    return balance[self]
  end

  return Account
#+end_src

** Error Handling

#+begin_src lua
  -- try {
  --   protected code
  -- } catch (error) {
  --   handle exception
  -- }

  -- equivalent ->

  local ok, error = pcall(function() protected_code() end)

  if not ok then
    handle_acception()
  end
#+end_src
