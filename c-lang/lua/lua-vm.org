* Lua's Virtual Machine

** Sources

| source                          | author                                                                       |
|---------------------------------+------------------------------------------------------------------------------|
| *The Implementation of Lua 5.0* | Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes Filho |
| *Lua Source Code*, 5.5          | Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes Filho |
| *Crafting Interpreters*         | Robert Nystrom                                                               |

As of version 5.5, there are 85 instructions in Lua's virtual machine. Most instructions
correspond directly to language constructs, such as arithmetic, table creation and indexing,
function and method calls, setting variables and getting values. There are also jump
instructions for implementing control flow.

** Notational Conventions

- ~R[x]~: ~xth~ register.

- ~K[x]~: ~xth~ constant.

- ~RK[x]~: if ~k(i)~ then ~K[x]~ else ~R[x]~.

** Instruction Set

| opcode     | operands  | description                                                      |
|------------+-----------+------------------------------------------------------------------|
| MOVE       | A B       | R[A] := R[B]                                                     |
| LOADI      | A sBx     | R[A] := sBx                                                      |
| LOADF      | A sBx     | R[A] := (lua_Number)sBx                                          |
| LOADK      | A Bx      | R[A] := K[Bx]                                                    |
| LOADKX     | A         | R[A] := K[extra arg]                                             |
| LOADFALSE  | A         | R[A] := false                                                    |
| LFALSESKIP | A         | R[A] := false; pc++                                              |
| LOADTRUE   | A         | R[A] := true                                                     |
| LOADNIL    | A B       | R[A], R[A+1], ..., R[A+B] := nil                                 |
| GETUPVAL   | A B       | R[A] := UpValue[B]                                               |
| SETUPVAL   | A B       | UpValue[B] := R[A]                                               |
|------------+-----------+------------------------------------------------------------------|
| GETTABUP   | A B C     | R[A] := UpValue[B][K[C]:shortstring]                             |
| GETTABLE   | A B C     | R[A] := R[B][R[C]]                                               |
| GETI       | A B C     | R[A] := R[B][C]                                                  |
| GETFIELD   | A B C     | R[A] := R[B][K[C]:shortstring]                                   |
|------------+-----------+------------------------------------------------------------------|
| SETTABUP   | A B C     | UpValue[A][K[B]:shortstring] := RK(C)                            |
| SETTABLE   | A B C     | R[A][R[B]] := RK(C)                                              |
| SETI       | A B C     | R[A][B] := RK(C)                                                 |
| SETFIELD   | A B C     | R[A][K[B]:shortstring] := RK(C)                                  |
|------------+-----------+------------------------------------------------------------------|
| NEWTABLE   | A B C k   | R[A] := {}                                                       |
|------------+-----------+------------------------------------------------------------------|
| SELF       | A B C     | R[A+1] := R[B]; R[A] := R[B][RK(C):shortstring]                  |
|------------+-----------+------------------------------------------------------------------|
| ADDI       | A B sC    | R[A] := R[B] + sC                                                |
|------------+-----------+------------------------------------------------------------------|
| ADDK       | A B C     | R[A] := R[B] + K[C]:number                                       |
| SUBK       | A B C     | R[A] := R[B] - K[C]:number                                       |
| MULK       | A B C     | R[A] := R[B] * K[C]:number                                       |
| MODK       | A B C     | R[A] := R[B] % K[C]:number                                       |
| POWK       | A B C     | R[A] := R[B] ^ K[C]:number                                       |
| DIVK       | A B C     | R[A] := R[B] / K[C]:number                                       |
| IDIVK      | A B C     | R[A] := R[B] // K[C]:number                                      |
|------------+-----------+------------------------------------------------------------------|
| BANDK      | A B C     | R[A] := R[B] & K[C]:integer                                      |
| BORK       | A B C     | R[A] := R[B] \vert{} K[C]:integer                                |
| BXORK      | A B C     | R[A] := R[B] ~ K[C]:integer                                      |
|------------+-----------+------------------------------------------------------------------|
| SHLI       | A B sC    | R[A] := sC << R[B]                                               |
| SHRI       | A B sC    | R[A] := R[B] >> sC                                               |
|------------+-----------+------------------------------------------------------------------|
| ADD        | A B C     | R[A] := R[B] + R[C]                                              |
| SUB        | A B C     | R[A] := R[B] - R[C]                                              |
| MUL        | A B C     | R[A] := R[B] * R[C]                                              |
| MOD        | A B C     | R[A] := R[B] % R[C]                                              |
| POW        | A B C     | R[A] := R[B] ^ R[C]                                              |
| DIV        | A B C     | R[A] := R[B] / R[C]                                              |
| IDIV       | A B C     | R[A] := R[B] // R[C]                                             |
|------------+-----------+------------------------------------------------------------------|
| BAND       | A B C     | R[A] := R[B] & R[C]                                              |
| BOR        | A B C     | R[A] := R[B] \vert{} R[C]                                        |
| BXOR       | A B C     | R[A] := R[B] ~ R[C]                                              |
| SHL        | A B C     | R[A] := R[B] << R[C]                                             |
| SHR        | A B C     | R[A] := R[B] >> R[C]                                             |
|------------+-----------+------------------------------------------------------------------|
| MMBIN      | A B C     | call C metamethod over R[A] and R[B]                             |
| MMBINI     | A sB C k  | call C metamethod over R[A] and sB                               |
| MMBINK     | A B C k   | call C metamethod over R[A] and K[B]                             |
|------------+-----------+------------------------------------------------------------------|
| UNM        | A B       | R[A] := -R[B]                                                    |
| BNOT       | A B       | R[A] := ~R[B]                                                    |
| NOT        | A B       | R[A] := not R[B]                                                 |
| LEN        | A B       | R[A] := #R[B] (length operator)                                  |
|------------+-----------+------------------------------------------------------------------|
| CONCAT     | A B       | R[A] := R[A].. ... ..R[A + B - 1]                                |
|------------+-----------+------------------------------------------------------------------|
| CLOSE      | A         | close all upvalues >= R[A]                                       |
| TBC        | A         | mark variable A "to be closed"                                   |
| JMP        | sJ        | pc += sJ                                                         |
| EQ         | A B k     | if ((R[A] =  R[B]) ~= k) then pc++                               |
| LT         | A B k     | if ((R[A] <  R[B]) ~= k) then pc++                               |
| LE         | A B k     | if ((R[A] <= R[B]) ~= k) then pc++                               |
|------------+-----------+------------------------------------------------------------------|
| EQK        | A B k     | if ((R[A] = K[B]) ~= k) then pc++                                |
| EQI        | A sB k    | if ((R[A] = sB) ~= k) then pc++                                  |
| LTI        | A sB k    | if ((R[A] < sB) ~= k) then pc++                                  |
| LEI        | A sB k    | if ((R[A] <= sB) ~= k) then pc++                                 |
| GTI        | A sB k    | if ((R[A] > sB) ~= k) then pc++                                  |
| GEI        | A sB k    | if ((R[A] >= sB) ~= k) then pc++                                 |
|------------+-----------+------------------------------------------------------------------|
| TEST       | A k       | if (not R[A] = k) then pc++                                      |
| TESTSET    | A B k     | if (not R[B] = k) then pc++ else R[A] := R[B]                    |
|------------+-----------+------------------------------------------------------------------|
| CALL       | A B C     | R[A], ... , R[A+C-2] := R[A](R[A+1], ... , R[A+B-1])             |
| TAILCALL   | A B C k   | return R[A](R[A+1], ... ,R[A+B-1])                               |
|------------+-----------+------------------------------------------------------------------|
| RETURN     | A B C k   | return R[A], ... ,R[A+B-2]                                       |
| RETURN0    |           | return                                                           |
| RETURN1    | A         | return R[A]                                                      |
|------------+-----------+------------------------------------------------------------------|
| FORLOOP    | A Bx      | update counters; if loop continues then pc-=Bx;                  |
| FORPREP    | A Bx      | <check values and prepare counters> if not to run then pc+=Bx+1; |
|------------+-----------+------------------------------------------------------------------|
| TFORPREP   | A Bx      | create upvalue for R[A + 3]; pc+=Bx                              |
| TFORCALL   | A C       | R[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);                   |
| TFORLOOP   | A Bx      | if R[A+2] ~= nil then { R[A] = R[A+2]; pc -= Bx }                |
|------------+-----------+------------------------------------------------------------------|
| SETLIST    | A vB vC k | R[A][C+i] := R[A+i], 1 <= i <= B                                 |
|------------+-----------+------------------------------------------------------------------|
| CLOSURE    | A Bx      | R[A] := closure(KPROTO[Bx])                                      |
|------------+-----------+------------------------------------------------------------------|
| VARARG     | A B C k   | R[A], R[A+1], ..., R[A+C-2] = varargs                            |
|------------+-----------+------------------------------------------------------------------|
| GETVARG    | A B C     | R[A] := R[B][R[C], R[B] is vararg parameter ]                    |
|------------+-----------+------------------------------------------------------------------|
| ERRNNIL    | A Bx      | raise error if R[A] ~= nil (K[Bx - 1] is global name)            |
|------------+-----------+------------------------------------------------------------------|
| VARARGPREP | A         | (adjust varargs)                                                 |
|------------+-----------+------------------------------------------------------------------|
| EXTRAARG   | Ax        | extra (larger) argument for previous opcode                      |

** Instruction Layout

#+begin_example
  +------------------+
  | OP | A |  B |  C |
  |----|---|----|----|
  | OP | A | vB | vC |
  |----|---|---------|
  | OP | A |  Bx     |
  |----|---|---------|
  | OP | A | sBx     |
  |----|-------------|
  | OP | Ax          |
  |----|-------------|
  | OP | sJ          |
  +------------------+

  === Instruction layout as documented in source code: lopcodes.h ===

  We assume that instructions are unsigned 32-bit integers.
  All instructions have an opcode in the first 7 bits.
  Instructions can have the following formats:

         | 3 3 2 2 2 2 2 2 | 2 2 2 2 1 1 1 1 | 1 | 1 1 1 1 1 0 0 0 | 0 0 0 0 0 0 0 |
         |-----------------|-----------------|---|-----------------|---------------|
         | 1 0 9 8 7 6 5 4 | 3 2 1 0 9 8 7 6 | 5 | 4 3 2 1 0 9 8 7 | 6 5 4 3 2 1 0 |
  -------|-----------------|-----------------|---|-----------------|---------------|
  iABC   |       C(8)      |      B(8)       | k |     A(8)        |   Op(7)       |
  -------|-----------------|-----------------|---|-----------------|---------------|
  ivABC  |      vC(10)     |     vB(6)       | k |     A(8)        |   Op(7)       |
  -------|---------------------------------------|-----------------|---------------|
  iABx   |            Bx(17)                     |     A(8)        |   Op(7)       |
  -------|---------------------------------------|-----------------|---------------|
  iAsBx  |           sBx (signed)(17)            |     A(8)        |   Op(7)       |
  -------|---------------------------------------------------------|---------------|
  iAx    |                       Ax(25)                            |   Op(7)       |
  -------|---------------------------------------------------------|---------------|
  isJ    |                       sJ (signed)(25)                   |   Op(7)       |

  v = variant
  s = signed
  x = extended

  A signed argument is represented in excess K: The represented value is
  the written unsigned value minus K, where K is half (rounded down) the
  maximum value for the corresponding unsigned argument.

  === Size and position of opcode arguments ===

  SIZE_C  = 8
  SIZE_vC = 10
  SIZE_B  = 8
  SIZE_vB = 6
  SIZE_Bx = (SIZE_C + SIZE_B + 1)
  SIZE_A  = 8
  SIZE_Ax = (SIZE_Bx + SIZE_A)
  SIZE_sJ = (SIZE_Bx + SIZE_A)

  SIZE_OP = 7

  POS_OP  = 0

  POS_A   = (POS_OP + SIZE_OP)
  POS_k   = (POS_A + SIZE_A)
  POS_B   = (POS_k + 1)
  POS_vB  = (POS_k + 1)
  POS_C   = (POS_B + SIZE_B)
  POS_vC  = (POS_vB + SIZE_vB)

  POS_Bx  = POS_k

  POS_Ax  = POS_A

  POS_sJ  = POS_A
#+end_example

** Lua Function to Bytecode

#+begin_src lua
  -- === Lua Function ===

  function max(a, b)
      local m = a
      if b > a then
          m = b
      end
      return m
  end

  -- === Bytecode: 5.5 ===
  --
  --   Op      | A | B | C |
  --  ----------------------
  -- 1 MOVE      2   0        ; R(A) := R(B) local a
  -- 2 LT        0   1   0    ; RK(A) local a < RK(B) local b, where C = false
  -- 3 JMP       1            ; A to pc -> 5
  -- 4 MOVE      2   1        ; R(A) local m := R(B) local b
  -- 5 RETURN1   2            ; return R(A) local m
  -- 6 RETURN0                ; return
  --
  -- | index | name | startpc | endpc |
  -- |-------+------+---------+-------|
  -- | 0     | a    | 1       | 7     |
  -- | 1     | b    | 1       | 7     |
  -- | 2     | m    | 2       | 7     |
#+end_src

** Runtime

*** Global State

#+begin_src c
  // === Global State ===
  // State shared by all threads.

  typedef struct global_State {
    // Function to reallocate memory.
    lua_Alloc frealloc;
    // Auxiliary data to "frealloc".
    void *ud;
    // Number of bytes currently allocated + debt.
    l_mem GCtotalbytes;
    // Bytes counted but not yet allocated.
    l_mem GCdebt;
    // Number of objects marked in a GC cycle.
    l_mem GCmarked;
    // Auxiliary counter to control major-minor shifts.
    l_mem GCmajorminor;
    // Hash table for strings.
    stringtable strt;
    TValue l_registry;
    // Bottom value, nil.
    TValue nilvalue;
    // Randomized seed for hashes.
    unsigned int seed;
    lu_byte gcparams[LUA_GCPN];
    lu_byte currentwhite;
    // State of garbage collector.
    lu_byte gcstate;
    // Kind of garbage collection.
    lu_byte gckind;
    // Stops emergency collections.
    lu_byte gcstopem;
    // Control whether GC is running.
    lu_byte gcstp;
    // True for emergency collections.
    lu_byte gcemergency;
    // List of all collectable objects.
    GCObject *allgc;
    // Current position in sweep list.
    GCObject **sweepgc;
    // List of collectable objects with finalizers.
    GCObject *finobj;
    // List of gray objects.
    GCObject *gray;
    // List of objects to be traversed atomically.
    GCObject *grayagain;
    // List of tables with weak values.
    GCObject *weak;
    // List of ephemeron tables (weak keys).
    GCObject *ephemeron;
    // List of all-weak tables.
    GCObject *allweak;
    // List of userdata to be garbage collected.
    GCObject *tobefnz;
    // List of objects not to be collected.
    GCObject *fixedgc;
    // --- Fields for Generational Collector ---
    // Objects that survived one GC cycle.
    GCObject *survival;
    GCObject *old1;
    // Objects more than one cycle old.
    GCObject *reallyold;
    GCObject *firstold1;
    // --- List of Objects with Finalizers ---
    GCObject *finobjsur;
    GCObject *finobjold1;
    GCObject *finobjrold;
    // List of threads with open upvalues.
    struct lua_State *twups;
    // Function to be called for unprotected errors.
    lua_CFunction panic;
    // Message for memory-allocation errors.
    TString *memerrmsg;
    // Array with tag-method names.
    TString *tmname[TM_N];
    // Metatables for basic types.
    struct Table *mt[LUA_NUMTYPES];
    // Cache for strings in API.
    TString *strcache[STRCACHE_N][STRCACHE_M];
    // Warning function.
    lua_WarnFunction warnf;
    // Auxiliary data for warning function.
    void *ud_warn;
    // Main thread of this state.
    LX mainth;
  } global_State;

  // === Thread State + Extra Space ===

  typedef struct LX {
    lu_byte extra_[LUA_EXTRASPACE];
    lua_State l;
  } LX;
#+end_src

*** Thread State

#+begin_src c
  // === Per Thread State ===

  struct lua_State {
    // CommonHeader -----------+
    struct GCObject *next; //  |
    lu_byte tt;            //  |
    lu_byte marked;        // <+
    // Type for thread status/error codes.
    TStatus status;
    // First free slot in the stack.
    StkIdRel top;
    // Reference to state shared by all threads. Contains mostly data
    // for memory allocation and garbage collection.
    struct global_State *l_G;
    // Call information for current function.
    CallInfo *ci;
    // End of stack (last element + 1)
    StkIdRel stack_last;
    // Stack base.
    StkIdRel stack;
    // List of open upvalues in this stack.
    UpVal *openupval;
    // List of to-be-closed variables.
    StkIdRel tbclist;
    // List of garbage-collectable objects.
    GCObject *gclist;
    // List of threads with open upvalues.
    struct lua_State *twups;
    // Current errory recovery point.
    struct lua_longjmp *errorJmp;
    // Call information for first level (C host).
    CallInfo base_ci;
    // Function to be called by the debugger.
    volatile lua_Hook hook;
    // Current error handling function (stack index).
    ptrdiff_t errfunc;
    // Number of nested, (non-yieldable | C) calls.
    l_uint32 nCcalls;
    // Last program counter traced.
    int oldpc;
    // Number of items in call information list.
    int nci;
    int basehookcount;
    int hookcount;
    volatile l_signalT hookmask;
    // Information about transferred values for (call | return) hooks.
    struct {
      // Offset of first value transferred.
      int ftransfer;
      // Number of values transferred.
      int ntransfer;
    } transferinfo;
  };

  // === Function Call Information ===

  struct CallInfo {
    // Function index in the stack.
    StkIdRel func;
    // Top index for this function.
    StkIdRel top;
    // Dynamic call link.
    struct CallInfo *previous, *next;
    union {
      // === Lua Function ===
      struct {
        // Saved pointer to bytecode instruction.
        const Instruction *savedpc;
        // Function tracing lines/counts.
        volatile l_signalT trap;
        // Number of extra arguments in variable-argument functions.
        int nextraargs;
      } l;
      // === C Function ===
      struct {
        // Continuation in case of yields.
        lua_KFunction k;
        ptrdiff_t old_errfunc;
        // Context information in case of yields.
        lua_KContext ctx;
      } c;
    } u;
    union {
      // Called function index. Used only by C functions during
      // a protected call.
      int funcidx;
      // Number of values yielded. Used only by functions
      // that are yielding.
      int nyield;
      // Number of values returned.
      int nres;
    } u2;
    // Bit mask denoting function status.
    // - number of results.
    // - metamethod?
    // - etc.
    l_uint32 callstatus;
  };

  // === Lua Stack ===

  // Lua stack entries. Field "tbclist" forms a list of all
  // to-be-closed variables active in this stack. Dummy entries are
  // used when the distance between two tbc variables does not fit
  // in an unsigned short. They are represented by delta == 0.
  // Their real delta is always the maximum value that fits in
  // that field.
  typedef union StackValue {
    TValue val;
    struct {
      // Lua value.
      Value value_;
      // Type tag.
      lu_byte tt_;
      unsigned short delta;
    } tbclist;
  } StackValue;

  // Index to stack elements.
  typedef StackValue *StkId;

  // === Stack Pointers ===
  typedef union {
    // Pointer
    StkId p;
    // Offset used during stack reallocation.
    ptrdiff_t offset;
  } StkIdRel;
#+end_src

*** Data Types

#+begin_src c
  // === Values ===

  typedef union Value {
    // Garbage-collectable objects.
    struct GCObject *gc;
    // Light userdata.
    void *p;
    // Light C functions.
    lua_CFunction f;
    // Integers.
    lua_Integer i;
    // Floats.
    lua_Number n;
    // Not used. May avoid warnings for uninitialized values.
    lu_byte ub;
  } Value;

  // tagged union (value_, tt_)
  // where value_ = the union of C types that implement a Lua value
  //       tt_    = the type tag: an unsigned char that identifies the Lua value
  typedef struct TValue {
    Value value_;
    lu_byte tt_;
  } TValue;

  // === Collectable Objects ===
  // Type shared by all collectable objects:
  // Tables, strings, functions, threads, and full userdata.

  typedef struct GCObject {
    struct GCObject *next;
    lu_byte tt;
    lu_byte marked;
  } GCObject;
#+end_src

*** Tables

#+begin_src c
  // === Lua Table ===

  typedef struct Table {
    // CommonHeader -----------+
    struct GCObject *next; //  |
    lu_byte tt;            //  |
    lu_byte marked;        // <+
    // 1 << p means tagmethod(p) is not present.
    lu_byte flags;
    // log2 of number of slots in "node" array.
    lu_byte lsizenode;
    // Number of slots in "array" array.
    unsigned int asize;
    // Array part.
    Value *array;
    // Hash table nodes.
    Node *node;
    struct Table *metatable;
    GCObject *gclist;
  } Table;

  // === Hash Table Node ===
  // A key-value pair plus a "next" field to link colliding entries.
  // The separation of "key_tt" and "key_val" shrinks the memory
  // footprint for 4-byte and 8-byte alignments.

  typedef union Node {
    struct NodeKey {
      // Fields for value -+
      Value value_; //     |
      lu_byte tt_;  // <---+
      // Key type.
      lu_byte key_tt;
      int next;
      // Key value.
      Value key_val;
    } u;
    // Direct access to node as a proper "TValue".
    TValue i_val;
  } Node;
#+end_src

*** Functions, Closures, and UpValues

#+begin_quote
  "When Lua compiles a function it generates a *prototype* containing the virtual machine
   instructions for the function, its constant values (numbers, literal strings, etc.),
   and some debug information. At run time, whenever Lua executes a ~function...end~
   expression, it creates a new closure. Each closure has a reference to its corresponding
   prototype, a reference to its environment (a table wherein it looks for global variables),
   and an array of references to upvalues, which are used to access outer local variables...

   Lua uses a structure called an *upvalue* to implement closures. Any outer local variable
   is accessed indirectly through an upvalue. The upvalue originally points to the stack
   slot wherein the variable lives. When the variable goes out of scope, it migrates into
   a slot inside the upvalue itself...

   Unlike its inner functions, the function that declares the variable accesses [that variable]
   as it accesses its own local variables: directly in the stack."

  â€” *The Implementation of Lua 5.0*
#+end_quote

#+begin_src c
  // === Function Prototype ===

  typedef struct Proto {
    // CommonHeader -----------+
    struct GCObject *next; //  |
    lu_byte tt;            //  |
    lu_byte marked;        // <+
    // Number of fixed (named) parameters.
    lu_byte numparams;
    lu_byte flag;
    // Number of Registers needed by this function.
    lu_byte maxstacksize;
    int sizeupvalues;
    int sizek;
    int sizecode;
    int sizelineinfo;
    int sizep;
    int sizelocvars;
    int sizeabslineinfo;
    // Debug information.
    int linedefined;
    int lastlinedefined;
    // Constants used by function.
    TValue *k;
    // Opcodes.
    Instruction *code;
    // Functions defined inside function.
    struct Proto **p;
    // upvalue information.
    Upvaldesc *upvalues;
    // Debug information.
    ls_byte *lineinfo;
    AbsLineInfo *abslineinfo;
    // Debug information: local variables.
    LocVar *locvars;
    // Debug information: source string.
    TString  *source;
    GCObject *gclist;
  } Proto;

  // === Upvalues ===

  typedef struct UpVal {
    // CommonHeader -----------+
    struct GCObject *next; //  |
    lu_byte tt;            //  |
    lu_byte marked;        // <+
    union {
      // Pointer to stack or upvalue
      TValue *p;
      // Offset for stack reallocation
      ptrdiff_t offset;
    } v;
    union {
      // Open upvalue
      struct {
        // Linked list
        struct UpVal *next;
        struct UpVal **previous;
      } open;
      // Closed upvalue
      TValue value;
    } u;
  } UpVal;

  // Closures for C functions registered with Lua.

  typedef struct CClosure {
    ClosureHeader;
    // typedef int (*lua_CFunction) (lua_State *L);
    lua_CFunction f;
    // List of upvalues
    TValue upvalue[1];
  } CClosure;

  // Closures for function defined in Lua.

  typedef struct LClosure {
    // ClosureHeader -------------+
    // CommonHeader -----------+  |
    struct GCObject *next; //  |  |
    lu_byte tt;            //  |  |
    lu_byte marked;        // <+  |
    lu_byte nupvalues;     //     |
    GCObject *gclist       // <---+
    struct Proto *p;
    // List of upvalues
    UpVal *upvals[1];
  } LClosure;

  typedef union Closure {
    CClosure c;
    LClosure l;
  } Closure;
#+end_src

#+begin_example
  === Closures ===

  1. Resolves local variables that are declared in surrounding functions.
  2. Capture variables that have already left the stack.

  === Open Upvalues ===

   function f(x, y)
       function g(z)
           return x + y + z
       end
       return g
   end

   sum = f(7, 11)

                            Open Upvalue         Open Upvalue
                           +-------------+      +-------------+
        Open Upvalues <----| next        |<-----| next        |
                           +-------------+      +-------------+
                           | location    |--+   | location    |--+
                           +-------------+  |   +-------------+  |
                           | closed      |  |   | closed      |  |
                           +-------------+  |   +-------------+  |
                                            |                    |
        +-----------------------------------+                    |
        |    +---------------------------------------------------+
        V    V
  +---+---+---->
  | f | 7 | 11 | <-- Stack
  +---+---+---->

  === Closed Upvalues ===

  sum(1)

                            Function Prototype
                           +-------------+
          Closure      +-->| chunk       |--> Bytecode Array
         +----------+  |   |-------------|
     +-->| function |--+   | constants   |--> Value Array
     |   |----------|      +-------------+
     |   | upvalues |--+
     |   +----------+  |    Upvalue Pointer Array
     |                 |   +-------------+-------------+
     |                 +-->| index 0     | index 1     |
     |                     +-------------+-------------+
     |                            |           |
     |                  +---------+           |
     |                  |   Closed Upvalue    |   Closed Upvalue
     |                  |  +-------------+    |  +-------------+
     |  Open Upvalues <----| next        |<------| next        |
     |                  |  +-------------+    |  +-------------+
     |                  +->| location    |--+ +->| location    |--+
     |                     +-------------+  |    +-------------+  |
     |                     | closed 7    |<-+    | closed 11   |<-+
     |                     +-------------+       +-------------+
     |
  +------->
  | g | 1 | <-- Stack
  +------->
#+end_example
