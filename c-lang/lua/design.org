* Design Overview

** Sources

| source                        | author                                                                       |
|-------------------------------+------------------------------------------------------------------------------|
| *A Look at the Design of Lua* | Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes Filho |
| *Programming in Lua*          | Roberto Ierusalimschy                                                                             |

** Lua Standalone Interpreter

Lua is implemented not as a standalone program, but as a library with a C API.
The standalone Lua interpreter is a tiny application written on top of the C library.

#+begin_src c
  // Main body of the Lua stand-alone intepreter. Called in protected mode.
  // Parses and handles all arguments to the main program.
  static int pmain (lua_State *L) {
    int argc = (int)lua_tointeger(L, 1);
    char **argv = (char **)lua_touserdata(L, 2);
    int script;
    int args = collectargs(argv, &script);

    // First argument is not an option.
    int optlim = (script > 0) ? script : argc;
    // Check that interpreter has the correct version.
    luaL_checkversion(L);

    // Bad arguments?
    if (args == has_error) {
      print_usage(argv[script]);
      return 0;
    }
    // Option '-v'?
    if (args & has_v) {
      print_version();
    }
    // Option '-E'?
    if (args & has_E) {
      lua_pushboolean(L, 1);
      // Signal for libraries to ignore environment variables.
      lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
    }
    // Open standard libraries.
    luaL_openlibs(L);
    // Create table 'arg'
    createargtable(L, argv, argc, script);
    // Start GC in generational mode.
    lua_gc(L, LUA_GCRESTART);
    lua_gc(L, LUA_GCGEN, 0, 0);
    // No option '-E'?
    if (!(args & has_E)) {
      // Run LUA_INIT
      if (handle_luainit(L) != LUA_OK) {
        return 0;
      }
    }
    // Execute arguments '-e' and '-l'.
    if (!runargs(L, argv, optlim))
      return 0;
    // Execute main script (if there is one).
    if (script > 0) {
      if (handle_script(L, argv + script) != LUA_OK)
        return 0;
    }
    // If -i option, run read-eval-print loop.
    if (args & has_i) {
      doREPL(L);
    } else if (script < 1 && !(args & (has_e | has_v))) {
      if (lua_stdin_is_tty()) {
        print_version();
        doREPL(L);
      } else {
        // Executes stdin as a file.
        dofile(L, NULL);
      }
    }
    // Signal no errors.
    lua_pushboolean(L, 1);
    return 1;
  }

  // The requisite main program as implemented in the Lua stand-alone interpreter.
  int main (int argc, char *argv[]) {
    int status, result;
    // Create thread state.
    lua_State *L = luaL_newstate();
    if (L == NULL) {
      l_message(argv[0], "cannot create state: not enough memory");
      return EXIT_FAILURE;
    }
    // Stop garbage collection while building state
    lua_gc(L, LUA_GCSTOP);
    // Prepare call to 'pmain' in protected mode.
    lua_pushcfunction(L, &pmain);
    // 1st argument.
    lua_pushinteger(L, argc);
    // 2nd argument.
    lua_pushlightuserdata(L, argv);
    // Call 'pmain'.
    status = lua_pcall(L, 2, 1, 0);
    // Get result.
    result = lua_toboolean(L, -1);
    report(L, status);
    lua_close(L);
    return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
  }
#+end_src

** Lua Map Function

An implementation of the map function using Lua's C API.

#+begin_src c
  int lua_map (lua_State *L) {
    int i, n;

    // 1st argument must be a table (t).
    luaL_checktype(L, 1, LUA_TTABLE);

    // 2nd argument must be a function (f).
    luaL_checktype(L, 2, LUA_TFUNCTION);

    // Get size of table
    n = luaL_getn(L, 1);

    for (i = 1; i <= n; i += 1) {
      // Push f
      lua_pushvalue(L, 2);
      // Push t[i]
      lua_rawgeti(L, 1, i);
      // Call f(t[i])
      lua_call(L, 1, 1);
      // t[i] = result
      lua_rawseti(L, 1, i);
    }

    return 0;  /* no results */
  }
#+end_src

** Modules: Implementation 1

Lua loads any chunk as the body of an enclosing anonymous function. A module
is a chunk — an anonymous function — that creates and returns a table.
The table provides the namespace, lexical scoping provides encapsulation, and
first-class functions allow exportation.

#+begin_src lua
  -- Constructing a module using first-class functions and tables.
  -- function ()
       local Module = {}

       function Module.new (x, y)
         return { x = x, y = y }
       end

       function Module.add (v1, v2)
         return Module.new(v1.x + v2.x, v1.y + v2.y)
       end

       function Module.magnitude (v)
         math.sqrt(v.x ^ 2 + v.y ^ 2)
       end

       return Module
  -- end

  -- local vec = require("module")
  --
  -- five = vec.magnitude(vec.new(3, 4))
#+end_src

** Modules: Implementation 2

#+begin_src lua
  -- function ()
       local sqrt = math.sqrt
       local _ENV = {}

       function new (x, y)
         return {x = x, y = y}
       end

       function add (v1, v2)
         return new(v1.x + v2.x, v1.y + v2.y)
       end

       function magnitude (v)
         return sqrt(v.x ^ 2 + v.y ^ 2)
       end
       return _ENV
  -- end
#+end_src

* Object-Oriented Programming: Meta Tables

#+begin_src lua
  local meta = {}

  function vector (x, y)
    local v = { x = x, y = y }
    setmetatable(v, meta)
    return v
  end

  function meta.__add (v1, v2)
    return vector(v1.x + v2.x, v1.y + v2.y)
  end

  A = vector(1, 2)
  B = vector(2, 2)
  C = A + B --> { x = 3, y = 4 }
#+end_src

** Object-Oriented Programming: Protoypes

#+begin_src lua
  local Account = { balance = 0 }

  local meta = { __index = Account }

  function Account:new ()
    local object = {}
    setmetatable(object, meta)
    return object
  end

  -- Translates: object:deposit(amount) -> object:deposit(self, amount)
  --             where self = object
  function Account:deposit (amount)
    self.balance = self.balance + amount
  end

  function Account:balance ()
    return self.balance
  end

  return Account

  -- Account = require("Account")
  --
  -- account = Account:new()
  -- account:deposit(100)
  -- balance = account:balance()
#+end_src

** Object-Oriented Programming: Privacy

#+begin_src lua
  local balance = {}

  -- Set keys to weak for garbage collection.
  setmetatable(balance, { __mode = "k" })

  local Account = {}
  local meta = { __index = Account }

  function Account:new ()
    local object = {}
    setmetatable(object, meta)
    balance[object] = 0
    return object
  end

  function Account:deposit (amount)
    balance[self] = balance[self] + amount
  end

  function Account:balance ()
    return balance[self]
  end

  return Account
#+end_src

** Error Handling

#+begin_src lua
  -- try {
  --   protected code
  -- } catch (error) {
  --   handle exception
  -- }

  -- equivalent ->

  local ok, error = pcall(function() protected_code end)

  if not ok then
    handle_acception
  end
#+end_src
