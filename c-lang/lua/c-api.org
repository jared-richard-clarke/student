* Lua's C API

** Sources

| source                                           | author                                                                       |
|--------------------------------------------------+------------------------------------------------------------------------------|
| *A Look at the Design of Lua*                    | Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes Filho |
| *Passing a Language through the Eye of a Needle* | Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes Filho |
| *Programming in Lua*                             | Roberto Ierusalimschy                                                        |

** Introduction

#+begin_quote
  "The Lua library defines no C global variables at all. It keeps all its state in the dynamic
   structure ~lua_State~; all functions inside Lua receive a pointer to this structure as an
   argument. This design makes Lua reentrant and ready to be used in multithreaded code...

   A major component in the communication between Lua and C is an omnipresent virtual stack.
   Almost all API calls operate on values on this stack. All data exchange from Lua to C and
   from C to Lua occurs through this stack. Moreover, we can use the stack to keep intermediate
   results, too...

   Lua manipulates this stack in a strict LIFO discipline (Last In, First Out). When we call Lua,
   it changes only the top part of the stack. Our C code has more freedom; specifically, it can
   inspect any element in the stack and even insert and delete elements at any position."

   — *Programming in Lua*, Roberto Ierusalimschy

  "...the stack allows the programmer to control the lifetime of any object in a safe way. While an
   object is in the stack, it cannot be collected; once out of the stack, it cannot be manipulated.
   Moreover, the stack offers a natural way to pass parameters and results."

   — *Passing a Language through the Eye of a Needle*, Ierusalimschy, Henrique de Figueiredo, and Celes
#+end_quote

*** Pushing Elements

The API has a dedicated push function for each Lua type with a direct representation in C.

#+begin_src c
  LUA_API void        (lua_pushnil)           (lua_State *L);
  LUA_API void        (lua_pushboolean)       (lua_State *L, int bool);
  LUA_API void        (lua_pushnumber)        (lua_State *L, lua_Number n);
  LUA_API void        (lua_pushinteger)       (lua_State *L, lua_Integer n);
  LUA_API const char *(lua_pushlstring)       (lua_State *L, const char *s, size_t len);
  LUA_API const char *(lua_pushstring)        (lua_State *L, const char *s);

  LUA_API void        (lua_pushcclosure)      (lua_State *L, lua_CFunction fn, int n);
  LUA_API void        (lua_pushlightuserdata) (lua_State *L, void *p);
  LUA_API int         (lua_pushthread)        (lua_State *L);

  // If possible, grows stack to accomodate "sz" number of slots.
  // Otherwise returns zero.
  LUA_API int         (lua_checkstack)        (lua_State *L, int sz);

  // Similar to "lua_checkstack" but raises an error with the given message
  // if unable to complete operation.
  LUALIB_API void     (luaL_checkstack)       (lua_State *L, int sz, const char *msg);
#+end_src

*** Indexing Elements

#+begin_quote
  "To refer to elements on the stack, the API uses indices. The first element pushed on the stack
   has index 1, the next one has index 2, and so on. We can also access elements using the top of
   the stack as our reference, with negative indices."

   — *Programming in Lua*, Roberto Ierusalimschy
#+end_quote

#+begin_src c
  static void dump_stack (lua_State *L) {
    int i;
    // Stack depth
    int top = lua_gettop(L);
    // Iterate through stack
    for (i = 1; i <= top; i += 1) {
      int t = lua_type(L, i);
      switch (t) {
        case LUA_TSTRING: {
          printf("'%s'", lua_tostring(L, i));
          break;
        }
        case LUA_TBOOLEAN: {
          printf(lua_toboolean(L, i) ? "true" : "false");
          break;
        }
        case LUA_TNUMBER: {
          if (lua_isinteger(L, i)) {
            printf("%lld", lua_tointeger(L, i));
          } else {
            printf("%g", lua_tonumber(L, i));
          }
          break;
        }
        default: {
          printf("%s", lua_typename(L, t));
          break;
        }
      }
      // Separator
      printf(" ");
    }
    // End
    printf("\n");
  }
#+end_src

*** Basic Stack Manipulation

#+begin_src c
  // Returns the number of elements on the stack, which is also the top element's index.
  LUA_API int  (lua_gettop)    (lua_State *L);

  // Sets the number of elements on the stack. lua_settop(L, 0) empties the stack.
  LUA_API void (lua_settop)    (lua_State *L, int idx);

  // Pushes onto the stack a copy of the element at the given index.
  LUA_API void (lua_pushvalue) (lua_State *L, int idx);

  // Rotates the stack elements from the given index to the top of the stack by "n" positions.
  LUA_API void (lua_rotate)    (lua_State *L, int idx, int n);

  // Copies the element at one index into another, leaving the original untouched.
  LUA_API void (lua_copy)      (lua_State *L, int fromidx, int toidx);

  // Removes element at given index, shifting elements above it to fill in the gap.
  #define lua_remove(L, idx)   (lua_rotate(L, (idx), -1), lua_pop(L, 1))

  // Inserts top element into given index, shifting elements above to open space.
  #define lua_insert(L, idx)   lua_rotate(L, (idx), 1)

  // Pops an element and sets it at the given index.
  #define lua_replace(L, idx)  (lua_copy(L, -1, (idx)), lua_pop(L, 1))

  // Pops n elements from the stack.
  #define lua_pop(L, n)        lua_settop(L, -(n) - 1)
#+end_src

| function                          | stack                                 |
|-----------------------------------+---------------------------------------|
| ~lua_State *L = luaL_newstate();~ | []                                    |
| ~lua_pushboolean(L, 1);~          | [ true ]                              |
| ~lua_pushnumber(L, 10);~          | [ true, 10 ]                          |
| ~lua_pushnil(L);~                 | [ true, 10, nil ]                     |
| ~lua_pushstring(L, "hello");~     | [ true, 10, nil, "hello" ]            |
| ~lua_pushvalue(L, -4);~           | [ true, 10, nil, "hello", true ]      |
| ~lua_replace(L, 3);~              | [ true, 10, true, "hello" ]           |
| ~lua_settop(L, -5);~              | [ true, 10, true, "hello", nil, nil ] |
| ~lua_rotate(L, 3, 1);~            | [ true, 10, nil, true, "hello", nil ] |
| ~lua_remove(L, -3);~              | [ true, 10, nil, "hello", nil ]       |
| ~lua_settop(L, -5);~              | [ true ]                              |
| ~lua_close(L);~                   |                                       |

** Calling Functions from C

#+begin_src c
  // === Lua Function Call ===
  //
  // a = f("how", t.x, 14)

  // === C Function Call ===

  // Function to be called.
  lua_getglobal(L, "f");
  // 1st argument.
  lua_pushliteral(L, "how");
  // Table to be indexed.
  lua_getglobal(L, "t");
  // Push the result of 2nd argument "t.x".
  lua_getfield(L, -1, "x");
  // Remove "t" from the stack.
  lua_remove(L, -2);
  // 3rd argument.
  lua_pushinteger(L, 14);
  // Call "f" with 3 arguments and 1 result.
  lua_call(L, 3, 1);
  // Set global "a".
  lua_setglobal(L, "a");
#+end_src

** Lua Standalone Interpreter

Lua is implemented not as a standalone program, but as a C library. The standalone Lua interpreter
is an interface that feeds files and strings from the user to the Lua library.

#+begin_src c
  // === Standard Libraries ===
  // Portions from "linit.c" and "lauxlib.c".

  static const luaL_Reg loadedlibs[] = {
    { LUA_GNAME,       luaopen_base },
    { LUA_LOADLIBNAME, luaopen_package },
    { LUA_COLIBNAME,   luaopen_coroutine },
    { LUA_TABLIBNAME,  luaopen_table },
    { LUA_IOLIBNAME,   luaopen_io },
    { LUA_OSLIBNAME,   luaopen_os },
    { LUA_STRLIBNAME,  luaopen_string },
    { LUA_MATHLIBNAME, luaopen_math },
    { LUA_UTF8LIBNAME, luaopen_utf8 },
    { LUA_DBLIBNAME,   luaopen_debug },
    { NULL,            NULL }
  };

  LUALIB_API void luaL_openlibs (lua_State *L) {
    const luaL_Reg *lib;
    for (lib = loadedlibs; lib->func; lib++) {
      luaL_requiref(L, lib->name, lib->func, 1);
      lua_pop(L, 1);
    }
  }

  LUALIB_API void luaL_requiref (lua_State *L, const char *modname, lua_CFunction openf, int glb) {
    luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
    // LOADED[modname]
    lua_getfield(L, -1, modname);
     // Package not already loaded?
    if (!lua_toboolean(L, -1)) {
      // Remove field.
      lua_pop(L, 1);
      lua_pushcfunction(L, openf);
      // Argument to open function.
      lua_pushstring(L, modname);
      // Call "openf" to open module.
      lua_call(L, 1, 1);
      // Make copy of module (call result).
      lua_pushvalue(L, -1);
      // LOADED[modname] = module
      lua_setfield(L, -3, modname);
    }
    // Remove LOADED table.
    lua_remove(L, -2);
    if (glb) {
      // Copy of module.
      lua_pushvalue(L, -1);
      // _G[modname] = module
      lua_setglobal(L, modname);
    }
  }

  // === Lua Standalone Interpreter ===
  // Portions from "lua.c".

  // Main body of the Lua stand-alone intepreter. Called in protected mode.
  // Parses and handles all arguments to the main program.
  static int pmain (lua_State *L) {
    int argc = (int)lua_tointeger(L, 1);
    char **argv = (char **)lua_touserdata(L, 2);
    int script;
    // Traverses all arguments from "argv". Returns a mask of those
    // arguments before running any Lua code. Returns an error code if it
    // finds any invalid arguments.
    int args = collectargs(argv, &script);

    // First argument is not an option.
    int optlim = (script > 0) ? script : argc;
    // Check that interpreter has the correct version.
    luaL_checkversion(L);

    // Bad arguments?
    if (args == has_error) {
      print_usage(argv[script]);
      return 0;
    }
    // Option '-v'?
    if (args & has_v) {
      print_version();
    }
    // Option '-E'?
    if (args & has_E) {
      lua_pushboolean(L, 1);
      // Signal for libraries to ignore environment variables.
      lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
    }
    // Open standard libraries.
    luaL_openlibs(L);
    // Create table 'arg'
    createargtable(L, argv, argc, script);
    // Start GC in generational mode.
    lua_gc(L, LUA_GCRESTART);
    lua_gc(L, LUA_GCGEN, 0, 0);
    // No option '-E'?
    if (!(args & has_E)) {
      // Run LUA_INIT
      if (handle_luainit(L) != LUA_OK) {
        return 0;
      }
    }
    // Execute arguments '-e' and '-l'.
    if (!runargs(L, argv, optlim))
      return 0;
    // Execute main script (if there is one).
    if (script > 0) {
      if (handle_script(L, argv + script) != LUA_OK)
        return 0;
    }
    // If -i option, run read-eval-print loop.
    if (args & has_i) {
      doREPL(L);
    } else if (script < 1 && !(args & (has_e | has_v))) {
      if (lua_stdin_is_tty()) {
        print_version();
        doREPL(L);
      } else {
        // Executes stdin as a file.
        dofile(L, NULL);
      }
    }
    // Signal no errors.
    lua_pushboolean(L, 1);
    return 1;
  }

  // The requisite main program as implemented in the Lua stand-alone interpreter.
  int main (int argc, char *argv[]) {
    int status, result;
    // Create thread state.
    lua_State *L = luaL_newstate();
    if (L == NULL) {
      l_message(argv[0], "cannot create state: not enough memory");
      return EXIT_FAILURE;
    }
    // Stop garbage collection while building state
    lua_gc(L, LUA_GCSTOP);
    // Prepare call to 'pmain' in protected mode.
    lua_pushcfunction(L, &pmain);
    // 1st argument.
    lua_pushinteger(L, argc);
    // 2nd argument.
    lua_pushlightuserdata(L, argv);
    // Call 'pmain'.
    status = lua_pcall(L, 2, 1, 0);
    // Get result.
    result = lua_toboolean(L, -1);
    report(L, status);
    lua_close(L);
    return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
  }
#+end_src

** Lua C Map Function

#+begin_src c
  // === C API ===

  lua_State *L = luaL_newstate();
  luaL_openlibs(L);

  int f_map (lua_State *L) {
    int i, n;

    // 1st argument must be a table (t).
    luaL_checktype(L, 1, LUA_TTABLE);

    // 2nd argument must be a function (f).
    luaL_checktype(L, 2, LUA_TFUNCTION);

    // Get size of table
    n = luaL_len(L, 1);

    for (i = 1; i <= n; i += 1) {
      // Push f
      lua_pushvalue(L, 2);
      // Push t[i]
      lua_geti(L, 1, i);
      // Call f(t[i])
      lua_call(L, 1, 1);
      // t[i] = result
      lua_seti(L, 1, i);
    }
    // Number of results left on the stack.
    return 0;
  }

  lua_pushfunction(L, f_map);
  lua_setglobal(L, "map");

  // === Lua ===
  //
  // array = { 1, 2, 3, 4 }
  // map(array, function (x) return x * x end)
  // array --> { 1, 4, 9, 16 }
#+end_src

** Lua C String Function

#+begin_src c
  // === C API ===

  lua_State *L = luaL_newstate();
  luaL_openlibs(L);

  // Uppercase a string, using a buffer.
  static int f_uppercase (lua_State *L) {
    size_t l;
    size_t i;
    // Declare a buffer.
    luaL_Buffer b;

    // Ensure argument is a string.
    const char *s = luaL_checklstring(L, 1, &l);

    // Initialize buffer.
    char *p = luaL_buffinitsize(L, &b, l);

    // For each character in the buffer, uppercase that character.
    for (i = 0; i < l; i += 1) {
      p[i] = toupper(uchar(s[i]));
    }

    // Flush buffer. Leave resulting string on the stack.
    luaL_pushresultsize(&b, l);

    // Number of results left on the stack.
    return 1;
  }

  lua_pushfunction(L, f_uppercase);
  lua_setglobal(L, "uppercase");

  // === Lua ===
  //
  // uppercase("abc") -->  "ABC"
#+end_src

Lua's generic buffer implementation.

#+begin_src c
  // LUAI_MAXALIGN defines fields that, when used in a union, ensure
  // maximum alignment for the other items in that union.
  //
  // LUAI_MAXALIGN -> lua_Number n; double u; void *s; lua_Integer i; long l

  struct luaL_Buffer {
    char *b;      // Buffer address
    size_t size;  // Buffer size
    size_t n;     // Number of characters in buffer
    lua_State *L;
    union {
      LUAI_MAXALIGN;            // Ensure maximum alignment for buffer
      char b[LUAL_BUFFERSIZE];  // Initial buffer
    } init;
  };
#+end_src

** Lua C Bit Array

#+begin_src c
  #include <stddef.h>
  #include <limits.h>

  #include "lua.h"
  #include "lauxlib.h"

  // Boolean arrays where each entry is stored in a single bit.

  // Number of bits in an unsigned integer.
  #define BITS_PER_WORD (CHAR_BIT * sizeof(unsigned int))
  // Word that stores bit that corresponds to a given index.
  #define I_WORD(i) ((unsigned int)(i) / BITS_PER_WORD)
  // Mask to access the correct bit inside the word.
  #define I_BIT(i) (1 << ((unsigned int)(i) % BITS_PER_WORD))

  #define checkarray(L) (BitArray *)luaL_checkudata(L, 1, "LuaBook.array")

  typedef struct BitArray {
    int size;
    // Variable part. "values[1]" is a placeholder. This is the C89 idiom
    // for declaring variable-sized arrays inside structs. C99 would declare
    // "values[]" instead. This syntax is called the "flexible array member".
    unsigned int values[1];
  } BitArray;

  static int newarray(lua_State *L) {
    int i;
    size_t nbytes;
    BitArray *a;

    // Number of bits
    int n = (int)luaL_checkinteger(L, 1);
    luaL_argcheck(L, n >= 1, 1, "invalid size");
    // The size of an array with "n" elements. Subtracts one from "n"
    // because the original structure already includes space for one
    // element.
    nbytes = sizeof(BitArray) + I_WORD(n - 1) * sizeof(unsigned int);
    a = (BitArray *)lua_newuserdata(L, nbytes);

    a->size = n;
    for (i = 0; i <= I_WORD(n - 1); i++) {
        // Initialize array.
        a->values[i] = 0;
    }

    luaL_getmetatable(L, "LuaBook.array");
    lua_setmetatable(L, -2);

    // New userdata is already on the stack.
    return 1;
  }

  static int getsize(lua_State *L) {
    BitArray *a = checkarray(L);
    lua_pushinteger(L, a->size);
    return 1;
  }

  static unsigned int *getparams(lua_State *L, unsigned int *mask) {
    BitArray *a = checkarray(L);
    int index = (int)luaL_checkinteger(L, 2) - 1;

    luaL_argcheck(L, 0 <= index && index < a->size, 2, "index out of range");

    // Mask to access correct bit.
    *mask = I_BIT(index);
    // Word address.
    return &a->values[I_WORD(index)];
  }

  static int setarray(lua_State *L) {
    unsigned int mask;
    unsigned int *entry = getparams(L, &mask);
    luaL_checkany(L, 3);
    if (lua_toboolean(L, 3)) {
      *entry |= mask;
    } else {
      *entry &= ~mask;
    }
    return 0;
  }

  static int getarray(lua_State *L) {
    unsigned int mask;
    unsigned int *entry = getparams(L, &mask);
    lua_pushboolean(L, *entry & mask);
    return 1;
  }

  int array2string(lua_State *L) {
    BitArray *a = checkarray(L);
    lua_pushfstring(L, "array(%d)", a->size);
    return 1;
  }

  static const struct luaL_Reg arraylib_f[] = {
    { "new", newarray },
    { NULL,  NULL }};

  static const struct luaL_Reg arraylib_m[] = {
    { "__newindex", setarray },
    { "__index",    getarray },
    { "__len",      getsize },
    { "__tostring", array2string },
    { NULL,         NULL }};

  int luaopen_array(lua_State *L) {
    luaL_newmetatable(L, "LuaBook.array");
    luaL_setfuncs(L, arraylib_m, 0);
    luaL_newlib(L, arraylib_f);
    return 1;
  }
#+end_src

** Lua C Directory Iterator

#+begin_src c
  // === Lua Iterator ==
  //
  // for fname in dir.open(".") do
  //     print(fname)
  // end

  // === C Implmentation ===

  #include <dirent.h>
  #include <errno.h>
  #include <string.h>

  #include "lua.h"
  #include "lauxlib.h"

  // Forward declaration for the iterator function.
  static int dir_iter (lua_State *L);

  static int lua_dir (lua_State *L) {
    const char *path = luaL_checkstring(L, 1);

    // Create a userdata to store a DIR address.
    DIR **d = (DIR **)lua_newuserdata(L, sizeof(DIR *));

    // Pre-initialize
    *d = NULL;

    // Set its metatable.
    luaL_getmetatable(L, "LuaBook.dir");
    lua_setmetatable(L, -2);

    // Try to open the given directory.
    *d = opendir(path);
    // Error opening the directory?
    if (*d == NULL) {
      luaL_error(L, "cannot open %s: %s", path, strerror(errno));
    }
    // Creates and returns the iterator function. Its sole upvalue,
    // the directory userdata, is already on the top of the stack.
    lua_pushcclosure(L, dir_iter, 1);
    return 1;
  }

  // Iterator.
  static int dir_iter (lua_State *L) {
    DIR *d = *(DIR **)lua_touserdata(L, lua_upvalueindex(1));
    struct dirent *entry = readdir(d);
    if (entry != NULL) {
      lua_pushstring(L, entry->d_name);
      return 1;
    } else {
      // No more values to return.
      return 0;
    }
  }

  // Garbage collection metamethod.
  static int dir_gc (lua_State *L) {
    DIR *d = *(DIR **)lua_touserdata(L, 1);
    if (d) {
      closedir(d);
    }
    return 0;
  }

  // Add function to registry.
  static const struct luaL_Reg dirlib [] = {
    { "open", lua_dir },
    { NULL,   NULL }
  };

  // Open one-function library.
  int luaopen_dir (lua_State *L) {
    luaL_newmetatable(L, "LuaBook.dir");

    // Set its __gc field.
    lua_pushcfunction(L, dir_gc);
    lua_setfield(L, -2, "__gc");

    // Create the library.
    luaL_newlib(L, dirlib);
    return 1;
  }
#+end_src
