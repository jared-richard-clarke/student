* Lua's C API

** Sources

| source                        | author                                                                       |
|-------------------------------+------------------------------------------------------------------------------|
| *A Look at the Design of Lua* | Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes Filho |
| *Programming in Lua*          | Roberto Ierusalimschy                                                                             |

** Lua Standalone Interpreter

Lua is implemented not as a standalone program, but as a library with a C API.
The standalone Lua interpreter is a tiny application written on top of the C library.

#+begin_src c
  // Main body of the Lua stand-alone intepreter. Called in protected mode.
  // Parses and handles all arguments to the main program.
  static int pmain (lua_State *L) {
    int argc = (int)lua_tointeger(L, 1);
    char **argv = (char **)lua_touserdata(L, 2);
    int script;
    int args = collectargs(argv, &script);

    // First argument is not an option.
    int optlim = (script > 0) ? script : argc;
    // Check that interpreter has the correct version.
    luaL_checkversion(L);

    // Bad arguments?
    if (args == has_error) {
      print_usage(argv[script]);
      return 0;
    }
    // Option '-v'?
    if (args & has_v) {
      print_version();
    }
    // Option '-E'?
    if (args & has_E) {
      lua_pushboolean(L, 1);
      // Signal for libraries to ignore environment variables.
      lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
    }
    // Open standard libraries.
    luaL_openlibs(L);
    // Create table 'arg'
    createargtable(L, argv, argc, script);
    // Start GC in generational mode.
    lua_gc(L, LUA_GCRESTART);
    lua_gc(L, LUA_GCGEN, 0, 0);
    // No option '-E'?
    if (!(args & has_E)) {
      // Run LUA_INIT
      if (handle_luainit(L) != LUA_OK) {
        return 0;
      }
    }
    // Execute arguments '-e' and '-l'.
    if (!runargs(L, argv, optlim))
      return 0;
    // Execute main script (if there is one).
    if (script > 0) {
      if (handle_script(L, argv + script) != LUA_OK)
        return 0;
    }
    // If -i option, run read-eval-print loop.
    if (args & has_i) {
      doREPL(L);
    } else if (script < 1 && !(args & (has_e | has_v))) {
      if (lua_stdin_is_tty()) {
        print_version();
        doREPL(L);
      } else {
        // Executes stdin as a file.
        dofile(L, NULL);
      }
    }
    // Signal no errors.
    lua_pushboolean(L, 1);
    return 1;
  }

  // The requisite main program as implemented in the Lua stand-alone interpreter.
  int main (int argc, char *argv[]) {
    int status, result;
    // Create thread state.
    lua_State *L = luaL_newstate();
    if (L == NULL) {
      l_message(argv[0], "cannot create state: not enough memory");
      return EXIT_FAILURE;
    }
    // Stop garbage collection while building state
    lua_gc(L, LUA_GCSTOP);
    // Prepare call to 'pmain' in protected mode.
    lua_pushcfunction(L, &pmain);
    // 1st argument.
    lua_pushinteger(L, argc);
    // 2nd argument.
    lua_pushlightuserdata(L, argv);
    // Call 'pmain'.
    status = lua_pcall(L, 2, 1, 0);
    // Get result.
    result = lua_toboolean(L, -1);
    report(L, status);
    lua_close(L);
    return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
  }
#+end_src

** Lua Map Function

An implementation of the map function using Lua's C API.

#+begin_src c
  int lua_map (lua_State *L) {
    int i, n;

    // 1st argument must be a table (t).
    luaL_checktype(L, 1, LUA_TTABLE);

    // 2nd argument must be a function (f).
    luaL_checktype(L, 2, LUA_TFUNCTION);

    // Get size of table
    n = luaL_getn(L, 1);

    for (i = 1; i <= n; i += 1) {
      // Push f
      lua_pushvalue(L, 2);
      // Push t[i]
      lua_rawgeti(L, 1, i);
      // Call f(t[i])
      lua_call(L, 1, 1);
      // t[i] = result
      lua_rawseti(L, 1, i);
    }

    return 0;
  }
#+end_src

** Lua Uppercase Function

An implementation of an uppercasing function using Lua's C API.

#+begin_src c
  static int lua_uppercase (lua_State *L) {
    size_t l;
    size_t i;
    // Declare a buffer.
    luaL_Buffer b;

    // Ensure argument is a string.
    const char *s = luaL_checklstr(L, 1, &l);

    // Initialize buffer.
    luaL_buffinit(L, &b);

    // For each character in the string, uppercase that character,
    // and then push the result onto the buffer.
    for (i = 0; i < l; i += 1) {
      luaL_putchar(&b, toupper((unsigned char)(s[i])));
    }

    // Flush buffer. Leave resulting string on the stack.
    luaL_pushresult(&b);

    return 1;
  }
#+end_src
