* Syntactic Abstraction in Scheme

** Sources

| source                            | author                                          |
|-----------------------------------+-------------------------------------------------|
| *Syntactic Abstraction in Scheme* | R. Kent Dybvig, Robert Hieb, and Carl Bruggeman |

** Introduction

- The capturing problem :: A fundamental problem with traditional Lisp macro systems is
  that they do not respect lexical scoping. When one expression is substituted for another,
  apparent bindings can be shadowed, resulting in unintended capture of identifier references.

Dybvig, Hieb, and Bruggeman present a macro system for Scheme that enforces hygiene automatically
while maintaining the correlation between source and object code for debuggers and optimizing
compilers:

- Enforces hygiene with constant overhead for macros written in a full, general-purpose language.

- Solves the source-object correlation problem for variables and constants as well as structured
  expressions.

- Supplies a hygiene-preserving mechanism for controlled identifier capture.

- Maintain referential transparency for all local macros.

- Provides automatic syntax checking, input destructuring, and output restructuring for low-level
  macros.

*** Identifier Capture

#+begin_src scheme
  ;; 1. Macro identifiers capture runtime identifiers.
  (let ([t "okay"])
    (or #f t))

  ;; === naive expansion ===
  ;; where (or e1 e2) -> (let ([t e1]) (if t t e2))
  (let ([t "okay"])
    (let ([t #f])
      (if t t t)))

  ;; 2. Runtime identifiers capture macro identifiers.
  (let ([if #f])
    (or if "okay"))

  ;; === naive expansion ===
  ;; where (or e1 e2) -> (let ([t e1]) (if t t e2))
  (let ([if #f])
    (let ([t if])
      (if t t "okay")))
#+end_src

** The Language

New syntactic forms, or macros, are defined by associating keywords with transformation
procedures, or transformers. When the macro expander encounters a macro call, the macro
call expression is passed to the associated transformer to be processed. The expansion
process is repeated for the result returned by the transformer until no macro calls remain.

#+begin_src scheme
  ;; === macro calls ===
  (keyword sub-form ...)

  ;; === macro definition and binding ===
  (define-syntax <keyword> <transformer>)

  (let-syntax ([<keyword> <transformer>] ...) <body>)

  (letrec-syntax ([<keyword> <transformer>] ...) <body>)

  ;; === destructuring and restructuring ===
  (syntax-case <input> (<literal> ...)
    (<pattern> <fender> <expression>)
    ...)

  (syntax <template>)

  (syntax->datum <syntax>)

  (datum->syntax <identifier> <datum>)

  ;; === predicates ===
  (identifier? <object>)
  (free-identifier=?  <identifier-1> <identifier-2>)

  (bound-identifier=? <identifier-1> <identifier-2>)
#+end_src

- syntax object :: The argument to a macro transformer, a syntax object contains contextual
  information about an expression in addition to its structure. This contextual information
  is used by the expander to maintain hygiene and referential transparency. Transformers can
  compare identifiers according to their use as free identifiers, bound identifiers, or
  symbolic data.

#+begin_src scheme
  ;; Hygiene dictates that the binding for "t" is visible only within code
  ;; introduced by the macro, not within forms introduced by the macro call.
  (define-syntax or
    (lambda (x)
      (syntax-case x ()
        [(_)   (syntax #f)]
        [(_ e) (syntax e)]
        [(_ e1 e2 e3 ...)
         (syntax (let ([t e1])
                   (if t t (or e2 e3))))])))

  ;; === "syntax-rules" defined by "syntax-case" ===
  (define-syntax syntax-rules
    (lambda (x)
      (syntax-case x ()
        [(_ (i ...) ((keyword . pattern) template) ...)
         (syntax (lambda (x)
                   (syntax-case x (i ...)
                     ((_ . pattern) (syntax template)) ...)))])))

  ;; === "with-syntax" defined by "syntax-case" ===
  (define-syntax with-syntax
    (lambda (x)
      (syntax-case x ()
        [(_ ((p s) ...) e1 e2 ...)
         (syntax (syntax-case (list s ...) ()
                   [(p ...) (begin e1 e2 ...)]))])))
#+end_src

** Traditional Macro-Expansion Algorithm (Simplified)

#+begin_example
  # === Macro Expansion Algorithm ===

  expand: Expression × Environment -> Expanded-Expression
  expand(e, r) =
    case parse(e, r) of:
      constant(c)             -> symbolic-data(c)
      variable(s)             -> variable(s)
      application(e1, e2)     -> application(expand(e1, r), expand(e2, r))
      symbolic-data(e)        -> symbolic-data(e)
      function(s, e)          -> function(s, expand(e, r[s := Variable]))
      macro-application(s, e) -> expand(t(e), r) where t = r(s)

      r ∈ Environment = Symbol -> Transformer + { Variable } + { Special }
        where Special = "quote" and "lambda"

      t ∈ Transformer = Expression -> Expression

      # === Macro Expansion Parser ===

      parse: Expression × Environment -> Parsed-Expression

      parse(⟦c⟧, r)            = constant(c)
      parse(⟦s⟧, r)            = variable(s) if r(s) = Variable
      parse(⟦(e1 e2)⟧, r)      = application(e1, e2) if e1 ∉ Symbol
      parse(⟦(s e)⟧, r)        = macro-application(s, e) if r(s) ∈ Transformer
      parse(⟦(quote e)⟧, r)    = symbolic-data(e) if r(⟦quote⟧) = Special
      parse(⟦(lambda s e)⟧, r) = function(s, e) if r(⟦lambda⟧) = Special
#+end_example

** Substitution-Based Macro-Expansion Algorithm

#+begin_example
  # === Macro Expansion Algorithm ===

  expand: Expression × Environment -> Expanded-Expression
  expand(e, r) =
    case parse(e, r) of:
      variable(i)                   -> variable(resolve(i))
      application(e1, e2)           -> application(expand(e1, r), expand(e2, r))
      symbolic-data(e)              -> symbolic-data(strip(e))
      syntax-data(e)                -> symbolic-data(e)
      function(i, e)                -> function(s, expand(subst(e, i, s), r'))
                                         where r' = r[s := Variable] and s is fresh
      pfunction(i, e)               -> function(s, expand(subst(e, i, s), r'))
                                         where r' = r[s := PVariable] and s is fresh
      macro-application(i, e)       -> expand(mark(t(mark(e, m)), m), r)
                                         where t = r(resolve(i)) and m is fresh
      syntax-binding(i, e1, e2)     -> expand(subst(e2, i, s), r[s := t])
                                         where t = eval(expand(e1, r)) and s is fresh
      rec-syntax-binding(i, e1, e2) -> expand(subst(e2, i, s), r[s := t])
                                         where t = eval(expand(subst(e1, i, s), r)) and s is fresh

      Environment = Symbol -> Transformer + { Variable } + { PVariable } + { Special }

  # === Macro-Expansion Parser ===

  parse: Expression × Environment -> Parsed-Expression

  parse(⟦c⟧, r)                       = symbolic-data(c)
  parse(⟦i⟧, r)                       = variable(i) if r(resolve(i)) = Variable
  parse(⟦(e1 e2)⟧, r)                 = application(e1, e2) if e1 ∉ Symbol
  parse(⟦(i e)⟧, r)                   = application(i, e) if r(resolve(i)) = Variable
  parse(⟦i e⟧, r)                     = macro-application(i, e) if r(resolve(i)) ∈ Transformer
  parse(⟦(quote e)⟧, r)               = symbolic-data(e) if r(⟦quote⟧) = Special
  parse(⟦(lambda i e)⟧, r)            = function(i, e) if r(⟦lambda⟧) = Special
  parse(⟦(plambda i e)⟧, r)           = pfunction(i, e) if r(⟦plambda⟧) = Special
  parse(⟦(syntax i)⟧, r)              = syntax-data(i) if r(resolve(i)) ≠ PVariable
  parse(⟦(syntax i)⟧, r)              = variable(i) if r(resolve(i)) = PVariable
  parse(⟦(let-syntax (i e1) e2)⟧, r)  = syntax-binding(i, e1, e2) if r(⟦let-syntax⟧) = Special
  parse(⟦letrec-syntax (i e1) e2⟧, r) = rec-syntax-binding(i, e1, e2) if r(⟦letrec-syntax⟧) = Special
#+end_example
