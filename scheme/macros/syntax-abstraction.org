* Syntactic Abstraction in Scheme

** Sources

| source                            | author                                          |
|-----------------------------------+-------------------------------------------------|
| *Syntactic Abstraction in Scheme* | R. Kent Dybvig, Robert Hieb, and Carl Bruggeman |
| *Hygienic Macro Technology*       | William D. Clinger and Mitchell Wand            |

** Introduction

- The capturing problem :: A fundamental problem with traditional Lisp macro systems is
  that they do not respect lexical scoping. Moving a piece of syntax from one place to
  another might lead to the accidental rebinding of a program's identifiers.

Dybvig, Hieb, and Bruggeman present a macro system for Scheme that enforces hygiene automatically
while maintaining the correlation between source and object code for debuggers and optimizing
compilers:

- Enforces hygiene with constant overhead for macros written in a full, general-purpose language.

- Solves the source-object correlation problem for variables and constants as well as structured
  expressions.

- Supplies a hygiene-preserving mechanism for controlled identifier capture.

- Maintain referential transparency for all local macros.

- Provides automatic syntax checking, input destructuring, and output restructuring for low-level
  macros.

*** Identifier Capture

#+begin_src scheme
  ;; 1. Macro identifiers capture runtime identifiers.
  (let ([t "okay"])
    (or #f t))

  ;; === naive expansion ===
  ;; where (or e1 e2) -> (let ([t e1]) (if t t e2))
  (let ([t "okay"])
    (let ([t #f])
      (if t t t)))

  ;; 2. Runtime identifiers capture macro identifiers.
  (let ([if #f])
    (or if "okay"))

  ;; === naive expansion ===
  ;; where (or e1 e2) -> (let ([t e1]) (if t t e2))
  (let ([if #f])
    (let ([t if])
      (if t t "okay")))
#+end_src

** The Language

New syntactic forms, or macros, are defined by associating keywords with transformation
procedures, or transformers. When the macro expander encounters a macro call, the macro
call expression is passed to the associated transformer to be processed. The expansion
process is repeated for the result returned by the transformer until no macro calls remain.

#+begin_src scheme
  ;; === macro calls ===
  (keyword sub-form ...)

  ;; === macro definition and binding ===
  (define-syntax keyword transformer)

  (let-syntax ([keyword transformer] ...) body)

  (letrec-syntax ([keyword transformer] ...) body)

  ;; === destructuring and restructuring ===
  (syntax-case input (literal ...)
    (pattern fender expression) ...)

  (syntax template)

  (syntax->datum syntax)

  (datum->syntax identifier datum)

  ;; === predicates ===
  (identifier? object)

  (free-identifier=?  identifier-1 identifier-2)

  (bound-identifier=? identifier-1 identifier-2)
#+end_src

- syntax object :: The argument to a macro transformer, a syntax object contains contextual
  information about an expression in addition to its structure. This contextual information
  is used by the expander to maintain hygiene and referential transparency. Transformers can
  compare identifiers according to their use as free identifiers, bound identifiers, or
  symbolic data.

#+begin_src scheme
  ;; Hygiene dictates that the binding for "t" is visible only within code
  ;; introduced by the macro, not within forms introduced by the macro call.
  (define-syntax or
    (lambda (x)
      (syntax-case x ()
        [(_)   (syntax #f)]
        [(_ e) (syntax e)]
        [(_ e1 e2 e3 ...)
         (syntax (let ([t e1])
                   (if t t (or e2 e3))))])))

  ;; === "syntax-rules" defined by "syntax-case" ===
  (define-syntax syntax-rules
    (lambda (x)
      (syntax-case x ()
        [(_ (i ...) ((keyword . pattern) template) ...)
         (syntax (lambda (x)
                   (syntax-case x (i ...)
                     ((_ . pattern) (syntax template)) ...)))])))

  ;; === "with-syntax" defined by "syntax-case" ===
  (define-syntax with-syntax
    (lambda (x)
      (syntax-case x ()
        [(_ ((p s) ...) e1 e2 ...)
         (syntax (syntax-case (list s ...) ()
                   [(p ...) (begin e1 e2 ...)]))])))
#+end_src

** Traditional Macro-Expansion Algorithm (Simplified)

#+begin_example
  # === Macro Expansion Algorithm ===

  expand: Expression × Environment -> Expanded-Expression

  expand(e, r) =
    case parse(e, r) of:

      constant(c)             -> symbolic-data(c)

      variable(s)             -> variable(s)

      application(e1, e2)     -> application(expand(e1, r), expand(e2, r))

      symbolic-data(e)        -> symbolic-data(e)

      function(s, e)          -> function(s, expand(e, r[s := Variable]))

      macro-application(s, e) -> expand(t(e), r) where t = r(s)

      r ∈ Environment = Symbol -> Transformer + { Variable } + { Special }
        where Special = "quote" and "lambda"

      t ∈ Transformer = Expression -> Expression

      # === Macro Expansion Parser ===

      parse: Expression × Environment -> Parsed-Expression

      parse(⟦c⟧, r)            = constant(c)

      parse(⟦s⟧, r)            = variable(s) if r(s) = Variable

      parse(⟦(e1 e2)⟧, r)      = application(e1, e2) if e1 ∉ Symbol

      parse(⟦(s e)⟧, r)        = macro-application(s, e) if r(s) ∈ Transformer

      parse(⟦(quote e)⟧, r)    = symbolic-data(e) if r(⟦quote⟧) = Special

      parse(⟦(lambda s e)⟧, r) = function(s, e) if r(⟦lambda⟧) = Special
#+end_example

** Substitution-Based Macro-Expansion Algorithm

#+begin_example
  # === Macro Expansion Algorithm ===

  expand: Expression × Environment -> Expanded-Expression

  expand(e, r) =
    case parse(e, r) of:

      variable(i)                   -> variable(resolve(i))

      application(e1, e2)           -> application(expand(e1, r), expand(e2, r))

      symbolic-data(e)              -> symbolic-data(strip(e))

      syntax-data(e)                -> symbolic-data(e)

      function(i, e)                -> function(s, expand(subst(e, i, s), r'))
                                         where r' = r[s := Variable] and s is fresh

      pfunction(i, e)               -> function(s, expand(subst(e, i, s), r'))
                                         where r' = r[s := PVariable] and s is fresh

      macro-application(i, e)       -> expand(mark(t(mark(e, m)), m), r)
                                         where t = r(resolve(i)) and m is fresh

      syntax-binding(i, e1, e2)     -> expand(subst(e2, i, s), r[s := t])
                                         where t = eval(expand(e1, r)) and s is fresh

      rec-syntax-binding(i, e1, e2) -> expand(subst(e2, i, s), r[s := t])
                                         where t = eval(expand(subst(e1, i, s), r)) and s is fresh

      Environment = Symbol -> Transformer + { Variable } + { PVariable } + { Special }

  # === Macro-Expansion Parser ===

  parse: Expression × Environment -> Parsed-Expression

  parse(⟦c⟧, r)                       = symbolic-data(c)

  parse(⟦i⟧, r)                       = variable(i) if r(resolve(i)) = Variable

  parse(⟦(e1 e2)⟧, r)                 = application(e1, e2) if e1 ∉ Symbol

  parse(⟦(i e)⟧, r)                   = application(i, e) if r(resolve(i)) = Variable

  parse(⟦i e⟧, r)                     = macro-application(i, e) if r(resolve(i)) ∈ Transformer

  parse(⟦(quote e)⟧, r)               = symbolic-data(e) if r(⟦quote⟧) = Special

  parse(⟦(lambda i e)⟧, r)            = function(i, e) if r(⟦lambda⟧) = Special

  parse(⟦(plambda i e)⟧, r)           = pfunction(i, e) if r(⟦plambda⟧) = Special

  parse(⟦(syntax i)⟧, r)              = syntax-data(i) if r(resolve(i)) ≠ PVariable

  parse(⟦(syntax i)⟧, r)              = variable(i) if r(resolve(i)) = PVariable

  parse(⟦(let-syntax (i e1) e2)⟧, r)  = syntax-binding(i, e1, e2) if r(⟦let-syntax⟧) = Special

  parse(⟦letrec-syntax (i e1) e2⟧, r) = rec-syntax-binding(i, e1, e2) if r(⟦letrec-syntax⟧) = Special
#+end_example

** Dybvig's Algorithm

1. Syntax objects are constructed using the form ~(syntax <template>)~, which behaves like ~quote~,
   except it preserves contextual information from the template.

2. Syntax objects are observed using ~syntax-case~. A use of ~syntax-case~ consists of a sequence
   of pattern-expression pairs. A pattern may be a pattern variable, a list structure, an identifier,
   or a constant. Each pattern binds its pattern variables and evaluates the expression in the
   resulting environment. Right-hand-side expressions are arbitrary Scheme expressions that
   return syntax objects.

3. Syntax objects may be compared in two different ways to determine equivalency within the
   output of a transformer: Two identifiers ~x~ and ~y~ would be ~free-identifier=?~ in an
   environment ~e~ if and only ~e(x) = e(y)~. They would be ~bound-identifier=?~ if the
   binding for one captures references to the other within its scope.

4. Context information may be stripped from or added to a syntax object by the operations.
   ~syntax->datum~ and ~datum->syntax~. The former strips the context information from a
   syntax object. The latter takes a syntax object and a Scheme datum (usually, but not always,
   a Scheme identifier) and produces the syntax object that would have been created had that
   datum appeared in the same context as the syntax object. This is useful for controlled escape
   from hygiene. There is no operation to extract the context information from a syntax object.

5. A syntax object may be *marked*. It is assumed that there is an infinite collection of
   marks ~m~. Marks have the property that if an object is marked with the mark ~m~, and
   later marked with ~m~ again, the marks cancel.

6. A syntax object is subject to substitution ~subst(e, i, s)~, which returns a syntax object
   like ~e~ except that every occurrence of the identifier ~i~ (along with its context information)
   is replaced by ~s~ (with its context information).
