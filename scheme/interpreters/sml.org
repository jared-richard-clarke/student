* An SML Interpreter for the Lambda Calculus

** Sources

| source                                           | author              |
|--------------------------------------------------+---------------------|
| *ML for the Working Programmer*, Chapter 8 and 9 | Lawrence C. Paulson |

** Lexer, Parser, Printer, and Evaluator

#+begin_src sml
  (* === Lexical Analysis | Scanning === *)

  signature KEYWORD =
    sig
      (* alphanumeric keywords — greedy match *)
      val alphas: string list
      (* symbolic keywords — non-greedy match *)
      and symbols: string list
    end;

  signature LEXICAL =
    sig
      (* token: identifier or keyword *)
      datatype token = Id  of string
                     | Key of string
      val scan : string -> token list
    end;

  (* consumes characters, ignores whitespace *)
  functor Lexical (Keyword: KEYWORD) : LEXICAL =
    struct
      datatype token = Key of string
                     | Id  of string;

      fun member (x:string, l) = List.exists (fn y => x = y) l;

      fun alphanumeric x =
          if member(x, Keyword.alphas) then Key(x) else Id(x);

      (* scans symbolic keywords *)
      fun symbolic (symbol, text) =
          case Substring.getc text of
              NONE            => (Key symbol, text)
            | SOME (x, text1) =>
                  if member(symbol, Keyword.symbols)
                     orelse not (Char.isPunct x)
                  then (Key symbol, text)
                  else symbolic (symbol ^ String.str x, text1);

      (* transforms substring into a list of tokens *)
      fun scanning (tokens, text) =
          case Substring.getc text of
              (* end of substring *)
              NONE            => rev tokens
            | SOME (x, text1) =>
                if Char.isAlphaNum x
                   (* identifier or keyword *)
                   then let val (id, text2) = Substring.splitl Char.isAlphaNum text
                            val token = alphanumeric (Substring.string id)
                        in
                          scanning (token::tokens, text2)
                        end
                else if Char.isPunct x
                (* special symbol *)
                then let val (token, text2) = symbolic (String.str x, text1)
                     in
                       scanning (token::tokens, text2)
                     end
                (* ignores whitespace: spaces, line breaks, control characters *)
                else
                     scanning (tokens, Substring.dropl (not o Char.isGraph) text);

      fun scan text = scanning([], Substring.all text);
    end;

  (*
     === Functional Parsers ===

     Top-down recursive descent parsing via parsing combinators.
  *)

  (* Infix directives: global declarations — descending order *)
  infix 6 $--;
  infix 5 --;
  infix 3 >>;
  infix 0 ||;

  signature PARSE =
    sig
      exception SyntaxErr of string

      type token

      (* identifier *)
      val id : token list -> string * token list

      (* $key, where key = keyword *)
      val $ : string -> token list -> string * token list

      (* empty *)
      val empty : 'a -> 'b list * 'a

      (* choice: px || py *)
      val || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b

      (* !!px

         If px fails, throws a syntax error.
      *)
      val !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c

      (* sequence: px -- py *)
      val -- : ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e

      (* key $-- px = $key -- px
         where key = keyword

         Parses a keyword followed by px. Either returns
         the output of px or throws an error.
      *)
      val $-- : string * (token list -> 'a * 'b) -> token list -> 'a * 'b

      (* map: px >> fn *)
      val >> : ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c

      (* repeat px

         Parses zero or more repetitions of px.
      *)
      val repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a

      (* infixes px precedence apply
         where px         = parser
               precedence = fn operator -> binding-power
               apply      = fn operator x y -> (operator x y)

         Constructs parsers for infix operators.
       *)
      val infixes :
          (token list -> 'a * token list) * (string -> int) *
          (string -> 'a -> 'a -> 'a) -> token list -> 'a * token list

      (* reader px text

         Transforms text into tokens, then applies parser px.
         Ensures parser terminates at end of file.
      *)
      val reader: (token list -> 'a * 'b list) -> string -> 'a
    end;

  (* parser: tokens → τ × tokens, where τ = phrase *)
  functor Parsing (Lex: LEXICAL) : PARSE =
    struct
      type token = Lex.token;

      exception SyntaxErr of string;

      (* identifier parser *)
      fun id (Lex.Id x::tokens) = (x, tokens)
        | id tokens = raise SyntaxErr "Identifier expected";

      (* keyword parser *)
      fun $x (Lex.Key y::tokens) = if x = y then (x, tokens) else raise SyntaxErr x
        | $x _ = raise SyntaxErr "Symbol expected";

      (* empty parser *)
      fun empty tokens = ([], tokens);

      (* choice parser combinator *)
      fun (px || py) tokens = px tokens handle SyntaxErr _ => py tokens;

      (* error parser combinator *)
      fun !! px tokens = px tokens
          handle SyntaxErr message => raise Fail ("Syntax error: " ^ message);

      (* sequence parser combinator *)
      fun (px -- py) tokens =
          let val (x, tokens2) = px tokens
              val (y, tokens3) = py tokens2
          in
            ((x, y), tokens3)
          end;

      (* map function combinator *)
      fun (px >> f) tokens =
          let val (x, tokens2) = px tokens
          in
            (f x, tokens2)
          end;

      (* keyword-phrase parser combinator *)
      fun (key $-- px) = ($key -- !!px >> #2);

      (* repeat parser combinator — zero or more *)
      fun repeat px tokens = (   px -- repeat px >> (op::)
                              || empty) tokens;

      (* infix parser combinator *)
      fun infixes (px, precedence, apply) =
        let fun over k tokens = next k (px tokens)
            and next k (x, Lex.Key(a)::tokens) =
                  if precedence a < k
                  then (x, Lex.Key a::tokens)
                  else next k ((over (precedence a) >> apply a x) tokens)
              | next k (x, tokens) = (x, tokens)
        in
          over 0
        end;

      (* parser *)
      fun reader px text =
             (case px (Lex.scan text) of
                  (x, []) => x
                | (_, _::_) => raise SyntaxErr "Extra characters in phrase");
    end;

  (*
     === Lambda Terms ===

     index -> bound variables
     name  -> free variables
  *)

  signature LAMBDA =
    sig
      datatype t = Free     of string
                 | Bound    of int
                 | Abstract of string * t
                 | Apply    of t * t
      val abstract: int -> string -> t -> t
      val absList: string list * t -> t
      val applyList: t * t list -> t
      val subst: int -> t -> t -> t
      val inst: t StringDict.t -> t -> t
    end;

  structure Lambda : LAMBDA =
    struct
      datatype t = Free     of string
                 | Bound    of int
                 | Abstract of string * t
                 | Apply    of t * t;

      (* Convert occurrences of b to bound index i in a term *)
      fun abstract i b (Free a)         = if a = b then Bound i else Free a
        | abstract i b (Bound j)        = Bound j
        | abstract i b (Abstract(a, t)) = Abstract(a, abstract (i + 1) b t)
        | abstract i b (Apply(t, u))    = Apply(abstract i b t, abstract i b u);

      (* Abstraction over several free variables *)
      fun absList (bs, t) = foldr (fn (b, u) => Abstract(b, abstract 0 b u)) t bs;

      (* Application of t to several terms *)
      fun applyList (t0, us) = foldl (fn (u, t) => Apply(t,u)) t0 us;

      (* Shift a term's non-local indices by i; d is the depth of abstractions *)
      fun shift 0 d u = u
        | shift i d (Free a)         = Free a
        | shift i d (Bound j)        = if j >= d then Bound(j + i) else Bound j
        | shift i d (Abstract(a, t)) = Abstract(a, shift i (d + 1) t)
        | shift i d (Apply(t, u))    = Apply(shift i d t, shift i d u);

      (* Substitute u for bound variable i in a term t *)
      fun subst i u (Free a)         = Free a
        | subst i u (Bound j)        = (* locally bound *)
                                       if j < i then Bound j
                                       else if j = i then shift i 0 u
                                       else (*j > i*) Bound(j - 1) (* non-local to t *)
        | subst i u (Abstract(a, t)) = Abstract(a, subst (i + 1) u t)
        | subst i u (Apply(t1, t2))  = Apply(subst i u t1, subst i u t2);

      (* Substitution for free variables *)
      fun inst env (Free a)         = (inst env (StringDict.lookup(env,a))
                                       handle StringDict.E _ => Free a)
        | inst env (Bound i)        = Bound i
        | inst env (Abstract(a, t)) = Abstract(a, inst env t)
        | inst env (Apply(t1, t2))  = Apply(inst env t1, inst env t2);
    end;

  (* === Parsing Lambda Terms === *)

  structure LambdaKey =
    struct
      val alphas = []
      and symbols = ["%", ".", "(", ")"]
    end;

  structure LambdaLex = Lexical (LambdaKey);

  structure LambdaParsing = Parsing (LambdaLex);

  signature PARSE_TERM =
    sig
      val read: string -> Lambda.t
    end;

  (* Term = "%" Id Id* Term
          | Atom Atom*

     Atom = Id
          | "(" Term ")"
  *)
  structure ParseTerm : PARSE_TERM =
    struct
      fun makeLambda ((x, xs), t) = Lambda.absList (x::xs, t);

      open LambdaParsing

      (* term/atom distinction prevents left recursion *)
      fun term tokens =
        (   "%" $-- id -- repeat id -- "." $-- term >> makeLambda
         || atom -- repeat atom                     >> Lambda.applyList
        ) tokens
      and atom tokens =
        (   id                                      >> Lambda.Free
         || "(" $-- term -- $ ")"                   >> #1
        ) tokens;
      val read = reader term;
    end;

  (* === Pretty Printing Lambda Terms === *)

  signature DISPLAY_TERM =
    sig
      val rename : string list * string -> string
      val stripAbs : Lambda.t -> string list * Lambda.t
      val pr : Lambda.t -> unit
    end;

  structure DisplayTerm : DISPLAY_TERM =
    struct
      (* Free variable in a term -- simple & slow version using append *)
      fun vars (Lambda.Free a)         = [a]
        | vars (Lambda.Bound i)        = []
        | vars (Lambda.Abstract(a, t)) = vars t
        | vars (Lambda.Apply(t1, t2))  = vars t1 @ vars t2;

      (* Rename variable "a" to avoid clashes with the strings bs. *)
      fun rename (bs, a) =
          if List.exists (fn x => x = a) bs then rename (bs, a ^ "'") else a;

      (* Remove leading lambdas; return bound variable names *)
      fun strip (bs, Lambda.Abstract(a, t)) =
            let val b = rename (vars t, a)
            in
              strip (b::bs, Lambda.subst 0 (Lambda.Free b) t)
            end
        | strip (bs, u) = (rev bs, u);

      fun stripAbs t = strip ([], t);

      fun spaceJoin (b, z) = " " ^ b ^ z;

      fun term (Lambda.Free a) = Pretty.str a
        | term (Lambda.Bound i) = Pretty.str "??UNMATCHED INDEX??"
        | term (t as Lambda.Abs _) =
              let val (b::bs, u) = stripAbs t
                  val binder = "%" ^ b ^ (foldr spaceJoin ". " bs)
              in
                Pretty.blo(0, [Pretty.str binder, term u])
              end
        | term t = Pretty.blo(0, applic t)
      and applic (Lambda.Apply(t, u)) = applic t @ [Pretty.brk 1, atom u]
        | applic t = [atom t]
      and atom (Lambda.Free a) = Pretty.str a
        | atom t = Pretty.blo(1, [Pretty.str"(",
                                  term t,
                                  Pretty.str")"]);

      fun pr t = Pretty.pr (TextIO.stdOut, term t, 50);
    end;

  (* === Evaluating Lambda Terms === *)

  signature REDUCE =
    sig
      val eval : Lambda.t -> Lambda.t
      val byValue : Lambda.t -> Lambda.t
      val headNF : Lambda.t -> Lambda.t
      val byName : Lambda.t -> Lambda.t
    end;

  structure Reduce : REDUCE =
    struct
      (* evaluation, not affecting function bodies *)
      fun eval (Lambda.Apply(t1, t2)) =
                    (case eval t1 of
                         Lambda.Abstract(a, u) => eval(Lambda.subst 0 (eval t2) u)
                       | u1 => Lambda.Apply(u1, eval t2))
        | eval t = t;

      (* normalization using call-by-value *)
      fun byValue t = bodies (eval t)
      and bodies (Lambda.Abstract(a, t)) = Lambda.Abs(a, byValue t)
        | bodies (Lambda.Apply(t1, t2))  = Lambda.Apply(bodies t1, bodies t2)
        | bodies t = t;

      (* head normal form *)
      fun headNF (Lambda.Abstract(a, t)) = Lambda.Abstract(a, headNF t)
        | headNF (Lambda.Apply(t1, t2))  =
                    (case headNF t1 of
                         Lambda.Abstract(a, t) => headNF(Lambda.subst 0 t2 t)
                       | u1                    => Lambda.Apply(u1, t2))
        | headNF t                       = t;

      (* normalization using call-by-name *)
      fun byName t = args (headNF t)
      and args (Lambda.Abstract(a, t)) = Lambda.Abstract(a, args t)
        | args (Lambda.Apply(t1, t2))  = Lambda.Apply(args t1, byName t2)
        | args t                       = t;
    end;

  (* === Constructing the Standard Environment === *)

  fun insertEnv ((a, b), env) =
      StringDict.insert (env, a, ParseTerm.read b);

  val stdEnv = foldl insertEnv StringDict.empty
    [(* booleans *)
     ("true",  "%x y.x"),
     ("false", "%x y.y"),
     ("if",    "%p x y. p x y"),

     (* ordered pairs *)
     ("pair", "%x y f.f x y"),
     ("fst",  "%p.p true"),
     ("snd",  "%p.p false"),

     (* natural numbers *)
     ("suc",    "%n f x. n f (f x)"),
     ("iszero", "%n. n (%x.false) true"),
     ("0", "%f x. x"),
     ("1", "suc 0"),
     ("2", "suc 1"),
     ("3", "suc 2"),
     ("4", "suc 3"),
     ("5", "suc 4"),
     ("6", "suc 5"),
     ("7", "suc 6"),
     ("8", "suc 7"),
     ("9", "suc 8"),

     (* operators *)
     ("add",  "%m n f x. m f (n f x)"),
     ("mult", "%m n f. m (n f)"),
     ("expt",  "%m n f x. n m f x"),
     ("prefn", "%f p. pair (f (fst p)) (fst p)"),
     ("pre",   "%n f x. snd (n (prefn f) (pair x x))"),
     ("sub",   "%m n. n pre m"),
     ("ack",   "%m. m (%f n. n f (f 1)) suc"),

     (* lists *)
     ("nil",  "%z.z"),
     ("cons", "%x y. pair false (pair x y)"),
     ("null", "fst"),
     ("hd",   "%z. fst(snd z)"),
     ("tl",   "%z. snd(snd z)"),

     (* recursion for call-by-name *)
     ("Y",       "%f. (%x.f(x x))(%x.f(x x))"),
     ("fact",    "Y (%g n. if (iszero n) 1 (mult n (g (pre n))))"),
     ("append",  "Y (%g z w. if (null z) w (cons (hd z) (g (tl z) w)))"),
     ("inflist", "Y (%z. cons MORE z)"),

     (* recursion for call-by-value *)
     ("YV",    "%f. (%x.f(%y.x x y)) (%x.f(%y.x x y))"),
     ("factV", "YV (%g n. (if (iszero n) (%y.1) (%y.mult n (g (pre n))))y)")];

  (* === program === *)

  fun stdRead a = Lambda.inst stdEnv (ParseTerm.read a);
  fun try evfn  = DisplayTerm.pr o evfn o stdRead;
#+end_src

** Pretty Printer

The pretty printer module as used by the lambda calculus program above.

#+begin_src sml
  signature PRETTY =
    sig
      type t
      val blo : int * t list -> t
      val str : string -> t
      val brk : int -> t
      val pr  : TextIO.outstream * t * int -> unit
    end;

  structure Pretty : PRETTY =
    struct
      (* compound phrases, strings, and breaks *)
      datatype t = Block  of t list * int * int (*indentation, length*)
                 | String of string
                 | Break  of int;               (*length*)

    (* Add the lengths of the expressions until the next Break; if no Break then
       include "after", to account for text following this block. *)
    fun breakdist (Block(_, _, len)::es, after) = len + breakdist (es, after)
      | breakdist (String s::es, after)         = size s + breakdist (es, after)
      | breakdist (Break _::es, after)          = 0
      | breakdist ([], after)                   = after;

    fun pr (os, e, margin) =
      let val space = ref margin

          fun blanks n = (TextIO.output(os, StringCvt.padLeft #" " n ""); space := !space - n)

          fun newline () = (TextIO.output(os, "\n"); space := margin)

          fun printing ([], _, _)                 = ()
            | printing (e::es, blockspace, after) =
                (case e of
                   Block(bes, indent, len) => printing(bes, !space-indent, breakdist(es,after))
                 | String s                => (TextIO.output(os, s); space := !space - size s)
                 | Break len               => if len + breakdist(es, after) <= !space 
                                              then blanks len
                                              else (newline(); blanks(margin-blockspace));
             printing (es, blockspace, after))
      in
        printing([e], margin, 0);
        newline()
      end; 

    fun length (Block(_, _, len)) = len
      | length (String s)         = size s
      | length (Break len)        = len;

    val str = String
    and brk = Break;

    fun blo (indent,es) =
      let fun sum([], k)    = k
            | sum(e::es, k) = sum(es, length e + k)
      in
        Block(es, indent, sum(es, 0))
      end;
  end;
#+end_src
