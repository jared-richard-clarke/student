* Zig's ArrayList

To better understand Rust's ~Vec~, I included selected code from Zig's ~ArrayList~.
Same data structure, different implementations.

#+begin_src zig
  const std = @import("std.zig");
  const debug = std.debug;
  const assert = debug.assert;
  const mem = std.mem;
  const math = std.math;
  const Allocator = mem.Allocator;
  const ArrayList = std.ArrayList;

  /// A contiguous, growable list of arbitrarily aligned items in memory.
  /// This is a wrapper around an array of T values aligned to `alignment`-byte
  /// addresses. If the specified alignment is `null`, then `@alignOf(T)` is used.
  ///
  /// Functions that potentially allocate memory accept an `Allocator` parameter.
  /// Initialize directly or with `initCapacity`, and deinitialize with `deinit`
  /// or use `toOwnedSlice`.
  ///
  /// Default initialization of this struct is deprecated; use `.empty` instead.
  pub fn Aligned(comptime T: type, comptime alignment: ?mem.Alignment) type {
      if (alignment) |a| {
          if (a.toByteUnits() == @alignOf(T)) {
              return Aligned(T, null);
          }
      }
      return struct {
          const Self = @This();

          items: Slice = &[_]T{},

          capacity: usize = 0,

          pub const empty: Self = .{
              .items = &.{},
              .capacity = 0,
          };

          pub const Slice = if (alignment) |a| ([]align(a.toByteUnits()) T) else []T;

          pub fn SentinelSlice(comptime s: T) type {
              return if (alignment) |a| ([:s]align(a.toByteUnits()) T) else [:s]T;
          }

          pub fn initCapacity(gpa: Allocator, num: usize) Allocator.Error!Self {
              var self = Self{};
              try self.ensureTotalCapacityPrecise(gpa, num);
              return self;
          }

          pub fn initBuffer(buffer: Slice) Self {
              return .{
                  .items = buffer[0..0],
                  .capacity = buffer.len,
              };
          }

          pub fn deinit(self: *Self, gpa: Allocator) void {
              gpa.free(self.allocatedSlice());
              self.* = undefined;
          }

          pub fn fromOwnedSlice(slice: Slice) Self {
              return Self{
                  .items = slice,
                  .capacity = slice.len,
              };
          }

          pub fn fromOwnedSliceSentinel(comptime sentinel: T, slice: [:sentinel]T) Self {
              return Self{
                  .items = slice,
                  .capacity = slice.len + 1,
              };
          }

          pub fn clone(self: Self, gpa: Allocator) Allocator.Error!Self {
              var cloned = try Self.initCapacity(gpa, self.capacity);
              cloned.appendSliceAssumeCapacity(self.items);
              return cloned;
          }

          pub fn insert(self: *Self, gpa: Allocator, i: usize, item: T) Allocator.Error!void {
              const dst = try self.addManyAt(gpa, i, 1);
              dst[0] = item;
          }

          pub fn insertAssumeCapacity(self: *Self, i: usize, item: T) void {
              assert(self.items.len < self.capacity);
              self.items.len += 1;

              @memmove(self.items[i + 1 .. self.items.len], self.items[i .. self.items.len - 1]);
              self.items[i] = item;
          }

          pub fn insertBounded(self: *Self, i: usize, item: T) error{OutOfMemory}!void {
              if (self.capacity - self.items.len == 0) return error.OutOfMemory;
              return insertAssumeCapacity(self, i, item);
          }

          pub fn addManyAt(
              self: *Self,
              gpa: Allocator,
              index: usize,
              count: usize,
          ) Allocator.Error![]T {
              var managed = self.toManaged(gpa);
              defer self.* = managed.moveToUnmanaged();
              return managed.addManyAt(index, count);
          }

          pub fn addManyAtAssumeCapacity(self: *Self, index: usize, count: usize) []T {
              const new_len = self.items.len + count;
              assert(self.capacity >= new_len);
              const to_move = self.items[index..];
              self.items.len = new_len;
              @memmove(self.items[index + count ..][0..to_move.len], to_move);
              const result = self.items[index..][0..count];
              @memset(result, undefined);
              return result;
          }

          pub fn addManyAtBounded(self: *Self, index: usize, count: usize) error{OutOfMemory}![]T {
              if (self.capacity - self.items.len < count) return error.OutOfMemory;
              return addManyAtAssumeCapacity(self, index, count);
          }

          pub fn insertSlice(
              self: *Self,
              gpa: Allocator,
              index: usize,
              items: []const T,
          ) Allocator.Error!void {
              const dst = try self.addManyAt(
                  gpa,
                  index,
                  items.len,
              );
              @memcpy(dst, items);
          }

          pub fn insertSliceAssumeCapacity(
              self: *Self,
              index: usize,
              items: []const T,
          ) void {
              const dst = self.addManyAtAssumeCapacity(index, items.len);
              @memcpy(dst, items);
          }

          pub fn insertSliceBounded(
              self: *Self,
              index: usize,
              items: []const T,
          ) error{OutOfMemory}!void {
              const dst = try self.addManyAtBounded(index, items.len);
              @memcpy(dst, items);
          }

          pub fn append(self: *Self, gpa: Allocator, item: T) Allocator.Error!void {
              const new_item_ptr = try self.addOne(gpa);
              new_item_ptr.* = item;
          }

          pub fn appendAssumeCapacity(self: *Self, item: T) void {
              self.addOneAssumeCapacity().* = item;
          }

          pub fn appendBounded(self: *Self, item: T) error{OutOfMemory}!void {
              if (self.capacity - self.items.len == 0) return error.OutOfMemory;
              return appendAssumeCapacity(self, item);
          }

          pub fn appendSlice(self: *Self, gpa: Allocator, items: []const T) Allocator.Error!void {
              try self.ensureUnusedCapacity(gpa, items.len);
              self.appendSliceAssumeCapacity(items);
          }

          pub fn appendSliceAssumeCapacity(self: *Self, items: []const T) void {
              const old_len = self.items.len;
              const new_len = old_len + items.len;
              assert(new_len <= self.capacity);
              self.items.len = new_len;
              @memcpy(self.items[old_len..][0..items.len], items);
          }

          pub fn appendSliceBounded(self: *Self, items: []const T) error{OutOfMemory}!void {
              if (self.capacity - self.items.len < items.len) return error.OutOfMemory;
              return appendSliceAssumeCapacity(self, items);
          }

          pub fn print(self: *Self, gpa: Allocator, comptime fmt: []const u8, args: anytype) error{OutOfMemory}!void {
              comptime assert(T == u8);
              try self.ensureUnusedCapacity(gpa, fmt.len);
              var aw: std.Io.Writer.Allocating = .fromArrayList(gpa, self);
              defer self.* = aw.toArrayList();
              return aw.writer.print(fmt, args) catch |err| switch (err) {
                  error.WriteFailed => return error.OutOfMemory,
              };
          }

          pub fn printAssumeCapacity(self: *Self, comptime fmt: []const u8, args: anytype) void {
              comptime assert(T == u8);
              var w: std.Io.Writer = .fixed(self.unusedCapacitySlice());
              w.print(fmt, args) catch unreachable;
              self.items.len += w.end;
          }

          pub fn printBounded(self: *Self, comptime fmt: []const u8, args: anytype) error{OutOfMemory}!void {
              comptime assert(T == u8);
              var w: std.Io.Writer = .fixed(self.unusedCapacitySlice());
              w.print(fmt, args) catch return error.OutOfMemory;
              self.items.len += w.end;
          }

          pub fn resize(self: *Self, gpa: Allocator, new_len: usize) Allocator.Error!void {
              try self.ensureTotalCapacity(gpa, new_len);
              self.items.len = new_len;
          }

          pub fn shrinkAndFree(self: *Self, gpa: Allocator, new_len: usize) void {
              assert(new_len <= self.items.len);

              if (@sizeOf(T) == 0) {
                  self.items.len = new_len;
                  return;
              }

              const old_memory = self.allocatedSlice();
              if (gpa.remap(old_memory, new_len)) |new_items| {
                  self.capacity = new_items.len;
                  self.items = new_items;
                  return;
              }

              const new_memory = gpa.alignedAlloc(T, alignment, new_len) catch |e| switch (e) {
                  error.OutOfMemory => {
                      // No problem, capacity is still correct then.
                      self.items.len = new_len;
                      return;
                  },
              };

              @memcpy(new_memory, self.items[0..new_len]);
              gpa.free(old_memory);
              self.items = new_memory;
              self.capacity = new_memory.len;
          }

          pub fn shrinkRetainingCapacity(self: *Self, new_len: usize) void {
              assert(new_len <= self.items.len);
              self.items.len = new_len;
          }

          pub fn clearRetainingCapacity(self: *Self) void {
              self.items.len = 0;
          }

          pub fn clearAndFree(self: *Self, gpa: Allocator) void {
              gpa.free(self.allocatedSlice());
              self.items.len = 0;
              self.capacity = 0;
          }

          pub fn ensureTotalCapacity(self: *Self, gpa: Allocator, new_capacity: usize) Allocator.Error!void {
              if (self.capacity >= new_capacity) return;
              return self.ensureTotalCapacityPrecise(gpa, growCapacity(self.capacity, new_capacity));
          }

          pub fn ensureTotalCapacityPrecise(self: *Self, gpa: Allocator, new_capacity: usize) Allocator.Error!void {
              if (@sizeOf(T) == 0) {
                  self.capacity = math.maxInt(usize);
                  return;
              }

              if (self.capacity >= new_capacity) return;

              const old_memory = self.allocatedSlice();
              if (gpa.remap(old_memory, new_capacity)) |new_memory| {
                  self.items.ptr = new_memory.ptr;
                  self.capacity = new_memory.len;
              } else {
                  const new_memory = try gpa.alignedAlloc(T, alignment, new_capacity);
                  @memcpy(new_memory[0..self.items.len], self.items);
                  gpa.free(old_memory);
                  self.items.ptr = new_memory.ptr;
                  self.capacity = new_memory.len;
              }
          }

          pub fn ensureUnusedCapacity(
              self: *Self,
              gpa: Allocator,
              additional_count: usize,
          ) Allocator.Error!void {
              return self.ensureTotalCapacity(gpa, try addOrOom(self.items.len, additional_count));
          }

          pub fn expandToCapacity(self: *Self) void {
              self.items.len = self.capacity;
          }

          pub fn addOne(self: *Self, gpa: Allocator) Allocator.Error!*T {
              // This can never overflow because `self.items` can never occupy the whole address space
              const newlen = self.items.len + 1;
              try self.ensureTotalCapacity(gpa, newlen);
              return self.addOneAssumeCapacity();
          }

          pub fn addOneAssumeCapacity(self: *Self) *T {
              assert(self.items.len < self.capacity);

              self.items.len += 1;
              return &self.items[self.items.len - 1];
          }

          pub fn addOneBounded(self: *Self) error{OutOfMemory}!*T {
              if (self.capacity - self.items.len < 1) return error.OutOfMemory;
              return addOneAssumeCapacity(self);
          }

          pub fn addManyAsArray(self: *Self, gpa: Allocator, comptime n: usize) Allocator.Error!*[n]T {
              const prev_len = self.items.len;
              try self.resize(gpa, try addOrOom(self.items.len, n));
              return self.items[prev_len..][0..n];
          }

          pub fn addManyAsArrayAssumeCapacity(self: *Self, comptime n: usize) *[n]T {
              assert(self.items.len + n <= self.capacity);
              const prev_len = self.items.len;
              self.items.len += n;
              return self.items[prev_len..][0..n];
          }

          pub fn addManyAsArrayBounded(self: *Self, comptime n: usize) error{OutOfMemory}!*[n]T {
              if (self.capacity - self.items.len < n) return error.OutOfMemory;
              return addManyAsArrayAssumeCapacity(self, n);
          }

          pub fn pop(self: *Self) ?T {
              if (self.items.len == 0) return null;
              const val = self.items[self.items.len - 1];
              self.items.len -= 1;
              return val;
          }

          pub fn allocatedSlice(self: Self) Slice {
              return self.items.ptr[0..self.capacity];
          }

          pub fn unusedCapacitySlice(self: Self) []T {
              return self.allocatedSlice()[self.items.len..];
          }

          pub fn getLast(self: Self) T {
              const val = self.items[self.items.len - 1];
              return val;
          }

          pub fn getLastOrNull(self: Self) ?T {
              if (self.items.len == 0) return null;
              return self.getLast();
          }

          const init_capacity = @as(comptime_int, @max(1, std.atomic.cache_line / @sizeOf(T)));

          pub fn growCapacity(current: usize, minimum: usize) usize {
              var new = current;
              while (true) {
                  new +|= new / 2 + init_capacity;
                  if (new >= minimum)
                      return new;
              }
          }
      };
  }

  fn addOrOom(a: usize, b: usize) error{OutOfMemory}!usize {
      const result, const overflow = @addWithOverflow(a, b);
      if (overflow != 0) return error.OutOfMemory;
      return result;
  }
#+end_src
