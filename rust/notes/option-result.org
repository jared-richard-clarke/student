* Recoverable Errors and Optional Values

** Sources

| source                          | author                          |
|---------------------------------+---------------------------------|
| *The Rust Programming Language* | Steve Klabnik and Carol Nichols |

** Handling Errors With ~Result<T, E>~

*** Match Expressions

#+begin_src rust
  use std::fs::File;
  use std::io::ErrorKind;
  fn main() {
      let greeting_file_result = File::open("hello.txt");
      let greeting_file = match greeting_file_result {
          Ok(file) => file,
          Err(error) => match error.kind() {
              ErrorKind::NotFound => match File::create("hello.txt") {
                  Ok(fc) => fc,
                  Err(e) => panic!("Problem creating the file: {:?}", e),
              },
              other_error => {
                  panic!("Problem opening the file: {:?}", other_error);
              }
          },
      };
  }
#+end_src

*** Closures

#+begin_src rust
  use std::fs::File;
  use std::io::ErrorKind;
  fn main() {
      let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
          if error.kind() == ErrorKind::NotFound {
              File::create("hello.txt").unwrap_or_else(|error| {
                  panic!("Problem creating the file: {:?}", error);
              })
          } else {
              panic!("Problem opening the file: {:?}", error);
          }
      });
  }
#+end_src

*** ~unwrap~

Unwraps the value inside the ~Ok~ variant of the ~Result~ enum. Otherwise panics,
using the message provided by the ~Err~ variant.

#+begin_src rust
  use std::fs::File;

  fn main() {
      let greeting_file = File::open("hello.txt").unwrap();
  }

  // "unwrap" as defined for "Result" in the standard library.
  fn unwrap(self) -> T
  where
      E: fmt::Debug,
  {
      match self {
	  Ok(t) => t,
	  Err(e) => unwrap_failed("called `Result::unwrap()` on an `Err` value", &e),
      }
  }

  // "expect" as defined for "Result" in the standard library.
  // Similar to "unwrap" but adds a user-supplied message.
  pub fn expect(self, msg: &str) -> T
  where
      E: fmt::Debug,
  {
      match self {
          Ok(t) => t,
          Err(e) => unwrap_failed(msg, &e),
      }
  }
#+end_src

** Error Propagation

*** Match Expressions

#+begin_src rust
  use std::fs::File;
  use std::io::{self, Read};

  fn main() {
      fn read_username_from_file() -> Result<String, io::Error> {
          let username_file_result = File::open("hello.txt");

          let mut username_file = match username_file_result {
              Ok(file) => file,
              Err(e) => return Err(e),
          };

          let mut username = String::new();

          match username_file.read_to_string(&mut username) {
              Ok(_) => Ok(username),
              Err(e) => Err(e),
          }
      }
  }
#+end_src

*** The ~?~ Operator

#+begin_src rust
  use std::fs::File;
  use std::io;
  use std::io::Read;

  fn main() {
      fn read_username_from_file() -> Result<String, io::Error> {
          let mut username = String::new();

          File::open("hello.txt")?.read_to_string(&mut username)?;

          Ok(username)
      }
  }
#+end_src

The ~?~ operator can only be used in functions that return ~Result~ or ~Option~.
In order to propagate errors in the main executable, ~main~ must return the
~Result~ type. The ~main~ function may return any types that implement the
~std::process::Termination~ trait.

#+begin_src rust
  use std::error::Error;
  use std::fs::File;

  fn main() -> Result<(), Box<dyn Error>> {
      let greeting_file = File::open("hello.txt")?;

      Ok(())
  }
#+end_src

** Rust: ~Option<T>~

*** Bottom Values

Bottom value ~null~ is useful but difficult to use safely. If a program uses ~null~
as if it were a not-null value, an error will be thrown. Rust provides ~Option<T>~
â€” an enum that encodes a value that is either present or absent.

#+begin_src rust
  // The "Option" type as defined in the standard library.
  enum Option<T> {
      None,
      Some(T),
  }
#+end_src

*** ~unwrap~

Unwraps the value contained in the ~Some~ variant of the ~Option~ enum.
Panics otherwise.

#+begin_src rust
  impl<T> Option<T> {
      fn unwrap(self) -> T {
          match self {
              Some(t) => t,
              None => panic("called 'Option::unwrap()' on a 'None' value"),
          }
      }
  }
#+end_src

*** ~unwrap_or~

Returns the value contained in ~Some~ or returns a default value as provided by the caller.

#+begin_src rust
  impl<T> Option<T> {
      fn unwrap_or(self, default: T) -> T {
          match self {
              Some(t) => t,
              None => default
          }
      }
  }
#+end_src

*** ~unwrap_or_else~ ( simplified )

#+begin_src rust
  impl<T> Option<T> {
      pub fn unwrap_or_else<F>(self, f: F) -> T
      where
          F: FnOnce() -> T
      {
          match self {
              Some(x) => x,
              None => f(),
          }
      }
  }
#+end_src
