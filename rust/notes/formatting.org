* Text Formatting in Rust

** Sources

| source                                        | author        |
|-----------------------------------------------+---------------|
| *The Rust Standard Library*, version 1.80.1   | rust-lang.org |
| *Behind the Scenes of Rust String Formatting* | Mara Bos      |

** Module ~fmt~

Provides utilities for formatting and printing ~Strings~.

- ~format!~ :: Creates a ~String~ using the interpolation of runtime expressions.

- ~format(args: Arguments<'_>) -> String~ :: Function takes an ~Arguments~ struct
  and returns the resulting formatted string.

- ~write!~ and ~writeln!~ :: Writes a formatted string to a specified stream without
  intermediate allocations. Macro invokes the ~write_fmt~ function defined on
  the ~std::io::Write~ and ~std::fmt::Write~ traits.

- ~write(output: &mut dyn Write, args: Arguments<'_>) -> Result<(), Error>~ :: Writes the contents
  of an ~Arguments~ struct to the provided output stream that implements the ~Write~ trait.

- ~print!~ and ~println!~ :: Writes a formatted string directly to ~stdout~.

- ~eprint!~ and ~eprintln!~ :: Writes a formatted string directly to ~stderr~

- ~format_args!~ :: A macro used to safely pass around an opaque object describing a
  formatted string. All macros in the format family are implemented in terms of ~format_args!~.

#+begin_quote
  "The provided ~write_fmt~ method simply calls ~std::fmt::write()~, which is the only function
   that knows how to "execute" the formatting instructions contained in a ~fmt::Arguments~ type.
   It calls ~write_str~ for the static parts of the template, and it will call the right
   ~Display::fmt~ (or ~LowerHex::fmt~, etc.) functions for the arguments, which will also result
   in calls to ~write_str~ down the line."

  — *Behind the Scenes of Rust String Formatting*, Mara Bos
#+end_quote

#+begin_src rust
  macro_rules! format {
      ($($arg::tt)*) => {{
          let text = $crate::fmt::format($crate::__export::format_args!($($arg)*));
          text
      }}
  }

  macro_rules! write {
      ($dst:expr, $($arg:tt)*) => {
          $dst.write_fmt($crate::format_args!($($arg)*))
      };
  }

  macro_rules! writeln {
      ($dst:expr $(,)?) => {
          $crate::write!($dst, "\n")
      };
      ($dst:expr, $($arg:tt)*) => {
          $dst.write_fmt($crate::format_args_nl!($($arg)*))
      };
  }

  macro_rules! print {
      ($($arg:tt)*) => {{
          $crate::io::_print($crate::format_args!($($arg)*));
      }};
  }

  macro_rules! println {
      () => {
          $crate::print!("\n")
      };
      ($($arg:tt)*) => {{
          $crate::io::_print($crate::format_args_nl!($($arg)*));
      }};
  }

  macro_rules! eprint {
      ($($arg:tt)*) => {{
          $crate::io::_eprint($crate::format_args!($($arg)*));
      }};
  }

  macro_rules! eprintln {
      () => {
          $crate::eprint!("\n")
      };
      ($($arg:tt)*) => {{
          $crate::io::_eprint($crate::format_args_nl!($($arg)*));
      }};
  }
#+end_src

** Type ~Arguments~

A safely precompiled version of a format string and its arguments. An opaque object
generated by the ~format_args!~ macro at compile time. It is the central type of
the ~fmt~ module.

#+begin_src rust
  // Produces value of type "fmt::Arguments"
  macro_rules! format_args {
      ($fmt:expr) => {{ /* compiler built-in */ }};
      ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};
  }

  // A safely precompiled version of a format string and its arguments.
  struct Arguments<'a> {
      // String Literals.
      pieces: &'a [&'static str],
      // Placeholder specifications. "None" if all specs are default — as in "{}{}".
      placeholders: Option<&'a [Placeholder]>,
      // Dynamic arguments for interpolation, to be interleaved with
      // string literals.
      args: &'a [Argument<'a>],
  }

  Placeholder {
      position: usize,
      fill: char,
      align: Alignment,
      flags: u32,
      precision: Count,
      width: Count,
  }

  enum Alignment {
      Left,
      Right,
      Center,
      Unknown,
  }

  // Used by "width" and "precision" specifiers.
  enum Count {
      // Specified with a literal number. Stores the value.
      Is(usize),
      // Specified using "$" and "*" syntaxes. Stores the index into "args".
      Param(usize),
      // Not specified.
      Implied,
  }

  // A generic argument that is taken by "format_args!()".
  struct Argument<'a> {
      ty: ArgumentType<'a>,
  }

  enum ArgumentType<'a> {
    // Contains two pointers: a reference to the argument itself and
    // a function pointer that implements a particular formatting trait.
    Placeholder { value: &'a Opaque, formatter: fn(&Opaque, &mut Formatter<'_>) -> Result },
    Count(usize),
  }
#+end_src

** Syntax

#+begin_example
  format_string := text [ maybe_format text ] *
  maybe_format  := '{' '{' | '}' '}' | format
  format        := '{' [ argument ] [ ':' format_spec ] [ ws ] * '}'
  argument      := integer | identifier

  format_spec   := [[fill]align][sign]['#']['0'][width]['.' precision]type
  fill          := character
  align         := '<' | '^' | '>'
  sign          := '+' | '-'
  width         := count
  precision     := count | '*'
  type          := '' | '?' | 'x?' | 'X?' | identifier
  count         := parameter | integer
  parameter     := argument '$'
#+end_example

** Formatting Traits

| specifier | trait                               |
|-----------+-------------------------------------|
| nothing   | ~Display~                           |
| ~?~       | ~Debug~                             |
| ~x?~      | ~Debug~ with lower-case hexadecimal |
| ~X?~      | ~Debug~ with upper-case hexadecimal |
| ~o~       | ~Octal~                             |
| ~x~       | ~LowerHex~                          |
| ~X~       | ~UpperHex~                          |
| ~p~       | ~Pointer~                           |
| ~b~       | ~Binary~                            |
| ~e~       | ~LowerExp~                          |
| ~E~       | ~UpperExp~                          |

#+begin_src rust
  // Required type signature of all formatting traits. Types that implement this
  // method typically write formatted text into "Formatter" using the "write!" macro.
  // Example: write!(formatter, "{:?}", self.field)
  fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>;

  // "Formatter" acts as a text buffer containing optional methods
  // for altering a particular type's textual representation according
  // to arguments provided in a format string.
  //
  // A "Formatter" is created internally by functions such as "write". Its fields
  // are typically filled in by an "Arguments" struct.
  struct Formatter<'a> {
      flags: u32,
      fill: char,
      align: Alignment,
      width: Option<usize>,
      precision: Option<usize>,

      // A mutable reference to a trait object that implements "Write".
      // A dynamic reference to a text buffer.
      buf: &'a mut (dyn Write + 'a),
  }
#+end_src

** ~format_args!~ to ~Arguments~

#+begin_src rust
  // === Example 1 ===

  format_args!("{0} {0:?} {1:x}", a, b)

  // - expands ->

  fmt::Arguments {
      pieces: &["", " ", " "],
      placeholders: None,
      args: &[
          fmt::Argument::new(&a, Display::fmt),
          fmt::Argument::new(&a, Debug::fmt),
          fmt::Argument::new(&b, LowerHex::fmt),
      ],
  }

  // === Example 2 ===

  format_args!("{0:?} {0:#?}", a)

  // - expands ->

  fmt::Arguments {
    pieces: &["", " "],
    placeholders: Some(&[
        fmt::Placeholder { position: 0, ..default() },
        fmt::Placeholder { position: 0, flags: 4 /* alternate */, ..default() },
    ]),
    args: &[
        fmt::Argument::new(&a, Debug::fmt),
    ],
  }
#+end_src
